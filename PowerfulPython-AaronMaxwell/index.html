<html><head><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link href="style.css" rel="stylesheet" type="text/css" /><title>B074JG8W8Z EBOK</title></head><body><div class="pcalibre1 pcalibre calibre" id="calibre_link-61">
<h1 class="pcalibre1 pcalibre calibre1">Powerful Python</h1>
<nav id="calibre_link-165" type="toc" class="calibre2 pcalibre1 pcalibre">
<h2 class="pcalibre1 pcalibre calibre1">Table of Contents</h2>
<ol class="pcalibre1 calibre3 pcalibre">
<li value="1" class="pcalibre1 pcalibre calibre4"><a href="#calibre_link-62" class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4">Doing More with Python</a>
<ol class="pcalibre1 calibre3 pcalibre">
<li value="1" class="pcalibre1 pcalibre calibre4"><a href="#calibre_link-63" class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4">Python Versions</a></li>
<li value="2" class="pcalibre1 pcalibre calibre4"><a href="#calibre_link-64" class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4">Python Application Environments</a></li>
<li value="3" class="pcalibre1 pcalibre calibre4"><a href="#calibre_link-65" class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4">Python Package Management</a></li>
</ol>
</li>
<li value="2" class="pcalibre1 pcalibre calibre4"><a href="#calibre_link-66" class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4">Scaling With Generators</a>
<ol class="pcalibre1 calibre3 pcalibre">
<li value="1" class="pcalibre1 pcalibre calibre4"><a href="#calibre_link-67" class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4">Iteration in Python</a></li>
<li value="2" class="pcalibre1 pcalibre calibre4"><a href="#calibre_link-68" class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4">Generator Functions</a></li>
<li value="3" class="pcalibre1 pcalibre calibre4"><a href="#calibre_link-69" class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4">Generator Patterns and Scalable Composability</a></li>
<li value="4" class="pcalibre1 pcalibre calibre4"><a href="#calibre_link-70" class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4">Python is Filled With Iterators</a></li>
<li value="5" class="pcalibre1 pcalibre calibre4"><a href="#calibre_link-71" class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4">The Iterator Protocol</a></li>
</ol>
</li>
<li value="3" class="pcalibre1 pcalibre calibre4"><a href="#calibre_link-72" class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4">Creating Collections with Comprehensions</a>
<ol class="pcalibre1 calibre3 pcalibre">
<li value="1" class="pcalibre1 pcalibre calibre4"><a href="#calibre_link-73" class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4">List Comprehensions</a></li>
<li value="2" class="pcalibre1 pcalibre calibre4"><a href="#calibre_link-74" class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4">Formatting For Readability (And More)</a></li>
<li value="3" class="pcalibre1 pcalibre calibre4"><a href="#calibre_link-75" class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4">Multiple Sources and Filters</a></li>
<li value="4" class="pcalibre1 pcalibre calibre4"><a href="#calibre_link-76" class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4">Comprehensions and Generators</a></li>
<li value="5" class="pcalibre1 pcalibre calibre4"><a href="#calibre_link-77" class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4">Dictionaries, Sets, and Tuples</a></li>
<li value="6" class="pcalibre1 pcalibre calibre4"><a href="#calibre_link-78" class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4">Limits of Comprehensions</a></li>
</ol>
</li>
<li value="4" class="pcalibre1 pcalibre calibre4"><a href="#calibre_link-79" class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4">Advanced Functions</a>
<ol class="pcalibre1 calibre3 pcalibre">
<li value="1" class="pcalibre1 pcalibre calibre4"><a href="#calibre_link-80" class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4">Accepting &amp; Passing Variable Arguments</a></li>
<li value="2" class="pcalibre1 pcalibre calibre4"><a href="#calibre_link-81" class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4">Functions As Objects</a></li>
<li value="3" class="pcalibre1 pcalibre calibre4"><a href="#calibre_link-82" class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4">Key Functions in Python</a></li>
</ol>
</li>
<li value="5" class="pcalibre1 pcalibre calibre4"><a href="#calibre_link-83" class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4">Decorators</a>
<ol class="pcalibre1 calibre3 pcalibre">
<li value="1" class="pcalibre1 pcalibre calibre4"><a href="#calibre_link-84" class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4">The Basic Decorator</a></li>
<li value="2" class="pcalibre1 pcalibre calibre4"><a href="#calibre_link-85" class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4">Data In Decorators</a></li>
<li value="3" class="pcalibre1 pcalibre calibre4"><a href="#calibre_link-86" class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4">Decorators That Take Arguments</a></li>
<li value="4" class="pcalibre1 pcalibre calibre4"><a href="#calibre_link-87" class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4">Class-based Decorators</a></li>
<li value="5" class="pcalibre1 pcalibre calibre4"><a href="#calibre_link-88" class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4">Decorators For Classes</a></li>
<li value="6" class="pcalibre1 pcalibre calibre4"><a href="#calibre_link-89" class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4">Preserving the Wrapped Function</a></li>
</ol>
</li>
<li value="6" class="pcalibre1 pcalibre calibre4"><a href="#calibre_link-90" class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4">Exceptions and Errors</a>
<ol class="pcalibre1 calibre3 pcalibre">
<li value="1" class="pcalibre1 pcalibre calibre4"><a href="#calibre_link-91" class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4">The Basic Idea</a></li>
<li value="2" class="pcalibre1 pcalibre calibre4"><a href="#calibre_link-92" class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4">Exceptions Are Objects</a></li>
<li value="3" class="pcalibre1 pcalibre calibre4"><a href="#calibre_link-93" class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4">Raising Exceptions</a></li>
<li value="4" class="pcalibre1 pcalibre calibre4"><a href="#calibre_link-94" class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4">Catching And Re-raising</a></li>
<li value="5" class="pcalibre1 pcalibre calibre4"><a href="#calibre_link-95" class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4">The Most Diabolical Python Anti-Pattern</a></li>
</ol>
</li>
<li value="7" class="pcalibre1 pcalibre calibre4"><a href="#calibre_link-96" class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4">Classes and Objects: Beyond The Basics</a>
<ol class="pcalibre1 calibre3 pcalibre">
<li value="1" class="pcalibre1 pcalibre calibre4"><a href="#calibre_link-97" class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4">Quick Note on Python 2</a></li>
<li value="2" class="pcalibre1 pcalibre calibre4"><a href="#calibre_link-98" class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4">Properties</a></li>
<li value="3" class="pcalibre1 pcalibre calibre4"><a href="#calibre_link-99" class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4">The Factory Patterns</a></li>
<li value="4" class="pcalibre1 pcalibre calibre4"><a href="#calibre_link-100" class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4">The Observer Pattern</a></li>
<li value="5" class="pcalibre1 pcalibre calibre4"><a href="#calibre_link-101" class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4">Magic Methods</a></li>
<li value="6" class="pcalibre1 pcalibre calibre4"><a href="#calibre_link-102" class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4">Rebelliously Misusing Magic Methods</a></li>
</ol>
</li>
<li value="8" class="pcalibre1 pcalibre calibre4"><a href="#calibre_link-103" class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4">Automated Testing and TDD</a>
<ol class="pcalibre1 calibre3 pcalibre">
<li value="1" class="pcalibre1 pcalibre calibre4"><a href="#calibre_link-104" class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4">What is Test-Driven Development?</a></li>
<li value="2" class="pcalibre1 pcalibre calibre4"><a href="#calibre_link-105" class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4">Unit Tests And Simple Assertions</a></li>
<li value="3" class="pcalibre1 pcalibre calibre4"><a href="#calibre_link-106" class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4">Fixtures And Common Test Setup</a></li>
<li value="4" class="pcalibre1 pcalibre calibre4"><a href="#calibre_link-107" class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4">Asserting Exceptions</a></li>
<li value="5" class="pcalibre1 pcalibre calibre4"><a href="#calibre_link-108" class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4">Using Subtests</a></li>
<li value="6" class="pcalibre1 pcalibre calibre4"><a href="#calibre_link-109" class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4">Final Thoughts</a></li>
</ol>
</li>
<li value="9" class="pcalibre1 pcalibre calibre4"><a href="#calibre_link-110" class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4">String Formatting</a>
<ol class="pcalibre1 calibre3 pcalibre">
<li value="1" class="pcalibre1 pcalibre calibre4"><a href="#calibre_link-111" class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4">Replacing Fields</a></li>
<li value="2" class="pcalibre1 pcalibre calibre4"><a href="#calibre_link-112" class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4">Number Formats (and "Format Specs")</a></li>
<li value="3" class="pcalibre1 pcalibre calibre4"><a href="#calibre_link-113" class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4">Width, Alignment, and Fill</a></li>
<li value="4" class="pcalibre1 pcalibre calibre4"><a href="#calibre_link-114" class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4">F-Strings</a></li>
<li value="5" class="pcalibre1 pcalibre calibre4"><a href="#calibre_link-115" class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4">Percent Formatting</a></li>
</ol>
</li>
<li value="10" class="pcalibre1 pcalibre calibre4"><a href="#calibre_link-116" class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4">Logging in Python</a>
<ol class="pcalibre1 calibre3 pcalibre">
<li value="1" class="pcalibre1 pcalibre calibre4"><a href="#calibre_link-117" class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4">The Basic Interface</a></li>
<li value="2" class="pcalibre1 pcalibre calibre4"><a href="#calibre_link-118" class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4">Configuring The Basic Interface</a></li>
<li value="3" class="pcalibre1 pcalibre calibre4"><a href="#calibre_link-119" class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4">Passing Arguments</a></li>
<li value="4" class="pcalibre1 pcalibre calibre4"><a href="#calibre_link-120" class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4">Beyond Basic: Loggers</a></li>
<li value="5" class="pcalibre1 pcalibre calibre4"><a href="#calibre_link-121" class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4">Log Destinations: Handlers and Streams</a></li>
<li value="6" class="pcalibre1 pcalibre calibre4"><a href="#calibre_link-122" class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4">Logging to Multiple Destinations</a></li>
<li value="7" class="pcalibre1 pcalibre calibre4"><a href="#calibre_link-123" class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4">Record Layout with Formatters</a></li>
</ol>
</li>
<li value="11" class="pcalibre1 pcalibre calibre4"><a href="#calibre_link-124" class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4">What’s Next?</a></li>
</ol>
</nav>
</div>


<div id="calibre_link-23" class="pcalibre1 pcalibre calibre">
<section class="calibre2 pcalibre1 pcalibre" id="calibre_link-166" title="Doing More with Python" type="chapter">
<header id="calibre_link-62" class="calibre2 pcalibre1 pcalibre">
<div class="pcalibre1 pcalibre chapter-header">
<h1 class="pcalibre1 chapter-title pcalibre"> <small class="subtitle pcalibre1 pcalibre"><b id="calibre_link-167" class="pcalibre1 pcalibre calibre6">DOING</b> <b class="pcalibre1 pcalibre calibre6">MORE</b> <b class="pcalibre1 pcalibre calibre6">WITH</b> <b class="pcalibre1 pcalibre calibre6">PYTHON</b></small></h1>
</div>
</header>
<p class="pcalibre1 pcalibre calibre7">I don’t need to tell you how amazing Python is. You <em class="pcalibre1 calibre8 pcalibre">know</em>. Or you
wouldn’t be reading this book.</p>
<p class="pcalibre1 pcalibre calibre7">It’s still fun to recognize what an exciting time it is for
Python. Amazon’s best-selling programming book list is <em class="pcalibre1 calibre8 pcalibre">filled</em> with
Python. Attendance at PyCon keeps climbing, on top of the regional
conferences and spin-off meetups. More and more organizations are
using Python…​  from tiny startups, to multinational corporations, to
NASA and the JPL, and everything in between. Even MIT reworked their
famous, venerable "Introduction to Computer Science and Programming"
class, replacing Scheme  with…​ you guessed it,
Python.</p>
<p class="pcalibre1 pcalibre calibre7">But enough cheerleading.</p>
<p class="pcalibre1 pcalibre calibre7">There are <em class="pcalibre1 calibre8 pcalibre">massive heaping piles</em> of books for people new to Python,
new to programming, or both. But you’re past the point where those do
you much good. If you’ve been coding in Python for a while already, or
Python is your second or third or seventh programming
language…​ you need more.</p>
<p class="pcalibre1 pcalibre calibre7">Reading blog posts can help, as can studying open-source code, and (if
you can swing it) working alongside a seasoned Pythonista. But these
aren’t the most convenient ways to learn.</p>
<p class="pcalibre1 pcalibre calibre7">And that’s why I wrote this book.</p>
<p class="pcalibre1 pcalibre calibre7">Python is richer than you imagine - as a language, as an
ecosystem. For many engineering domains, it has grown into a truly
outstanding choice for implementing high-quality, robust, maintainable
software - everything from one-off scripts to sprawling,
mission-critical applications. This book is designed to help you
master all of that: to teach you techniques, patterns, and tools to
permanently catapult your skill with everything Python has to offer.</p>
<p class="pcalibre1 pcalibre calibre7">To accomplish this, I did not hesitate to make hard
choices. Understand this book is highly <strong class="pcalibre1 pcalibre calibre9">opinionated</strong>.  I focus on
certain topics, and certain ways of structuring code, because I
believe it gives you the best payoff and value for your reading time.
Many blog posts have been written about different aspects of Python
development; frankly, some of them are not good advice. My goal in
this book is to give you excellent advice.</p>
<p class="pcalibre1 pcalibre calibre7">To that end, this book is <strong class="pcalibre1 pcalibre calibre9">practical</strong>. Everything herein is based on
the lessons learned writing real-world software, usually as part of a
team of engineers. That means factors like maintainability,
robustness, and readability are considered more important than
anything else. There is a balance between leveraging powerful
abstractions, and writing code that is easy to reason about correctly
by everyone on your team. Every page of this book walks that line.</p>
<p class="pcalibre1 pcalibre calibre7">Throughout, I give much attention to cognitive aspects of development.
How do you write code which you and others can reason about easily,
quickly, <em class="pcalibre1 calibre8 pcalibre">and</em> accurately? This is one reason variable and function
naming is so important. But it goes <strong class="pcalibre1 pcalibre calibre9">far beyond</strong> that, to
intelligently choosing which language features and library resources
to use, and which to avoid.</p>
<p class="pcalibre1 pcalibre calibre7">Thus, this book is <strong class="pcalibre1 pcalibre calibre9">selective</strong> in its topics. It’s not too large, as
measured by number of pages. <strong class="pcalibre1 pcalibre calibre9">That’s a feature, not a bug: you already
have too much to read.</strong> The focus is on what’s most impactfully
valuable to <em class="pcalibre1 calibre8 pcalibre">you</em>, so that - as much as possible - everything you
learn will serve you for <em class="pcalibre1 calibre8 pcalibre">years</em>.</p>
<p class="pcalibre1 pcalibre calibre7">That’s one reason this book is focused on Python 3. I’m fortunately
also able to help those of you using Python 2.7, because the most
valuable patterns, practices and strategies in Python are surprisingly
independent of Python version. So I’ll demonstrate each idea using
Python 3 code, and where the syntax of Python 2.7 differs, I’ll point
out those differences as we go along.</p>
<p class="pcalibre1 pcalibre calibre7">And it’s important that you do learn Python 3. The main Linux
distributions are mostly switching to 3; third-party library support
is <em class="pcalibre1 calibre8 pcalibre">extremely</em> solid; and the list of improvements and
features Python 3 has over 2.7 is huge, and getting
longer.<sup class="pcalibre1 pcalibre noteref">[<a href="#calibre_link-24" id="calibre_link-26" type="noteref" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">1</a>]</sup>  This book is written to prepare you for Python’s
foreseeable future.</p>
<p class="pcalibre1 pcalibre calibre7">When I teach live workshops in Python for working developers, my
intention is to instill transformatively powerful skills and
abilities, which will serve attendees for the rest of their careers. I
bring this same intention for <em class="pcalibre1 calibre8 pcalibre">you</em>, reading this book. If you have
any comments or questions, I’d love to hear them - reach me by email
at <a class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4" href="mailto:aaron@powerfulpython.com">aaron@powerfulpython.com</a>.</p>
<p class="pcalibre1 pcalibre calibre7">And as a reader of this book, you will want to subscribe to the
Powerful Python
Newsletter,<sup class="pcalibre1 pcalibre noteref">[<a href="#calibre_link-25" id="calibre_link-27" type="noteref" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">2</a>]</sup>
because it gives you important new articles on intermediate and
advanced Python. For those of you with a digital edition of this book,
it’s also how I let you know there’s a new edition to download.</p>
<p class="pcalibre1 pcalibre calibre7">Speaking of the digital version: if you’ve bought this as a physical
book, you can add a DRM-free digital copy for $4.99 USD. This includes
digital updates to future editions; you’ll get the 3rd edition when it
comes out, as well as intermediate point releases. (Between the 1st
and 2nd editions, digital readers got three substantial updates,
with new chapters and extensive revisions.) Go to
powerfulpython.com/book-upgrade to take advantage.</p>
<section class="calibre2 pcalibre1 pcalibre" title="Python Versions">
<h2 id="calibre_link-63" class="pcalibre1 pcalibre calibre1">Python Versions</h2>
<p class="pcalibre1 pcalibre calibre7">  We’re at an
interesting transition point. I know most of you are using Python 3 at
least part of the time. Many of you use only Python 2.7, and many only
Python 3. In this book, I take care of everyone.</p>
<p class="pcalibre1 pcalibre calibre7">Most code examples in this book are written for Python 3.5 and later.
Sometimes I’ll talk about features specific to a later version - when
we talk about Python 3.6’s f-strings, for example - and I’ll make it
clear when that happens.</p>
<p class="pcalibre1 pcalibre calibre7">I’ve also written this book’s code in a way that can be easily adapted
to Python 2.7. Surprisingly, in many cases the exact same code will
work in both Python 2.7 and Python 3!  <strong class="pcalibre1 pcalibre calibre9">The structure of quality
Python software, and the patterns and strategies that work
exceptionally well in the real world, are <em class="pcalibre1 calibre8 pcalibre">surprisingly</em> independent
of version.</strong></p>
<p class="pcalibre1 pcalibre calibre7">And of course, there are sometimes differences in syntax. So
throughout the book, I include footnotes and special sub-sections that
explain how things are different in Python 2.7, as they come up.</p>
<p class="pcalibre1 pcalibre calibre7">(And if you <em class="pcalibre1 calibre8 pcalibre">are</em> working in that version, pay close attention
when I show you Python 2 code. If there are two ways to do
something in Python 2.7 - one of which is forward-compatible with
Python 3, and another which is not - I’ll <em class="pcalibre1 calibre8 pcalibre">always</em> show you the
former. It tells you how to write for Python 2 today, in a way that
gives you less to re-learn when you eventually upgrade.)</p>
<p class="pcalibre1 pcalibre calibre7">People often ask if it’s worth their effort to upgrade from Python 2
to 3. You’ll find passionate opinions on every side of this fence.  I
can offer this advice: <strong class="pcalibre1 pcalibre calibre9">If I had to sum up what makes Python 3
different, it’s that creating high quality software is easier in
Python 3.</strong> You can, obviously, create high quality software in Python
2; you just have to work a bit harder, sometimes.</p>
<p class="pcalibre1 pcalibre calibre7">Of course, you also lose the opportunity to use some exciting and fun
Python-3-only features. This arguably doesn’t matter from an
engineering standpoint. But it might matter to you personally. And
there will come a day when having only Python 2.x on your resume will
make it look dated.</p>
<p class="pcalibre1 pcalibre calibre7">In any event, this book is about <em class="pcalibre1 calibre8 pcalibre">current</em> versions of Python. That
includes Python versions 3.5 and later, as well as 2.7. I do consider
Python 2.6 obsolete at this point, though you may still need to use it
for legacy reasons. If so, some topics will be a bit more difficult to
translate into your code base.</p>
<p class="pcalibre1 pcalibre calibre7">This book uses <code class="pcalibre1 pcalibre literal">str.format()</code> to format strings:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13">"Hello, {}!"</span>.format(<span class="pcalibre1 pcalibre calibre13">"John"</span>)
<span class="pcalibre1 pcalibre calibre13">'Hello, John!'</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">For a quick refresher, skim the first few sections of the "String
Formatting" chapter. To round out this intro, we’ll look at some
important practical aspects of developing modern Python applications.</p>
</section>
<section class="calibre2 pcalibre1 pcalibre" title="Python Application Environments">
<h2 id="calibre_link-64" class="pcalibre1 pcalibre calibre1">Python Application Environments</h2>
<p class="pcalibre1 pcalibre calibre7">

Python sports a concept called the <em class="pcalibre1 calibre8 pcalibre">virtual environment</em>. It is
sometimes called a "virtualenv" or a "venv". You can think of a
virtual environment as a kind of lightweight container for a Python
application, where the application can see its own particular set of
Python libraries, at specific versions. This provides some significant
benefits for deployment:</p>
<div class="pcalibre1 pcalibre itemized-list">
<ul class="pcalibre1 calibre14 pcalibre">
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">Dependencies can be precisely tracked and specified, and even kept
in version control.</span>
</li>
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">Two different Python applications with conflicting dependencies can
peacefully coexist on the same machine.</span>
</li>
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">Python packages can be installed without requiring elevated system privileges.</span>
</li>
</ul>
</div>
<p class="pcalibre1 pcalibre calibre7">How you create a virtual environment depends on whether you’re using
Python 3 or 2. For Python 3, you invoke <code class="pcalibre1 pcalibre literal">python3 -m venv</code>, adding one
more argument - the name of a folder to create:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"># The recommended method in Python 3.
$ python3 -m venv webappenv</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">(The <code class="pcalibre1 pcalibre literal">$</code> is the shell prompt.)  For the near future, you can also use
the <code class="pcalibre1 pcalibre literal">pyvenv</code> command. This works fine, but is deprecated, and
scheduled to disappear in Python 3.8:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"># Does the same thing, but is deprecated.
$ pyvenv webappenv</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">What these both do is create a folder named "webappenv" in the current
directory. The Python 2 tool, <code class="pcalibre1 pcalibre literal">virtualenv</code>, has the same interface;
wherever you see <code class="pcalibre1 pcalibre literal">python -m venv</code> in this book, you can substitute
<code class="pcalibre1 pcalibre literal">virtualenv</code> instead:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"># Same as the above, in Python 2.
$ virtualenv webappenv</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Regardless of which you use, you’ll end up with a new folder named
<code class="pcalibre1 pcalibre literal">webappenv</code>, containing all sorts of goodies. To access them, you must
run a script called "activate". In macOS and Linux, type the following
in your shell:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11">$ source webappenv/bin/activate
(webappenv)$</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">For Windows, run the script <code class="pcalibre1 pcalibre literal">webappenv\Scripts\activate.bat</code> instead:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11">C:\labs&gt; webappenv\Scripts\activate.bat
(webappenv) C:\labs&gt;</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Notice your prompt has changed: now it contains <code class="pcalibre1 pcalibre literal">(webappenv)</code>. The
script called <code class="pcalibre1 pcalibre literal">activate</code> did not start a new shell or session; all it
did was alter your PATH and PYTHONPATH environment variables, and a
few others (like the PS1 variable, which specifies how your shell
renders the prompt.) You just <em class="pcalibre1 calibre8 pcalibre">activated</em> your virtual environment, as
we say. When it’s active for that particular shell session, we say you
are working <em class="pcalibre1 calibre8 pcalibre">in the virtual environment</em>.</p>
<p class="pcalibre1 pcalibre calibre7">Suppose your system Python executable is at
<code class="pcalibre1 pcalibre literal">/usr/bin/python3</code> (or <code class="pcalibre1 pcalibre literal">/usr/bin/python</code> for version 2). And suppose
you’ve created the webappenv folder in <code class="pcalibre1 pcalibre literal">/Users/sam/mywebapp/webappenv</code>. With the
virtual environment activated, you have your own local copy of the
Python interpreter. You can check this with the <code class="pcalibre1 pcalibre literal">which</code> command on macOS
and Linux:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11">(webappenv)$ which python
/Users/sam/mywebapp/webappenv/bin/python
(webappenv)$ python -V
Python 3.6.0</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Or the <code class="pcalibre1 pcalibre literal">where</code> command on Windows:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11">(webappenv) C:\labs&gt; where python
C:\labs\webappenv\Scripts\python.exe
C:\Python36\python.exe</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">This is for the virtual environment we created with <code class="pcalibre1 pcalibre literal">pyvenv</code>, which
means it’s Python 3. Now, what if you want to restore your old PATH
(and PYTHONPATH, etc.)? Within the virtualenv, you now have a function
defined called <code class="pcalibre1 pcalibre literal">deactivate</code>:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11">(webappenv)$ deactivate
$ which python
/usr/bin/python</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Now imagine you are writing a Python application: let’s call it
<code class="pcalibre1 pcalibre literal">mediatag</code>, one designed for tagging files in your media
collection. It’s implemented in Python 2.7. We can do the following:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11">$ cd /Users/sam/mediatag
$ virtualenv mediatagenv
$ source mediatagenv/bin/activate
(mediatagenv)$ which python
/Users/sam/mywebapp/mediatagenv/bin/python
(mediatagenv)$ python -V
Python 2.7.13</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">This shows one minor benefit of virtual environments: it provides a
new way to control the precise version of Python used by an
application. But the main benefit for using virtual environments has
to do with resolving requirements, upgrades, and dependencies with
packages and libraries.</p>
</section>
<section class="calibre2 pcalibre1 pcalibre" title="Python Package Management">
<h2 id="calibre_link-65" class="pcalibre1 pcalibre calibre1">Python Package Management</h2>
<p class="pcalibre1 pcalibre calibre7">The sordid history of Python library and package management is full of
hidden twists, perilous turns, and dark corners hiding sinister
beasts. Good news: you don’t have to worry about any of that.</p>
<p class="pcalibre1 pcalibre calibre7"> Modern Python provides an application called <code class="pcalibre1 pcalibre literal">pip</code>,
which allows you to easily install third-party Python libraries and
applications.  It incorporates many of the lessons learned from its
predecessors, sidestepping problems that previously had to be dealt
with manually. And it works very well with Python virtual
environments.</p>
<p class="pcalibre1 pcalibre calibre7">The first step is to install <code class="pcalibre1 pcalibre literal">pip</code>. With Python 3, this is included
for you automatically, and is installed in your virtual environment:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11">$ source venv/bin/activate
(venv)$ python -V
Python 3.6.0
(venv)$ which pip
/Users/sam/myapp/venv/bin/pip</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">For Python 2, if <code class="pcalibre1 pcalibre literal">pip</code> is already installed on the system, your virtual
environment will be created to include it. For macOS and Windows, recent
versions of Python 2 automatically include <code class="pcalibre1 pcalibre literal">pip</code>; if not, you can
quickly find out how to install it by searching online.</p>
<p class="pcalibre1 pcalibre calibre7">Once you have the <code class="pcalibre1 pcalibre literal">pip</code> executable, you can use <code class="pcalibre1 pcalibre literal">pip install</code> to
install libraries just within the virtual environment. For example,
<code class="pcalibre1 pcalibre literal">requests</code> is a high-quality HTTP library. Install it like so:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11">pip install requests</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">This is the <code class="pcalibre1 pcalibre literal">install</code> command. You will see some output, narrating the
process of installing <code class="pcalibre1 pcalibre literal">requests</code> at a specific version. Once complete,
you will be able to open a Python prompt and <code class="pcalibre1 pcalibre literal">import requests</code>.</p>
<p class="pcalibre1 pcalibre calibre7">The <code class="pcalibre1 pcalibre literal">pip install</code> command is also used to upgrade packages. For
example, sometimes a fresh virtual environment may install a slightly
stale version of <code class="pcalibre1 pcalibre literal">pip</code>. <code class="pcalibre1 pcalibre literal">pip</code> is just another package, so you can
upgrade it with the <code class="pcalibre1 pcalibre literal">-U</code> or <code class="pcalibre1 pcalibre literal">--upgrade</code> option:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11">pip install --upgrade pip</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Installed packages are, by default, fetched from Pypi - the official online
Python package repository. Any package or library listed at
<a class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4" href="https://pypi.python.org/pypi">https://pypi.python.org/pypi</a> can be installed with <code class="pcalibre1 pcalibre literal">pip</code>. You can
uninstall them with <code class="pcalibre1 pcalibre literal">pip uninstall</code>.</p>
<p class="pcalibre1 pcalibre calibre7">Now, some of these packages' files are substantial, or even compiled
into object files. You definitely don’t want to put them in version
control. How do you register the exact version dependencies your app
has for third-party libraries? And how do you manage upgrades (and
even downgrades) over time?</p>
<p class="pcalibre1 pcalibre calibre7"><code class="pcalibre1 pcalibre literal">pip</code> provides a good solution for this. The first part of it relies on
the <code class="pcalibre1 pcalibre literal">pip freeze</code> command:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11">(venv)$ pip freeze
requests==2.7.0</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">This prints the packages installed from Pypi, one per line, with the
exact version.  What you can do is place this in a file named <code class="pcalibre1 pcalibre literal">requirements.txt</code>:</p>
<p class="pcalibre1 pcalibre calibre7">
</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11">(venv)$ pip freeze &gt; requirements.txt
(venv)$ cat requirements.txt
requests==2.7.0</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7"><strong class="pcalibre1 pcalibre calibre9">This</strong> file is what you will check into version control. You can
recreate the application environment, right down to the minor versions
of each dependent library, simply by passing <code class="pcalibre1 pcalibre literal">requirements.txt</code> to
<code class="pcalibre1 pcalibre literal">pip</code>.  Whether your coworker is fetching the raw source to start
development, or if the devops team sets up a CI environment that
runs the automated tests, the environment is consistent and
well-defined, from development to staging to production.</p>
<p class="pcalibre1 pcalibre calibre7">You can pass any file path to <code class="pcalibre1 pcalibre literal">python3 -m venv</code> (and <code class="pcalibre1 pcalibre literal">pyvenv</code>, and
<code class="pcalibre1 pcalibre literal">virtualenv</code>). For organizational convenience, many choose to put it
in the top-level folder of the repository holding the Python
application. There are two schools of thought on what to name it.</p>
<p class="pcalibre1 pcalibre calibre7">One school picks a consistent name, which is used for every
project. "venv" is very popular:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11">python3 -m venv venv</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">The idea is that every Python project will have a folder in its top
level called <code class="pcalibre1 pcalibre literal">venv</code> to contain the virtual environment. This has
several advantages. For one, you can easily activate the virtual
environment for any application, just by typing <code class="pcalibre1 pcalibre literal">source
venv/bin/activate</code>. In fact, you can define a shell alias to help:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"># Type "venv" &lt;enter&gt; to get in the virtual environment.
alias venv='source venv/bin/activate'</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">You can also configure your version control system to ignore any
folder named "venv", and thereby avoid ever accidentally committing
your virtual environment. (You don’t want to do that. It’s a lot of
files, and will annoy your fellow developers.)</p>
<p class="pcalibre1 pcalibre calibre7">The other naming scheme is to give it a name that has something to do
with the application. For example, for an application called
"mywebapp", you might create it like this:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11">python3 -m venv mywebappenv</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">The advantage of this is that, when activated, the prompt is modified
to tell you which particular virtual environment your shell prompt is
using. This can be helpful if you work with many different Python
applications, as it’s much more informative than a prompt that just
says "(venv)".</p>
<p class="pcalibre1 calibre7 pcalibre7">The downside comes from the inconsistency of the folder
name: keeping the folder out of version control is more error-prone,
and activating the virtual environment requires the distraction of
conscious thought each time. Both approaches are valid; it really
comes down to which you and your teammates like better.</p>
</section>
<footer class="pcalibre1 pcalibre calibre15">
<div class="calibre16 pcalibre1 pcalibre"></div><div class="pcalibre1 pcalibre chapter-footer">
<div class="pcalibre1 pcalibre footnotes">
<aside id="calibre_link-24" type="footnote" class="calibre2 pcalibre1 pcalibre">
<p class="pcalibre1 calibre17 pcalibre"><sup class="noteref1 pcalibre1 pcalibre"><a href="#calibre_link-26" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">1</a></sup> See <a class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4" href="https://powerfulpython.com/blog/whats-really-new-in-python-3/">https://powerfulpython.com/blog/whats-really-new-in-python-3/</a> for a summary.</p>
</aside>
<aside id="calibre_link-25" type="footnote" class="calibre2 pcalibre1 pcalibre">
<p class="pcalibre1 calibre17 pcalibre"><sup class="noteref1 pcalibre1 pcalibre"><a href="#calibre_link-27" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">2</a></sup> <a class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4" href="https://powerfulpython.com/python-newsletter/">https://powerfulpython.com/python-newsletter/</a></p>
</aside>
</div>
</div>
</footer>
</section>
</div>


<div id="calibre_link-37" class="pcalibre1 pcalibre calibre">
<section class="calibre2 pcalibre1 pcalibre" id="calibre_link-168" title="Scaling With Generators" type="chapter">
<header id="calibre_link-66" class="calibre2 pcalibre1 pcalibre">
<div class="pcalibre1 pcalibre chapter-header">
<h1 class="pcalibre1 chapter-title pcalibre"> <small class="subtitle pcalibre1 pcalibre"><b class="pcalibre1 pcalibre calibre6">SCALING</b> <b class="pcalibre1 pcalibre calibre6">WITH</b> <b class="pcalibre1 pcalibre calibre6">GENERATORS</b></small></h1>
</div>
</header>
<p class="pcalibre1 pcalibre calibre7">This <code class="pcalibre1 pcalibre literal">for</code> loop seems simple:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">for</span> item <span class="pcalibre1 pcalibre calibre18">in</span> items:
    do_something_with(item)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7"> And yet, miracles hide here. As you probably
know, the act of efficiently going through a collection, one element
at a time, is called <em class="pcalibre1 calibre8 pcalibre">iteration</em>. But few understand how Python’s
iteration system really works…​  how deep and well-thought-out it
is. This chapter makes you one of those people, giving you the ability
to naturally write <strong class="pcalibre1 pcalibre calibre9">highly scalable</strong> Python applications…​ able to
handle ever-larger data sets in performant, memory-efficient ways.</p>
<p class="pcalibre1 pcalibre calibre7"> Iteration is also core to one of
Python’s most powerful tools: the <em class="pcalibre1 calibre8 pcalibre">generator function</em>. Generator
functions are not just a convenient way to create useful iterators.
They enable some exquisite patterns of code organization, in a way
that - by their very nature - intrinsically encourage excellent coding
habits.</p>
<p class="pcalibre1 pcalibre calibre7">This chapter is special, because understanding it threatens to make
you a permanently better programmer <em class="pcalibre1 calibre8 pcalibre">in every language</em>. Mastering
Python generators tends to do that, because of the distinctions and
insights you gain along the way.  Let’s dive in.</p>
<section class="calibre2 pcalibre1 pcalibre" title="Iteration in Python">
<h2 id="calibre_link-67" class="pcalibre1 pcalibre calibre1">Iteration in Python</h2>
<p class="pcalibre1 pcalibre calibre7">

Python has a built-in function called <code class="pcalibre1 pcalibre literal">iter()</code>. When you pass it a
collection, you get back an <em class="pcalibre1 calibre8 pcalibre">iterator object</em>:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; numbers = [7, 4, 11, 3]
&gt;&gt;&gt; iter(numbers)
&lt;list_iterator object at 0x10219dc50&gt;</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Just as in other languages, a Python iterator produces the values in a
sequence, one at a time. You probably know an iterator is like a
moving pointer over the collection:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; numbers_iter = iter(numbers)
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre18">for</span> num <span class="pcalibre1 pcalibre calibre18">in</span> numbers_iter: <span class="pcalibre1 pcalibre calibre18">print</span>(num)
7
4
11
3</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">You don’t normally need to do this. If you instead write <code class="pcalibre1 pcalibre literal">for num in
numbers</code>, what Python effectively does under the hood is call <code class="pcalibre1 pcalibre literal">iter()</code>
on that collection. This happens automatically. Whatever object it
gets back is used as the iterator for that <code class="pcalibre1 pcalibre literal">for</code> loop:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre13"># This...</span>
<span class="pcalibre1 pcalibre calibre18">for</span> num <span class="pcalibre1 pcalibre calibre18">in</span> numbers:
    <span class="pcalibre1 pcalibre calibre18">print</span>(num)

<span class="pcalibre1 pcalibre calibre13"># ... is effectively just like this:</span>
numbers_iter = iter(numbers)
<span class="pcalibre1 pcalibre calibre18">for</span> num <span class="pcalibre1 pcalibre calibre18">in</span> numbers_iter:
    <span class="pcalibre1 pcalibre calibre18">print</span>(num)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">An iterator over a collection is a separate object, with its own
identity - which you can verify with <code class="pcalibre1 pcalibre literal">id()</code>:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13"># id() returns a unique number for each object.</span>
... <span class="pcalibre1 pcalibre calibre13"># Different objects will always have different IDs.</span>
&gt;&gt;&gt; id(numbers)
4330133896
&gt;&gt;&gt; id(numbers_iter)
4330216640</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">How does <code class="pcalibre1 pcalibre literal">iter()</code> actually get the iterator? It can do this in several
ways, but one relies on a magic method called
<code class="pcalibre1 pcalibre literal">__iter__</code>. This is a method any class (including yours) may
define; when called with no arguments, it must return a fresh iterator
object. Lists have it, for example:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; numbers.__iter__
&lt;method-wrapper <span class="pcalibre1 pcalibre calibre13">'__iter__'</span> of list object at 0x10130e4c8&gt;
&gt;&gt;&gt; numbers.__iter__()
&lt;list_iterator object at 0x1013180f0&gt;</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">   Python makes a distinction between objects
which are <em class="pcalibre1 calibre8 pcalibre">iterators</em>, and objects which are <em class="pcalibre1 calibre8 pcalibre">iterable</em>.  We say an
object is <em class="pcalibre1 calibre8 pcalibre">iterable</em> if and only if you can pass it to <code class="pcalibre1 pcalibre literal">iter()</code>, and
get a ready-to-use iterator. If that object has an <code class="pcalibre1 pcalibre literal">__iter__</code>
method, <code class="pcalibre1 pcalibre literal">iter()</code> will call it to get the iterator. Python lists and
tuples are iterable. So are strings, which is why you can write <code class="pcalibre1 pcalibre literal">for
char in my_str:</code> to iterate over <code class="pcalibre1 pcalibre literal">my_str</code>​'s characters. Any
container you might use in a <code class="pcalibre1 pcalibre literal">for</code> loop is iterable.</p>
<p class="pcalibre1 pcalibre calibre7"> A <code class="pcalibre1 pcalibre literal">for</code> loop is the most common way to
step through a sequence. But sometimes your code needs to step through in
a more fine-grained way. For this, use the built-in function
<code class="pcalibre1 pcalibre literal">next()</code>. You normally call it with a single argument, which is an
iterator. Each time you call it, <code class="pcalibre1 pcalibre literal">next(my_iterator)</code> fetches and
returns the next element:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; names = [<span class="pcalibre1 pcalibre calibre13">"Tom"</span>, <span class="pcalibre1 pcalibre calibre13">"Shelly"</span>, <span class="pcalibre1 pcalibre calibre13">"Garth"</span>]
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13"># Create a fresh iterator...</span>
... names_it = iter(names)
&gt;&gt;&gt; next(names_it)
<span class="pcalibre1 pcalibre calibre13">'Tom'</span>
&gt;&gt;&gt; next(names_it)
<span class="pcalibre1 pcalibre calibre13">'Shelly'</span>
&gt;&gt;&gt; next(names_it)
<span class="pcalibre1 pcalibre calibre13">'Garth'</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">
What happens if you call <code class="pcalibre1 pcalibre literal">next(names_it)</code> again? <code class="pcalibre1 pcalibre literal">next()</code> will raise a
special built-in exception, called <code class="pcalibre1 pcalibre literal">StopIteration</code>:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; next(names_it)
Traceback (most recent call last):
  File <span class="pcalibre1 pcalibre calibre13">"&lt;stdin&gt;"</span>, line 1, <span class="pcalibre1 pcalibre calibre18">in</span> &lt;module&gt;
<span class="pcalibre1 pcalibre calibre18">StopIteration</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7"> This is part of Python’s <em class="pcalibre1 calibre8 pcalibre">iterator
protocol</em>. Raising this specific exception is, by design, how an
iterator signals the sequence is done. You rarely have to raise or
catch this exception yourself, though we’ll see some patterns later
where it’s useful to do so. A good mental model for how a <code class="pcalibre1 pcalibre literal">for</code> loop
works is to imagine it calling <code class="pcalibre1 pcalibre literal">next()</code> each time through the loop,
exiting when <code class="pcalibre1 pcalibre literal">StopIteration</code> gets raised.</p>
<p class="pcalibre1 pcalibre calibre7">When using <code class="pcalibre1 pcalibre literal">next()</code> yourself, you can provide a second argument, for
the default value. If you do, <code class="pcalibre1 pcalibre literal">next()</code> will return that instead of
raising <code class="pcalibre1 pcalibre literal">StopIteration</code> at the end:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; names = [<span class="pcalibre1 pcalibre calibre13">"Tom"</span>, <span class="pcalibre1 pcalibre calibre13">"Shelly"</span>, <span class="pcalibre1 pcalibre calibre13">"Garth"</span>]
&gt;&gt;&gt; new_names_it = iter(names)
&gt;&gt;&gt; next(new_names_it, <span class="pcalibre1 pcalibre calibre13">"Rick"</span>)
<span class="pcalibre1 pcalibre calibre13">'Tom'</span>
&gt;&gt;&gt; next(new_names_it, <span class="pcalibre1 pcalibre calibre13">"Rick"</span>)
<span class="pcalibre1 pcalibre calibre13">'Shelly'</span>
&gt;&gt;&gt; next(new_names_it, <span class="pcalibre1 pcalibre calibre13">"Rick"</span>)
<span class="pcalibre1 pcalibre calibre13">'Garth'</span>
&gt;&gt;&gt; next(new_names_it, <span class="pcalibre1 pcalibre calibre13">"Rick"</span>)
<span class="pcalibre1 pcalibre calibre13">'Rick'</span>
&gt;&gt;&gt; next(new_names_it)
Traceback (most recent call last):
  File <span class="pcalibre1 pcalibre calibre13">"&lt;stdin&gt;"</span>, line 1, <span class="pcalibre1 pcalibre calibre18">in</span> &lt;module&gt;
<span class="pcalibre1 pcalibre calibre18">StopIteration</span>
&gt;&gt;&gt; next(new_names_it, <span class="pcalibre1 pcalibre calibre13">"Jane"</span>)
<span class="pcalibre1 pcalibre calibre13">'Jane'</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Now, let’s consider a different situation. What if you aren’t working
with a simple sequence of numbers or strings, but something more
complex?  What if you are calculating or reading or otherwise
obtaining the sequence elements as you go along? Let’s start with a
simple example (so it’s easy to reason about). Suppose you need to
write a function creating a list of square numbers, which will be
processed by other code:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">def</span> fetch_squares(max_root):
    squares = []
    <span class="pcalibre1 pcalibre calibre18">for</span> n <span class="pcalibre1 pcalibre calibre18">in</span> range(max_root):
        squares.append(n**2)
    <span class="pcalibre1 pcalibre calibre18">return</span> squares

MAX = 5
<span class="pcalibre1 pcalibre calibre18">for</span> square <span class="pcalibre1 pcalibre calibre18">in</span> fetch_squares(MAX):
    do_something_with(square)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">This works. But there is potential problem lurking here. Can you spot
it?</p>
<p class="pcalibre1 pcalibre calibre7">Here’s one: what if <code class="pcalibre1 pcalibre literal">MAX</code> is not 5, but 10,000,000?  Or
10,000,000,000? Or more? Your memory footprint is pointlessly
dreadful: the code here creates a <em class="pcalibre1 calibre8 pcalibre">massive</em> list, uses it <em class="pcalibre1 calibre8 pcalibre">once</em>, then
throws it away.  On top of that, the second <code class="pcalibre1 pcalibre literal">for</code> loop cannot event
<em class="pcalibre1 calibre8 pcalibre">start</em> until the entire list of squares has been fully calculated.
If some poor human is using this program, they’ll wonder if the
program is stuck.</p>
<p class="pcalibre1 pcalibre calibre7">Even worse: What if you aren’t doing arithmetic to get each element -
which is fast and cheap - but making a truly expensive calculation?
Or making an API call over the network? Or reading from a database?
Your program is sluggish, even unresponsive, and might even crash with
an out-of-memory error. Its users will think you’re a terrible
programmer.</p>
<p class="pcalibre1 pcalibre calibre7">The solution is to create an iterator to start with, lazily computing
each value only when needed. Then each cycle through the loop happens
just in time.</p>
<p class="pcalibre1 pcalibre calibre7">For the record, here is how you create an equivalent iterator class,
which fully complies with Python’s iterator protocol:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">class</span> <span class="pcalibre1 pcalibre calibre18">SquaresIterator</span>:
    <span class="pcalibre1 pcalibre calibre18">def</span> __init__(self, max_root_value):
        self.max_root_value = max_root_value
        self.current_root_value = 0
    <span class="pcalibre1 pcalibre calibre18">def</span> __iter__(self):
        <span class="pcalibre1 pcalibre calibre18">return</span> self
    <span class="pcalibre1 pcalibre calibre18">def</span> __next__(self):
        <span class="pcalibre1 pcalibre calibre18">if</span> self.current_root_value &gt;= self.max_root_value:
            <span class="pcalibre1 pcalibre calibre18">raise</span> <span class="pcalibre1 pcalibre calibre18">StopIteration</span>
        square_value = self.current_root_value ** 2
        self.current_root_value += 1
        <span class="pcalibre1 pcalibre calibre18">return</span> square_value

<span class="pcalibre1 pcalibre calibre13"># You can use it like this:</span>
<span class="pcalibre1 pcalibre calibre18">for</span> square <span class="pcalibre1 pcalibre calibre18">in</span> SquaresIterator(5):
    <span class="pcalibre1 pcalibre calibre18">print</span>(square)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Holy crap, that’s horrible. There’s got to be a better way.</p>
<p class="pcalibre1 pcalibre calibre7">Good news: there’s a better way.  It’s called a <strong class="pcalibre1 pcalibre calibre9">generator function</strong>,
and you’re going to love it!</p>
</section>
<section class="calibre2 pcalibre1 pcalibre" title="Generator Functions">
<h2 id="calibre_link-68" class="pcalibre1 pcalibre calibre1">Generator Functions</h2>
<p class="pcalibre1 pcalibre calibre7"> 
Python provides a tool called the <strong class="pcalibre1 pcalibre calibre9">generator function</strong>, which…​ well,
it’s hard to describe everything it gives you in one sentence. Of its
many talents, I’ll first focus on how it’s a <em class="pcalibre1 calibre8 pcalibre">very</em> useful shortcut
for creating iterators.</p>
<p class="pcalibre1 pcalibre calibre7">A generator function looks a lot like a regular function. But instead
of saying <code class="pcalibre1 pcalibre literal">return</code>, it uses a new and different keyword:
<code class="pcalibre1 pcalibre literal">yield</code>. Here’s a simple example:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">def</span> gen_nums():
    n = 0
    <span class="pcalibre1 pcalibre calibre18">while</span> n &lt; 4:
        <span class="pcalibre1 pcalibre calibre18">yield</span> n
        n += 1</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Use it in a for loop like this:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre18">for</span> num <span class="pcalibre1 pcalibre calibre18">in</span> gen_nums():
...     <span class="pcalibre1 pcalibre calibre18">print</span>(num)
0
1
2
3</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Let’s go through and understand this. When you call <code class="pcalibre1 pcalibre literal">gen_nums()</code> like
a function, it immediately returns a <strong class="pcalibre1 pcalibre calibre9">generator object</strong>:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; sequence = gen_nums()
&gt;&gt;&gt; type(sequence)
&lt;<span class="pcalibre1 pcalibre calibre18">class</span> <span class="pcalibre1 pcalibre calibre19">'</span><span class="pcalibre1 pcalibre calibre18">generator</span><span class="pcalibre1 pcalibre calibre13">'&gt;</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">  The <em class="pcalibre1 calibre8 pcalibre">generator function</em> is
<code class="pcalibre1 pcalibre literal">gen_nums</code> - what we define and then call.  A function is a generator
function if and only if it uses "yield" instead of "return". The
<em class="pcalibre1 calibre8 pcalibre">generator object</em> is what that generator function returns when called
- <code class="pcalibre1 pcalibre literal">sequence</code>, in this case. A generator function will <em class="pcalibre1 calibre8 pcalibre">always</em> return
a generator object; it can’t return anything else. And this generator
object is an iterator, which means you can iterate through it using
<code class="pcalibre1 pcalibre literal">next()</code> or a <code class="pcalibre1 pcalibre literal">for</code> loop:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; sequence = gen_nums()
&gt;&gt;&gt; next(sequence)
0
&gt;&gt;&gt; next(sequence)
1
&gt;&gt;&gt; next(sequence)
2
&gt;&gt;&gt; next(sequence)
3
&gt;&gt;&gt; next(sequence)
Traceback (most recent call last):
  File <span class="pcalibre1 pcalibre calibre13">"&lt;stdin&gt;"</span>, line 1, <span class="pcalibre1 pcalibre calibre18">in</span> &lt;module&gt;
<span class="pcalibre1 pcalibre calibre18">StopIteration</span></code></pre>
</figure>
<figure class="pcalibre1 pcalibre footnotes">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13"># Or in a for loop:</span>
... <span class="pcalibre1 pcalibre calibre18">for</span> num <span class="pcalibre1 pcalibre calibre18">in</span> gen_nums(): <span class="pcalibre1 pcalibre calibre18">print</span>(num)
...
0
1
2
3</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">The flow of code works like this: when <code class="pcalibre1 pcalibre literal">next()</code> is called the first
time, or the <code class="pcalibre1 pcalibre literal">for</code> loop first starts, the body of <code class="pcalibre1 pcalibre literal">gen_nums</code> starts
executing at the beginning, returning the value to the right of the
<code class="pcalibre1 pcalibre literal">yield</code>.</p>
<p class="pcalibre1 pcalibre calibre7">So far, this is much like a regular function. But the next time
<code class="pcalibre1 pcalibre literal">next()</code> is called - or, equivalently, the next time through the <code class="pcalibre1 pcalibre literal">for</code>
loop - the function doesn’t start at the beginning again. It starts on
the line <em class="pcalibre1 calibre8 pcalibre">after the yield statement</em>. Look at the source of <code class="pcalibre1 pcalibre literal">gen_nums()</code>
again:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">def</span> gen_nums():
    n = 0
    <span class="pcalibre1 pcalibre calibre18">while</span> n &lt; 4:
        <span class="pcalibre1 pcalibre calibre18">yield</span> n
        n += 1</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">
<code class="pcalibre1 pcalibre literal">gen_nums</code> is more general than a function or subroutine. It’s actually
a <em class="pcalibre1 calibre8 pcalibre">coroutine</em>. You see, a regular function can have several exit
points (otherwise known as <code class="pcalibre1 pcalibre literal">return</code> statements).  But it has only one
entry point: each time you call a function, it always starts at the
first line of the function body.</p>
<p class="pcalibre1 pcalibre calibre7">A coroutine is like a function, except it has several possible
<em class="pcalibre1 calibre8 pcalibre">entry</em> points. It starts with the first line, like a normal
function. But when it "returns", the coroutine isn’t exiting, so much
as <em class="pcalibre1 calibre8 pcalibre">pausing</em>. Subsequent calls with <code class="pcalibre1 pcalibre literal">next()</code> - or equivalently, the
next time through the <code class="pcalibre1 pcalibre literal">for</code> loop - start at that <code class="pcalibre1 pcalibre literal">yield</code> statement
again, right where it left off; the re-entry point is the line after
the <code class="pcalibre1 pcalibre literal">yield</code> statement.</p>
<p class="pcalibre1 pcalibre calibre7">And that’s the key: <strong class="pcalibre1 pcalibre calibre9">Each <code class="pcalibre1 pcalibre literal">yield</code> statement simultaneously defines an exit
point, <em class="pcalibre1 calibre8 pcalibre">and</em> a re-entry point.</strong></p>
<p class="pcalibre1 pcalibre calibre7">For generator objects, each time a new value is requested,
the flow of control picks up on the line after the <code class="pcalibre1 pcalibre literal">yield</code>
statement. In this case, the next line increments the variable <code class="pcalibre1 pcalibre literal">n</code>,
then continues with the while loop.</p>
<p class="pcalibre1 pcalibre calibre7">Notice we do not raise <code class="pcalibre1 pcalibre literal">StopIteration</code> anywhere in the body of
<code class="pcalibre1 pcalibre literal">gen_nums()</code>. When the function body finally exits - after it exits
the while loop, in this case - the generator object automatically
raises <code class="pcalibre1 pcalibre literal">StopIteration</code>.</p>
<p class="pcalibre1 pcalibre calibre7">

Again: each <code class="pcalibre1 pcalibre literal">yield</code> statement simultaneously defines an exit point,
<em class="pcalibre1 calibre8 pcalibre">and</em> a re-entry point. In fact, you can have multiple <code class="pcalibre1 pcalibre literal">yield</code>
statements in a generator:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">def</span> gen_extra_nums():
    n = 0
    <span class="pcalibre1 pcalibre calibre18">while</span> n &lt; 4:
        <span class="pcalibre1 pcalibre calibre18">yield</span> n
        n += 1
    <span class="pcalibre1 pcalibre calibre18">yield</span> 42 <span class="pcalibre1 pcalibre calibre13"># Second yield</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Here’s the output when you use it:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11">&gt;&gt;&gt; for num in gen_extra_nums():
...     print(num)
0
1
2
3
42</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">The second <code class="pcalibre1 pcalibre literal">yield</code> is reached after the <code class="pcalibre1 pcalibre literal">while</code> loop exits. When the
function reaches the implicit return at the end, the iteration
stops. Reason through the code above, and convince yourself it makes
sense.</p>
<p class="pcalibre1 pcalibre calibre7">Let’s revisit the earlier example, of cycling through a sequence
of squares. This is how we first did it:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">def</span> fetch_squares(max_root):
    squares = []
    <span class="pcalibre1 pcalibre calibre18">for</span> n <span class="pcalibre1 pcalibre calibre18">in</span> range(max_root):
        squares.append(n**2)
    <span class="pcalibre1 pcalibre calibre18">return</span> squares

MAX = 5
<span class="pcalibre1 pcalibre calibre18">for</span> square <span class="pcalibre1 pcalibre calibre18">in</span> fetch_squares(MAX):
    do_something_with(square)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">As an exercise, pause here, open up a new Python file, and see if you
can write a <code class="pcalibre1 pcalibre literal">gen_squares</code> generator function that accomplishes the
same thing.</p>
<p class="pcalibre1 pcalibre calibre7">Done? Great. Here’s what it looks like:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre18">def</span> gen_squares(max_num):
...     <span class="pcalibre1 pcalibre calibre18">for</span> num <span class="pcalibre1 pcalibre calibre18">in</span> range(max_num):
...         <span class="pcalibre1 pcalibre calibre18">yield</span> num ** 2
...
&gt;&gt;&gt; MAX = 5
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre18">for</span> square <span class="pcalibre1 pcalibre calibre18">in</span> gen_squares(MAX):
...     <span class="pcalibre1 pcalibre calibre18">print</span>(square)
0
1
4
9
16</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Now, this <code class="pcalibre1 pcalibre literal">gen_squares</code> has a problem in Python 2, but not Python
3. Can you spot it?</p>
<p class="pcalibre1 pcalibre calibre7">Here it is:  <code class="pcalibre1 pcalibre literal">range</code> returns an iterator in Python
3, but in Python 2 it returns a list. If MAX is huge, that creates a
huge list inside, killing scalability. So if you are using Python
2, your <code class="pcalibre1 pcalibre literal">gen_squares</code> needs to use <code class="pcalibre1 pcalibre literal">xrange</code> instead,
 which acts just like Python 3’s <code class="pcalibre1 pcalibre literal">range</code>.</p>
<p class="pcalibre1 pcalibre calibre7">The larger point here affects all versions of Python. Generator
functions <em class="pcalibre1 calibre8 pcalibre">potentially</em> have a small memory footprint, but only if you
code intelligently. When writing generator functions, be watchful for
hidden bottlenecks.</p>
<p class="pcalibre1 pcalibre calibre7">Now, strictly speaking, we don’t <em class="pcalibre1 calibre8 pcalibre">need</em> generator functions for
iteration. We just <em class="pcalibre1 calibre8 pcalibre">want</em> them, because they make certain patterns of
scalability far easier.  Now that we’re in a position to understand
it, let’s look at the <code class="pcalibre1 pcalibre literal">SquaresIterator</code> class again:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre13"># Same code we saw earlier.</span>
<span class="pcalibre1 pcalibre calibre18">class</span> <span class="pcalibre1 pcalibre calibre18">SquaresIterator</span>:
    <span class="pcalibre1 pcalibre calibre18">def</span> __init__(self, max_root_value):
        self.max_root_value = max_root_value
        self.current_root_value = 0
    <span class="pcalibre1 pcalibre calibre18">def</span> __iter__(self):
        <span class="pcalibre1 pcalibre calibre18">return</span> self
    <span class="pcalibre1 pcalibre calibre18">def</span> __next__(self):
        <span class="pcalibre1 pcalibre calibre18">if</span> self.current_root_value &gt;= self.max_root_value:
            <span class="pcalibre1 pcalibre calibre18">raise</span> <span class="pcalibre1 pcalibre calibre18">StopIteration</span>
        square_value = self.current_root_value ** 2
        self.current_root_value += 1
        <span class="pcalibre1 pcalibre calibre18">return</span> square_value

<span class="pcalibre1 pcalibre calibre13"># You can use it like this:</span>
<span class="pcalibre1 pcalibre calibre18">for</span> square <span class="pcalibre1 pcalibre calibre18">in</span> SquaresIterator(5):
    <span class="pcalibre1 pcalibre calibre18">print</span>(square)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Each value is obtained by invoking its <code class="pcalibre1 pcalibre literal">__next__</code> method, until it
raises <code class="pcalibre1 pcalibre literal">StopIteration</code>. This produces the same output; but look at the
source for the <code class="pcalibre1 pcalibre literal">SquaresIterator</code> class, and compare it to the source
for the generator above. Which is easier to read? Which is easier to
maintain?  And when requirements change, which is easier to modify
without introducing errors? Most people find the generator solution
easier and more natural.</p>
<p class="pcalibre1 pcalibre calibre7">
Authors often use the word "generator" by itself, to mean
either the generator function, <em class="pcalibre1 calibre8 pcalibre">or</em> the generator object returned when
you call it. Typically the writer thinks it’s obvious by the context
which they are referring to; sometimes it is, sometimes not.
Sometimes the writer is not even clear on the distinction to begin
with. But it’s important: just as there is a big difference between a
function, and the value it returns when you call it, so is there a big
difference between the generator function, and the generator object it returns.</p>
<p class="pcalibre1 pcalibre calibre7">In your own thought and speech, I encourage you to only use the
phrases "generator function" and "generator object", so you are always
clear inside yourself, and in your communication. (Which also helps
your teammates be more clear.)  The only exception: when you truly
mean "generator functions and objects", lumping them together, then
it’s okay to just say "generators". I’ll lead by example in this book.</p>
</section>
<section class="calibre2 pcalibre1 pcalibre" title="Generator Patterns and Scalable Composability">
<h2 id="calibre_link-69" class="pcalibre1 pcalibre calibre1">Generator Patterns and Scalable Composability</h2>
<p class="pcalibre1 pcalibre calibre7">Here’s a little generator function:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">def</span> matching_lines_from_file(path, pattern):
    <span class="pcalibre1 pcalibre calibre18">with</span> open(path) <span class="pcalibre1 pcalibre calibre18">as</span> handle:
        <span class="pcalibre1 pcalibre calibre18">for</span> line <span class="pcalibre1 pcalibre calibre18">in</span> handle:
            <span class="pcalibre1 pcalibre calibre18">if</span> pattern <span class="pcalibre1 pcalibre calibre18">in</span> line:
                <span class="pcalibre1 pcalibre calibre18">yield</span> line.rstrip(<span class="pcalibre1 pcalibre calibre13">'</span><span class="pcalibre1 pcalibre calibre20">\n</span><span class="pcalibre1 pcalibre calibre13">'</span>)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">

<code class="pcalibre1 pcalibre literal">matching_lines_from_file()</code> demonstrates several important practices
for modern Python, and is worth studying. It does simple substring
matching on lines of a text file, yielding lines containing that
substring.</p>
<p class="pcalibre1 pcalibre calibre7">The first line opens a read-only file object, called <code class="pcalibre1 pcalibre literal">handle</code>. If you
haven’t been opening your file objects using <code class="pcalibre1 pcalibre literal">with</code> statements, start
today. The main benefit is that once the <code class="pcalibre1 pcalibre literal">with</code> block is exited, the
file object is automatically closed - even if an exception causes a
premature exit. It’s similar to:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">try</span>:
    handle = open(path)
    <span class="pcalibre1 pcalibre calibre13"># read from handle</span>
<span class="pcalibre1 pcalibre calibre18">finally</span>:
    handle.close()</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">(The <code class="pcalibre1 pcalibre literal">try</code>/<code class="pcalibre1 pcalibre literal">finally</code> is explained in the exceptions chapter.)  Next we
have <code class="pcalibre1 pcalibre literal">for line in handle</code>. This useful idiom, which not many people
seem to know about, is a special case for text files. Each iteration
through the <code class="pcalibre1 pcalibre literal">for</code> loop, a new line of text will be read from the
underlying text file, and placed in the <code class="pcalibre1 pcalibre literal">line</code> variable.</p>
<p class="pcalibre1 pcalibre calibre7">Sometimes people foolishly take another approach, which I have to warn
you about:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre13"># Don't do this!!</span>
<span class="pcalibre1 pcalibre calibre18">for</span> line <span class="pcalibre1 pcalibre calibre18">in</span> handle.readlines():</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7"><code class="pcalibre1 pcalibre literal">.readlines()</code> (plural) reads in the <em class="pcalibre1 calibre8 pcalibre">entire file</em>, parses it into
lines, and returns a list of strings - one string per line. By now,
you realize how this destroys the generator
function’s scalability.</p>
<p class="pcalibre1 pcalibre calibre7">Another approach you will sometimes see, which <em class="pcalibre1 calibre8 pcalibre">is</em> scalable, is to
use the file object’s <code class="pcalibre1 pcalibre literal">.readline()</code> method (singular), which manually
returns lines one at a time:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre13"># .readline() reads and returns a single line of text,</span>
<span class="pcalibre1 pcalibre calibre13"># or returns the empty string at end-of-file.</span>
line = handle.readline()
<span class="pcalibre1 pcalibre calibre18">while</span> line != <span class="pcalibre1 pcalibre calibre13">''</span>:
    <span class="pcalibre1 pcalibre calibre13"># do something with line</span>
    <span class="pcalibre1 pcalibre calibre13"># ...</span>
    <span class="pcalibre1 pcalibre calibre13"># At the end of the loop, read the next line.</span>
    line = handle.readline()</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">But simply writing <code class="pcalibre1 pcalibre literal">for line in handle</code> is clearer and easier.</p>
<p class="pcalibre1 pcalibre calibre7">After that, it’s straightforward: matching lines have any trailing
<code class="pcalibre1 pcalibre literal">\n</code>-character stripped, and are yielded to the consumer. When writing
generator functions, you want to ask yourself "what is the maximum
memory footprint of this function, and how can I minimize it?"  You
can think of scalability as inversely proportional to this
footprint. For <code class="pcalibre1 pcalibre literal">matching_lines_from_file()</code>, it will be about equal to
the size of the longest line in the text file. So it’s appropriate for
the typical human-readable text file, whose lines are small.</p>
<p class="pcalibre1 pcalibre calibre7">(It’s also possible to point it to, say, a ten-terabyte text file
consisting of exactly one line. If you expect something like <em class="pcalibre1 calibre8 pcalibre">that</em>,
you’ll need a different approach.)</p>
<p class="pcalibre1 pcalibre calibre7">Now, suppose a log file contains lines like this:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11">WARNING: Disk usage exceeding 85%
DEBUG: User 'tinytim' upgraded to Pro version
INFO: Sent email campaign, completed normally
WARNING: Almost out of beer</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">... and you exercise <code class="pcalibre1 pcalibre literal">matching_lines_from_file()</code> like so:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11">for line in matching_lines_from_file("log.txt","WARNING:"):
    print(line)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">That yields these records:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11">WARNING: Disk usage exceeding 85%
WARNING: Almost out of beer</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Suppose your application needs that data in dict form:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11">{"level": "WARNING", "message": "Disk usage exceeding 85%"}
{"level": "DEBUG", "message":
    "User 'tinytim' upgraded to Pro version"}</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">We want to scalably transform the records from one form to another -
from strings (lines of the log file), to Python dicts. So let’s make a
new generator function to connect them:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">def</span> parse_log_records(lines):
    <span class="pcalibre1 pcalibre calibre18">for</span> line <span class="pcalibre1 pcalibre calibre18">in</span> lines:
        level, message = line.split(<span class="pcalibre1 pcalibre calibre13">": "</span>, 1)
        <span class="pcalibre1 pcalibre calibre18">yield</span> {<span class="pcalibre1 pcalibre calibre13">"level"</span>: level, <span class="pcalibre1 pcalibre calibre13">"message"</span>: message}</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Now we can connect the two:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre13"># log_lines is a generator object</span>
log_lines = matching_lines_from_file(<span class="pcalibre1 pcalibre calibre13">"log.txt"</span>, <span class="pcalibre1 pcalibre calibre13">"WARNING:"</span>)
<span class="pcalibre1 pcalibre calibre18">for</span> record <span class="pcalibre1 pcalibre calibre18">in</span> parse_log_records(log_lines):
    <span class="pcalibre1 pcalibre calibre13"># record is a dict</span>
    <span class="pcalibre1 pcalibre calibre18">print</span>(record)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Of course, <code class="pcalibre1 pcalibre literal">parse_log_records()</code> can be used on its own:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">with</span> open(<span class="pcalibre1 pcalibre calibre13">"log.txt"</span>) <span class="pcalibre1 pcalibre calibre18">as</span> handle:
    <span class="pcalibre1 pcalibre calibre18">for</span> record <span class="pcalibre1 pcalibre calibre18">in</span> parse_log_records(handle):
        <span class="pcalibre1 pcalibre calibre18">print</span>(record)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7"><code class="pcalibre1 pcalibre literal">matching_lines_from_file()</code> and <code class="pcalibre1 pcalibre literal">parse_log_records()</code> are like building
blocks. Properly designed, they can be used to build different data
processing streams. I call this <em class="pcalibre1 calibre8 pcalibre">scalable composability</em>.
It goes beyond designing composable functions and types.
Ask yourself how you can make the components scalable, <strong class="pcalibre1 pcalibre calibre9">and</strong> whatever
is assembled out of them scalable too.</p>
<p class="pcalibre1 pcalibre calibre7">Let’s discuss a particular design point. Both
<code class="pcalibre1 pcalibre literal">matching_lines_from_file()</code> and <code class="pcalibre1 pcalibre literal">parse_log_records()</code> produce an
iterator. (Or, more specifically, a generator object). But they have a
discrepancy on the input side: <code class="pcalibre1 pcalibre literal">parse_log_records()</code> accepts an
iterator, but <code class="pcalibre1 pcalibre literal">matching_lines_from_file()</code> requires a path to a file to
read from.  This means <code class="pcalibre1 pcalibre literal">matching_lines_from_file()</code> combines two
functions: read lines of text from a file, then filter those lines
based on some criteria.</p>
<p class="pcalibre1 pcalibre calibre7">Combining functions like this is often what you want in realistic
code. But when designing components to flexibly compose together,
inconsistent interfaces like this can be limiting. Let’s break up the
services in <code class="pcalibre1 pcalibre literal">matching_lines_from_file()</code> into two generator functions:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">def</span> lines_from_file(path):
    <span class="pcalibre1 pcalibre calibre18">with</span> open(path) <span class="pcalibre1 pcalibre calibre18">as</span> handle:
        <span class="pcalibre1 pcalibre calibre18">for</span> line <span class="pcalibre1 pcalibre calibre18">in</span> handle:
            <span class="pcalibre1 pcalibre calibre18">yield</span> line.rstrip(<span class="pcalibre1 pcalibre calibre13">'</span><span class="pcalibre1 pcalibre calibre20">\n</span><span class="pcalibre1 pcalibre calibre13">'</span>)

<span class="pcalibre1 pcalibre calibre18">def</span> matching_lines(lines, pattern):
    <span class="pcalibre1 pcalibre calibre18">for</span> line <span class="pcalibre1 pcalibre calibre18">in</span> lines:
        <span class="pcalibre1 pcalibre calibre18">if</span> pattern <span class="pcalibre1 pcalibre calibre18">in</span> line:
            <span class="pcalibre1 pcalibre calibre18">yield</span> line</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">You can compose these like so:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>lines = lines_from_file(<span class="pcalibre1 pcalibre calibre13">"log.txt"</span>)
matching = matching_lines(lines, <span class="pcalibre1 pcalibre calibre13">'WARNING:'</span>)
<span class="pcalibre1 pcalibre calibre18">for</span> line <span class="pcalibre1 pcalibre calibre18">in</span> matching:
    <span class="pcalibre1 pcalibre calibre18">print</span>(line)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Or even redefine <code class="pcalibre1 pcalibre literal">matching_lines_from_file()</code> in terms of them:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">def</span> matching_lines_from_file(pattern, path):
    lines = lines_from_file(path)
    matching = matching_lines(lines, pattern)
    <span class="pcalibre1 pcalibre calibre18">for</span> line <span class="pcalibre1 pcalibre calibre18">in</span> matching:
        <span class="pcalibre1 pcalibre calibre18">yield</span> line</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Conceptually, this factored-out <code class="pcalibre1 pcalibre literal">matching_lines</code> does a <em class="pcalibre1 calibre8 pcalibre">filtering</em>
operation; all lines are read in, and a subset are
yielded. <code class="pcalibre1 pcalibre literal">parse_log_records()</code> is different. One input record (a <code class="pcalibre1 pcalibre literal">str</code>
line) maps to exactly one output record (a <code class="pcalibre1 pcalibre literal">dict</code>). Mathematically,
it’s a <em class="pcalibre1 calibre8 pcalibre">mapping</em> operation.  Think of it as a transformer or
adapter.  <code class="pcalibre1 pcalibre literal">lines_from_file()</code> is in a third category; instead of taking
a stream as input, it takes a completely different parameter. Since it
still returns an iterator of records, think of it as a <em class="pcalibre1 calibre8 pcalibre">source</em>. And
any real program will eventually want to do something with that
stream, consuming it without producing another iterator; call that a
<em class="pcalibre1 calibre8 pcalibre">sink</em>.</p>
<p class="pcalibre1 pcalibre calibre7">You need all these pieces to make a working program.  When designing a
chainable set of generator functions like this - or even better, a
toolkit for constructing internal data pipelines - ask yourself
whether each component is a sink, a source, or whether it does
filtering, or mapping; or whether it’s some combination of these. Just
asking yourself this question leads to a more usable, readable, and
maintainable codebase. And if you’re making a library which others
will use, you’re more likely to end up with a toolkit so powerfully
flexible, people use it to build programs you never imagined.</p>
<p class="pcalibre1 pcalibre calibre7">I want you to notice something about <code class="pcalibre1 pcalibre literal">parse_log_records()</code>. As I said,
it fits in the "mapping" category. And notice its mapping is
one-to-one: one line of text becomes one dictionary. In other words,
each record in the input - a <code class="pcalibre1 pcalibre literal">str</code> - becomes <em class="pcalibre1 calibre8 pcalibre">exactly one</em> record in
the output - a <code class="pcalibre1 pcalibre literal">dict</code>.</p>
<p class="pcalibre1 pcalibre calibre7">That isn’t always the case. Sometimes, your generator function needs
to consume several input records to create one output record. Or the
opposite: one input record yields several output records.</p>
<p class="pcalibre1 pcalibre calibre7">Here’s an example of the latter. Imagine a text file containing lines
in a poem:<sup class="pcalibre1 pcalibre noteref">[<a href="#calibre_link-38" id="calibre_link-42" type="noteref" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">1</a>]</sup></p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11">all night our room was outer-walled with rain
drops fell and flattened on the tin roof
and rang like little disks of metal</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Let’s create a generator function, <code class="pcalibre1 pcalibre literal">words_in_text()</code>, producing the
words one at a time. First approach:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre13"># lines is an iterator of text file lines,</span>
<span class="pcalibre1 pcalibre calibre13"># e.g. returned by lines_from_file()</span>
<span class="pcalibre1 pcalibre calibre18">def</span> words_in_text(lines):
    <span class="pcalibre1 pcalibre calibre18">for</span> line <span class="pcalibre1 pcalibre calibre18">in</span> lines:
        <span class="pcalibre1 pcalibre calibre18">for</span> word <span class="pcalibre1 pcalibre calibre18">in</span> line.split():
            <span class="pcalibre1 pcalibre calibre18">yield</span> word</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">This generator function takes a <em class="pcalibre1 calibre8 pcalibre">fan out</em> approach. No input records
are dropped, which means it doesn’t do any filtering; it’s still
purely in the "mapping" category of generator functions. But the
mapping isn’t one to one. Rather, one input record produces one or
more output records. So, when you run the following code:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>poem_lines = lines_from_file(<span class="pcalibre1 pcalibre calibre13">"poem.txt"</span>)
poem_words = words_in_text(poem_lines)
<span class="pcalibre1 pcalibre calibre18">for</span> word <span class="pcalibre1 pcalibre calibre18">in</span> poem_words:
    <span class="pcalibre1 pcalibre calibre18">print</span>(word)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">... it produces this output:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11">all
night
our
room
was
outer-walled
...</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">That first input record - "all night our room was outer-walled with
rain" - yields eight words (output records). Ignoring any blank lines
in the poem, every line of prose will produce at least one -
probably several - words.</p>
<p class="pcalibre1 pcalibre calibre7">The idea of fanning out is interesting, but simple enough. It’s more
complex when we go the opposite direction: fanning <em class="pcalibre1 calibre8 pcalibre">in</em>. That means
the generator function consumes more than one input record to produce
each output record. Doing this successfully requires an awareness of
the input’s structure, and you’ll typically need to encode some
simple parsing logic.</p>
<p class="pcalibre1 pcalibre calibre7">Imagine a text file containing residential house sale data. Each
record is a set of key-value pairs, one pair per line, with records
separated by blank lines:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11">address: 1423 99th Ave
square_feet: 1705
price_usd: 340210

address: 24257 Pueblo Dr
square_feet: 2305
price_usd: 170210

address: 127 Cochran
square_feet: 2068
price_usd: 320500</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">To read this data into a form usable in our code, what we want is a
generator function - let’s name it <code class="pcalibre1 pcalibre literal">house_records()</code> - which accepts
a sequence of strings (lines) and parses them into convenient dictionaries:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11">&gt;&gt;&gt; lines_of_house_data = lines_from_file("housedata.txt")
&gt;&gt;&gt; houses = house_records(lines_of_house_data)
&gt;&gt;&gt; # Fetch the first record.
... house = next(houses)
&gt;&gt;&gt; house['address']
'1423 99th Ave'
&gt;&gt;&gt; house = next(houses)
&gt;&gt;&gt; house['address']
'24257 Pueblo Dr'</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">How would you create this? If practical, pause here, open up a code
editor, and see if you can implement it.</p>
<p class="pcalibre1 pcalibre calibre7">Okay, time’s up. Here is one approach:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">def</span> house_records(lines):
    record = {}
    <span class="pcalibre1 pcalibre calibre18">for</span> line <span class="pcalibre1 pcalibre calibre18">in</span> lines:
        <span class="pcalibre1 pcalibre calibre18">if</span> line == <span class="pcalibre1 pcalibre calibre13">''</span>:
            <span class="pcalibre1 pcalibre calibre18">yield</span> record
            record = {}
            <span class="pcalibre1 pcalibre calibre18">continue</span>
        key, value = line.split(<span class="pcalibre1 pcalibre calibre13">': '</span>, 1)
        record[key] = value
    <span class="pcalibre1 pcalibre calibre18">yield</span> record</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Notice where the <code class="pcalibre1 pcalibre literal">yield</code> keywords appear. The last line of the <code class="pcalibre1 pcalibre literal">for</code>
loop reads individual key-value pairs. Starting with an empty record
dictionary, it’s populated with data until <code class="pcalibre1 pcalibre literal">lines</code> produces an empty
line. That signals the current record is complete, so it’s
<code class="pcalibre1 pcalibre literal">yield</code>-ed, and a new record dictionary created. The end of the
very last record in <code class="pcalibre1 pcalibre literal">housedata.txt</code> is signaled not by an empty line,
but by the end of the file; that’s why we need the final <code class="pcalibre1 pcalibre literal">yield</code>
statement.</p>
<p class="pcalibre1 pcalibre calibre7">As defined, <code class="pcalibre1 pcalibre literal">house_records()</code> is a bit clunky if we’re normally reading
from a text file. It makes sense to define a new generator function
accepting just the path to the file:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">def</span> house_records_from_file(path):
    lines = lines_from_file(path)
    <span class="pcalibre1 pcalibre calibre18">for</span> house <span class="pcalibre1 pcalibre calibre18">in</span> house_records(lines):
        <span class="pcalibre1 pcalibre calibre18">yield</span> house

<span class="pcalibre1 pcalibre calibre13"># Then in your program:</span>
<span class="pcalibre1 pcalibre calibre18">for</span> house <span class="pcalibre1 pcalibre calibre18">in</span> house_records_from_file(<span class="pcalibre1 pcalibre calibre13">"housedata.txt"</span>):
    <span class="pcalibre1 pcalibre calibre18">print</span>(house[<span class="pcalibre1 pcalibre calibre13">"address"</span>])</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">You may have noticed many of these examples have a bit of
boilerplate, when one generator function internally calls another.
The last two lines of <code class="pcalibre1 pcalibre literal">house_records_from_file</code> say:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>    <span class="pcalibre1 pcalibre calibre18">for</span> house <span class="pcalibre1 pcalibre calibre18">in</span> house_records(lines):
        <span class="pcalibre1 pcalibre calibre18">yield</span> house</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Python 3 provides a shortcut, which lets you accomplish this in one
line, with the <code class="pcalibre1 pcalibre literal">yield from</code> statement:
</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">def</span> house_records_from_file(path):
    lines = lines_from_file(path)
    <span class="pcalibre1 pcalibre calibre18">yield from</span> house_records(lines)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Even though "yield from" is two words, semantically it’s like a single
keyword, and distinct from <code class="pcalibre1 pcalibre literal">yield</code>. The <code class="pcalibre1 pcalibre literal">yield from</code> statement is used
specifically in generator functions, when they yield values directly
from another generator object (or, equivalently, by calling another
generator function). Using it often simplifies your code, as you see
in <code class="pcalibre1 pcalibre literal">house_records_from_file()</code>. Going back a bit, here’s how it works
with <code class="pcalibre1 pcalibre literal">matching_lines_from_file()</code>:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">def</span> matching_lines_from_file(pattern, path):
    lines = lines_from_file(<span class="pcalibre1 pcalibre calibre13">"log.txt"</span>)
    <span class="pcalibre1 pcalibre calibre18">yield from</span> matching_lines(lines, <span class="pcalibre1 pcalibre calibre13">'WARNING:'</span>)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">The formal name for what <code class="pcalibre1 pcalibre literal">yield from</code> does is "delegating to a
sub-generator", and instills a deeper connection between the
containing and inner generator objects.  In particular, generator
objects have certain methods - <code class="pcalibre1 pcalibre literal">send</code>, <code class="pcalibre1 pcalibre literal">throw</code> and <code class="pcalibre1 pcalibre literal">close</code> - for
passing information back <em class="pcalibre1 calibre8 pcalibre">into</em> the context of the running
generator function. I won’t cover them in this edition of the book, as
they are not currently widely used; you can learn more by reading PEPs
342 and 380.<sup class="pcalibre1 pcalibre noteref">[<a href="#calibre_link-39" id="calibre_link-43" type="noteref" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">2</a>]</sup> If you
do use them, <code class="pcalibre1 pcalibre literal">yield from</code> becomes necessary to enable the flow of
information back into the scope of the running coroutine.</p>
</section>
<section class="calibre2 pcalibre1 pcalibre" title="Python is Filled With Iterators">
<h2 id="calibre_link-70" class="pcalibre1 pcalibre calibre1">Python is Filled With Iterators</h2>
<p class="pcalibre1 pcalibre calibre7">Let’s look at Python 3 dictionaries:<sup class="pcalibre1 pcalibre noteref">[<a href="#calibre_link-40" id="calibre_link-44" type="noteref" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">3</a>]</sup></p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; calories = {
...     <span class="pcalibre1 pcalibre calibre13">"apple"</span>: 95,
...     <span class="pcalibre1 pcalibre calibre13">"slice of bacon"</span>: 43,
...     <span class="pcalibre1 pcalibre calibre13">"cheddar cheese"</span>: 113,
...     <span class="pcalibre1 pcalibre calibre13">"ice cream"</span>: 15, <span class="pcalibre1 pcalibre calibre13"># You wish!</span>
... }
&gt;&gt;&gt; items = calories.items()
&gt;&gt;&gt; type(items)
&lt;<span class="pcalibre1 pcalibre calibre18">class</span> <span class="pcalibre1 pcalibre calibre19">'</span><span class="pcalibre1 pcalibre calibre18">dict_items</span><span class="pcalibre1 pcalibre calibre13">'&gt;</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7"> So what is this <code class="pcalibre1 pcalibre literal">dict_items</code>
object returned by <code class="pcalibre1 pcalibre literal">calories.items()</code>?  It turns out to be what Python
calls a <em class="pcalibre1 calibre8 pcalibre">view</em>. There is not any kind of base view type; rather, an
object quacks like a dictionary view if it supports three things:</p>
<div class="pcalibre1 pcalibre itemized-list">
<ul class="pcalibre1 calibre14 pcalibre">
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre"><code class="pcalibre1 pcalibre literal">len(view)</code> returns the number of items,</span>
</li>
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre"><code class="pcalibre1 pcalibre literal">iter(view)</code> returns an iterator over the key-value pairs, and</span>
</li>
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre"><code class="pcalibre1 pcalibre literal">(key, value) in view</code> returns True if that <code class="pcalibre1 pcalibre literal">key</code>-<code class="pcalibre1 pcalibre literal">value</code> pair is in the dictionary, else False.</span>
</li>
</ul>
</div>
<p class="pcalibre1 pcalibre calibre7">In other words, a dictionary view is iterable, with a couple of bonus
features. It also dynamically updates if its source dictionary
changes:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; items = calories.items()
&gt;&gt;&gt; len(items)
4
&gt;&gt;&gt; calories[<span class="pcalibre1 pcalibre calibre13">'orange'</span>] = 50
&gt;&gt;&gt; len(items)
5
&gt;&gt;&gt; (<span class="pcalibre1 pcalibre calibre13">'orange'</span>, 50) <span class="pcalibre1 pcalibre calibre18">in</span> items
True
&gt;&gt;&gt; (<span class="pcalibre1 pcalibre calibre13">'orange'</span>, 20) <span class="pcalibre1 pcalibre calibre18">in</span> items
False</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Dictionaries also have <code class="pcalibre1 pcalibre literal">.keys()</code> and <code class="pcalibre1 pcalibre literal">.values()</code>. Like <code class="pcalibre1 pcalibre literal">.items()</code>,
they each return a view. But instead of key-value pairs, they only
contain keys or values, respectively:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; foods = calories.keys()
&gt;&gt;&gt; counts = calories.values()
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13">'yogurt'</span> <span class="pcalibre1 pcalibre calibre18">in</span> foods
False
&gt;&gt;&gt; 100 <span class="pcalibre1 pcalibre calibre18">in</span> counts
False
&gt;&gt;&gt; calories[<span class="pcalibre1 pcalibre calibre13">'yogurt'</span>] = 100
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13">'yogurt'</span> <span class="pcalibre1 pcalibre calibre18">in</span> foods
True
&gt;&gt;&gt; 100 <span class="pcalibre1 pcalibre calibre18">in</span> counts
True</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">In Python 2 (explained more below), <code class="pcalibre1 pcalibre literal">items()</code> returns a list of
key-value tuples, rather than a view; Python 2 also has an
<code class="pcalibre1 pcalibre literal">iteritems()</code> method that returns an iterator (rather than an iterable
view object). Python 3’s version of the <code class="pcalibre1 pcalibre literal">items()</code> method essentially
obsoletes both of these. When you do need a list of key-value pairs in
Python 3, just write <code class="pcalibre1 pcalibre literal">list(calories.items())</code>.</p>
<p class="pcalibre1 pcalibre calibre7">
Iteration has snuck into many places in Python. The built-in <code class="pcalibre1 pcalibre literal">range</code>
function returns an iterable:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">&gt;&gt;&gt; </span>seq = range(3)
<span class="pcalibre1 pcalibre calibre18">&gt;&gt;&gt; </span>type(seq)
&lt;class 'range'&gt;
<span class="pcalibre1 pcalibre calibre18">&gt;&gt;&gt; for</span> n <span class="pcalibre1 pcalibre calibre18">in</span> seq: <span class="pcalibre1 pcalibre calibre18">print</span>(n)
0
1
2</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">


The built-in <code class="pcalibre1 pcalibre literal">map</code>, <code class="pcalibre1 pcalibre literal">filter</code>, and <code class="pcalibre1 pcalibre literal">zip</code> functions all return
iterators:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; numbers = [1, 2, 3]
&gt;&gt;&gt; big_numbers = [100, 200, 300]
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre18">def</span> double(n):
...     <span class="pcalibre1 pcalibre calibre18">return</span> 2 * n
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre18">def</span> is_even(n):
...     <span class="pcalibre1 pcalibre calibre18">return</span> n % 2 == 0
&gt;&gt;&gt; mapped = map(double, numbers)
&gt;&gt;&gt; mapped
&lt;map object at 0x1013ac518&gt;
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre18">for</span> num <span class="pcalibre1 pcalibre calibre18">in</span> mapped: <span class="pcalibre1 pcalibre calibre18">print</span>(num)
2
4
6</code></pre>
</figure>
<figure class="pcalibre1 pcalibre footnotes">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; filtered = filter(is_even, numbers)
&gt;&gt;&gt; filtered
&lt;filter object at 0x1013ac668&gt;
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre18">for</span> num <span class="pcalibre1 pcalibre calibre18">in</span> filtered: <span class="pcalibre1 pcalibre calibre18">print</span>(num)
2</code></pre>
</figure>
<figure class="pcalibre1 pcalibre footnotes">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; zipped = zip(numbers, big_numbers)
&gt;&gt;&gt; zipped
&lt;zip object at 0x1013a9608&gt;
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre18">for</span> pair <span class="pcalibre1 pcalibre calibre18">in</span> zipped: <span class="pcalibre1 pcalibre calibre18">print</span>(pair)
(1, 100)
(2, 200)
(3, 300)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Notice that <code class="pcalibre1 pcalibre literal">mapped</code> is something called a "map object", rather than a
list of the results of the calculation; and similar for <code class="pcalibre1 pcalibre literal">filtered</code> and
<code class="pcalibre1 pcalibre literal">zipped</code>. These are all iterators - giving you all the benefits of
iteration, built into the language.</p>
<section class="calibre2 pcalibre1 pcalibre" title="Python 2’s Differences">
<h3 id="calibre_link-169" class="pcalibre1 calibre21 pcalibre">Python 2’s Differences</h3>
<p class="pcalibre1 pcalibre calibre7">






</p>
<p class="pcalibre1 pcalibre calibre7">For Python 2, I’ll start with some recommendations, before explaining them:</p>
<div class="pcalibre1 pcalibre itemized-list">
<ul class="pcalibre1 calibre14 pcalibre">
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">With dictionaries, always use <code class="pcalibre1 pcalibre literal">viewitems()</code> rather than <code class="pcalibre1 pcalibre literal">items()</code>
or <code class="pcalibre1 pcalibre literal">iteritems()</code>. The only exception: if you truly need a list of
tuples, use <code class="pcalibre1 pcalibre literal">items()</code>.</span>
</li>
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">Likewise for <code class="pcalibre1 pcalibre literal">viewkeys()</code> and <code class="pcalibre1 pcalibre literal">viewvalues()</code>, rather than <code class="pcalibre1 pcalibre literal">keys()</code>,
<code class="pcalibre1 pcalibre literal">iterkeys()</code>, <code class="pcalibre1 pcalibre literal">values()</code>, and <code class="pcalibre1 pcalibre literal">itervalues()</code>.</span>
</li>
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">Use <code class="pcalibre1 pcalibre literal">xrange()</code> instead of <code class="pcalibre1 pcalibre literal">range()</code>, unless you have a special need
for an actual list.</span>
</li>
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">Be aware that <code class="pcalibre1 pcalibre literal">map</code>, <code class="pcalibre1 pcalibre literal">filter</code>, and <code class="pcalibre1 pcalibre literal">zip</code> create lists; if your data
may grow large, use <code class="pcalibre1 pcalibre literal">imap</code>, <code class="pcalibre1 pcalibre literal">ifilter</code> or <code class="pcalibre1 pcalibre literal">izip</code> from the
<code class="pcalibre1 pcalibre literal">itertools</code> module instead.</span>
</li>
</ul>
</div>
<p class="pcalibre1 pcalibre calibre7">These differently named methods and functions essentially have the
same behavior as Python 3’s more scalable versions. Python 2’s
<code class="pcalibre1 pcalibre literal">xrange</code> is just like Python 3’s <code class="pcalibre1 pcalibre literal">range</code>; Python 2’s <code class="pcalibre1 pcalibre literal">itertools.imap</code>
is just like Python 3’s <code class="pcalibre1 pcalibre literal">map</code>; and so on.</p>
<p class="pcalibre1 pcalibre calibre7">Let’s examine Python 2’s dictionary methods. In Python 2,
<code class="pcalibre1 pcalibre literal">calories.items()</code> returns a list of <code class="pcalibre1 pcalibre literal">(key, value)</code> tuples. So if the
dictionary has 10,000 keys, you’d get a list of 10,000
tuples. Similarly, <code class="pcalibre1 pcalibre literal">calories.keys()</code> returns a list of keys;
<code class="pcalibre1 pcalibre literal">calories.values()</code> returns a list of values.  The problems with this
will be obvious to you by now: the loop blocks until you create and
populate a list, which is immediately thrown away once the loop exits.</p>
<p class="pcalibre1 pcalibre calibre7">Python 2 addressed this by introducing two other
methods: <code class="pcalibre1 pcalibre literal">iteritems()</code>, returning an iterator over the key-value
tuples; and (later) <code class="pcalibre1 pcalibre literal">viewitems()</code>, which returned a view - an iterable
type. Similarly, <code class="pcalibre1 pcalibre literal">keys()</code> gave a list of keys, and they added
<code class="pcalibre1 pcalibre literal">iterkeys()</code> and then <code class="pcalibre1 pcalibre literal">viewkeys()</code>; and again for <code class="pcalibre1 pcalibre literal">values()</code>,
<code class="pcalibre1 pcalibre literal">itervalues()</code>, and <code class="pcalibre1 pcalibre literal">viewvalues()</code>.</p>
<p class="pcalibre1 pcalibre calibre7">In Python 3, what used to be called <code class="pcalibre1 pcalibre literal">viewitems()</code> was renamed
<code class="pcalibre1 pcalibre literal">items()</code>, and the old <code class="pcalibre1 pcalibre literal">items()</code> and <code class="pcalibre1 pcalibre literal">iteritems()</code> went
away. Similarly, <code class="pcalibre1 pcalibre literal">keys()</code> and <code class="pcalibre1 pcalibre literal">values()</code> were changed to return views
instead of lists.</p>
<p class="pcalibre1 pcalibre calibre7">For your own Python 2 code, I recommend you start using <code class="pcalibre1 pcalibre literal">viewitems()</code>,
except when you have an explicit reason to do otherwise. Using
<code class="pcalibre1 pcalibre literal">iteritems()</code> is certainly better than using <code class="pcalibre1 pcalibre literal">items()</code>, and for Python
2 code, generally works just as well as <code class="pcalibre1 pcalibre literal">viewitems()</code>. However, if you ever
decide to upgrade that codebase with <code class="pcalibre1 pcalibre literal">2to3</code>, the resulting code will
be closer to your original program.<sup class="pcalibre1 pcalibre noteref">[<a href="#calibre_link-41" id="calibre_link-45" type="noteref" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">4</a>]</sup>  Python 2’s
<code class="pcalibre1 pcalibre literal">viewitems</code> basically obsoleted <code class="pcalibre1 pcalibre literal">iteritems</code>, which is why the latter
has no equivalent in Python 3.</p>
<p class="pcalibre1 pcalibre calibre7">
The situation with <code class="pcalibre1 pcalibre literal">range</code> is simpler. Python 2’s original <code class="pcalibre1 pcalibre literal">range()</code>
function returned a list; later, <code class="pcalibre1 pcalibre literal">xrange()</code> was added, returning an
iterable, and practically speaking obsoleting Python 2’s
<code class="pcalibre1 pcalibre literal">range()</code>. But many people continue to use <code class="pcalibre1 pcalibre literal">range()</code>, for a range
(ha!)  of reasons. Python 3’s version of <code class="pcalibre1 pcalibre literal">range()</code> is essentially the
same as Python 2’s <code class="pcalibre1 pcalibre literal">xrange()</code>, and Python 3 has no function named
<code class="pcalibre1 pcalibre literal">xrange</code>. (Of course, <code class="pcalibre1 pcalibre literal">list(range(…​))</code> will give you an actual list,
if you need it.)</p>
<p class="pcalibre1 pcalibre calibre7">



<code class="pcalibre1 pcalibre literal">map</code>, <code class="pcalibre1 pcalibre literal">filter</code>, and <code class="pcalibre1 pcalibre literal">zip</code> are well used in certain circles. If you
want your Python 2 code using these functions to be fully
forward-compatible, you have to go to a little more trouble: their
iterator-equivalents are all in the <code class="pcalibre1 pcalibre literal">itertools</code> module. So, instead of
this:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>mapped = map(double, numbers)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">you will need to write this:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">from</span> <span class="pcalibre1 pcalibre calibre18">itertools</span> <span class="pcalibre1 pcalibre calibre18">import</span> imap
mapped = imap(double, numbers)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">
The <code class="pcalibre1 pcalibre literal">2to3</code> program will convert Python 2’s <code class="pcalibre1 pcalibre literal">imap(f, items)</code> to <code class="pcalibre1 pcalibre literal">map(f,
items)</code>, but will convert Python 2’s <code class="pcalibre1 pcalibre literal">map(f, items)</code> to <code class="pcalibre1 pcalibre literal">list(map(f,
items))</code>.  The <code class="pcalibre1 pcalibre literal">itertools</code> module similarly has <code class="pcalibre1 pcalibre literal">ifilter</code> and <code class="pcalibre1 pcalibre literal">izip</code>,
for which the same patterns apply.</p>
<p class="pcalibre1 pcalibre calibre7">It’s important to realize that everything described for Python 3 also
applies to Python 2.7, <em class="pcalibre1 calibre8 pcalibre">if</em> you use the different names of the
relevant methods and functions. And that is what I recommend you do,
so you get the scalability benefits of iterators, and have an easier
transition to Python 3.</p>
</section>
</section>
<section class="calibre2 pcalibre1 pcalibre" title="The Iterator Protocol">
<h2 id="calibre_link-71" class="pcalibre1 pcalibre calibre1">The Iterator Protocol</h2>
<p class="pcalibre1 pcalibre calibre7"> This optional section explains Python’s
<strong class="pcalibre1 pcalibre calibre9">iterator protocol</strong> in formal detail, giving you a precise and
low-level understanding of how generators, iterators, and iterables
all work. For the day-to-day coding of most programmers, it’s not
nearly as important as everything else in this chapter. That said, you
need this information to implement your own, custom iterable
collection types. Personally, I also find knowing the protocol helps
me reason through iteration-related issues and edge cases; by knowing
these details, I’m able to quickly troubleshoot and fix certain bugs
that might otherwise eat up my afternoon. If this all sounds valuable
to you, keep reading; otherwise, feel free to skip to the next
chapter.</p>
<p class="pcalibre1 pcalibre calibre7">

As mentioned, Python makes a distinction between <em class="pcalibre1 calibre8 pcalibre">iterators</em>, versus
objects that are <em class="pcalibre1 calibre8 pcalibre">iterable</em>. The difference is subtle to begin with,
and frankly it doesn’t help that the two words sound nearly
identical. Keep clear in your mind that "iterator" and "iterable" are
distinct but related concepts, and the following will be easier to
understand.</p>
<p class="pcalibre1 pcalibre calibre7">
Informally, an iterator is something you can pass to <code class="pcalibre1 pcalibre literal">next()</code>, or use
exactly once in a <code class="pcalibre1 pcalibre literal">for</code> loop. More formally, an object in Python 3 is
an iterator if follows the <strong class="pcalibre1 pcalibre calibre9">iterator protocol</strong>. And an object follows
the iterator protocol if it meets the following criteria:</p>
<div class="pcalibre1 pcalibre itemized-list">
<ul class="pcalibre1 calibre14 pcalibre">
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">It defines a method named <code class="pcalibre1 pcalibre literal">__next__</code>, called with no arguments.</span>
</li>
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">Each time <code class="pcalibre1 pcalibre literal">__next__()</code> is called, it produces the next item in the
sequence.</span>
</li>
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">Until all items have been produced. Then, subsequent calls to
<code class="pcalibre1 pcalibre literal">__next__()</code> raise <code class="pcalibre1 pcalibre literal">StopIteration</code>.</span>
</li>
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">It also defines a boilerplate method named <code class="pcalibre1 pcalibre literal">__iter__</code>,
called with no arguments, and returning the same iterator. Its body
is literally <code class="pcalibre1 pcalibre literal">return self</code>.</span>
</li>
</ul>
</div>
<p class="pcalibre1 pcalibre calibre7">Any object with these methods can call itself a Python iterator. You
are not intended to call the <code class="pcalibre1 pcalibre literal">__next__()</code> method directly. Instead,
you will use the built-in <code class="pcalibre1 pcalibre literal">next()</code> function. To understand better,
here is a simplified way you might write your own <code class="pcalibre1 pcalibre literal">next()</code> function:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">def</span> next(it, default=None):
    <span class="pcalibre1 pcalibre calibre18">try</span>:
        <span class="pcalibre1 pcalibre calibre18">return</span> it.__next__()
    <span class="pcalibre1 pcalibre calibre18">except</span> <span class="pcalibre1 pcalibre calibre18">StopIteration</span>:
        <span class="pcalibre1 pcalibre calibre18">if</span> default <span class="pcalibre1 pcalibre calibre18">is</span> None:
            <span class="pcalibre1 pcalibre calibre18">raise</span>
        <span class="pcalibre1 pcalibre calibre18">return</span> default</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">(This version will not let you specify <code class="pcalibre1 pcalibre literal">None</code> as a default value; the
real built-in <code class="pcalibre1 pcalibre literal">next()</code> will. Otherwise, it’s essentially accurate.)</p>
<p class="pcalibre1 pcalibre calibre7">All the above has one difference in Python 2: the iterator’s method is
named <code class="pcalibre1 pcalibre literal">.next()</code> rather than <code class="pcalibre1 pcalibre literal">.__next__()</code>. Abstracting over this
difference is one reason to use the built-in, top-level <code class="pcalibre1 pcalibre literal">next()</code>
function. Of course, using <code class="pcalibre1 pcalibre literal">next()</code> lets you specify a default value,
whereas <code class="pcalibre1 pcalibre literal">.__next__()</code> and <code class="pcalibre1 pcalibre literal">.next()</code> do not.</p>
<p class="pcalibre1 pcalibre calibre7">

Now, all the above is for the "iterator". Let’s explain the other
word, "iterable". Informally, an object is <em class="pcalibre1 calibre8 pcalibre">iterable</em> if it knows how
to create an iterator over its contents, which you can access with the
built-in <code class="pcalibre1 pcalibre literal">iter()</code> function. More formally,
a Python container object is <em class="pcalibre1 calibre8 pcalibre">iterable</em> if it meets one of these two criteria:</p>
<div class="pcalibre1 pcalibre itemized-list">
<ul class="pcalibre1 calibre14 pcalibre">
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">It defines a method called <code class="pcalibre1 pcalibre literal">__iter__()</code>, which creates and returns
an iterator over the elements in the container; or</span>
</li>
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">it follows the <em class="pcalibre1 calibre8 pcalibre">sequence
protocol</em>. This means it defines <code class="pcalibre1 pcalibre literal">__getitem__</code> - the magic
method for square brackets - and lets you reference <code class="pcalibre1 pcalibre literal">foo[0]</code>,
<code class="pcalibre1 pcalibre literal">foo[1]</code>, etc., raising an <code class="pcalibre1 pcalibre literal">IndexError</code> once you go past the last
element.</span>
</li>
</ul>
</div>
<p class="pcalibre1 pcalibre calibre7">(Notice "iterator" is a noun, while "iterable" is usually an
adjective. This can help you remember which is which.)</p>
<p class="pcalibre1 pcalibre calibre7">
When implementing your own container type, you probably want to make
it iterable, so you and others can use it in a <code class="pcalibre1 pcalibre literal">for</code> loop. Depending
on the nature of the container, it’s often easiest to implement the
sequence protocol. As an example, consider this simple <code class="pcalibre1 pcalibre literal">UniqueList</code>
type, which is a kind of hybrid between a list and a set:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">class</span> <span class="pcalibre1 pcalibre calibre18">UniqueList</span>:
    <span class="pcalibre1 pcalibre calibre18">def</span> __init__(self, items):
        self.items = []
        <span class="pcalibre1 pcalibre calibre18">for</span> item <span class="pcalibre1 pcalibre calibre18">in</span> items:
            self.append(item)
    <span class="pcalibre1 pcalibre calibre18">def</span> append(self, item):
        <span class="pcalibre1 pcalibre calibre18">if</span> item <span class="pcalibre1 pcalibre calibre18">not</span> <span class="pcalibre1 pcalibre calibre18">in</span> self.items:
            self.items.append(item)
    <span class="pcalibre1 pcalibre calibre18">def</span> __getitem__(self, index):
        <span class="pcalibre1 pcalibre calibre18">return</span> self.items[index]</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Use it like this:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; u = UniqueList([3,7,2,9,3,4,2])
&gt;&gt;&gt; u.items
[3, 7, 2, 9, 4]
&gt;&gt;&gt; u[3]
9
&gt;&gt;&gt; u[42]
Traceback (most recent call last):
  File <span class="pcalibre1 pcalibre calibre13">"&lt;stdin&gt;"</span>, line 1, <span class="pcalibre1 pcalibre calibre18">in</span> &lt;module&gt;
  File <span class="pcalibre1 pcalibre calibre13">"&lt;stdin&gt;"</span>, line 10, <span class="pcalibre1 pcalibre calibre18">in</span> __getitem__
<span class="pcalibre1 pcalibre calibre18">IndexError</span>: list index out of range</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">The <code class="pcalibre1 pcalibre literal">__getitem__</code> method implements square-bracket access;
basically, Python translates <code class="pcalibre1 pcalibre literal">u[3]</code> into <code class="pcalibre1 pcalibre literal">u.__getitem__(3)</code>. We’ve
programmed this object’s square brackets to operate much like a normal
list, in that the initial element is at index 0, and you get
subsequent elements with subsequent integers, not skipping any. And
when you go past the end, it raises <code class="pcalibre1 pcalibre literal">IndexError</code>. If an object has a
<code class="pcalibre1 pcalibre literal">__getitem__</code> method behaving in just this way, <code class="pcalibre1 pcalibre literal">iter()</code> knows how
to create an iterator over it:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">&gt;&gt;&gt; </span>u_iter = iter(u)
<span class="pcalibre1 pcalibre calibre18">&gt;&gt;&gt; </span>type(u_iter)
&lt;class 'iterator'&gt;
<span class="pcalibre1 pcalibre calibre18">&gt;&gt;&gt; for</span> num <span class="pcalibre1 pcalibre calibre18">in</span> u_iter: <span class="pcalibre1 pcalibre calibre18">print</span>(num)
3
7
2
9
4</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Notice we get a lot of this behavior for free, simply because we’re
using an actual list internally (and thus delegating much of the
<code class="pcalibre1 pcalibre literal">__getitem__</code> logic to it). That’s a clue for you, whenever you make
a custom collection that acts like a list - or one of the other
standard collection types. If your object internally stores its data
in one of the standard data types, you’ll often have an easier time
mimicking its behavior.</p>
<p class="pcalibre1 pcalibre calibre7">Implementing the sequence protocol - i.e., writing a <code class="pcalibre1 pcalibre literal">__getitem__</code>
method which acts like a list’s - is one way to make your class
iterable. The other involves writing an <code class="pcalibre1 pcalibre literal">__iter__</code> method. When
called with no arguments, it must return some object which follows the
iterator protocol, described above. In the worst case, you’ll need to
implement something like the <code class="pcalibre1 pcalibre literal">SquaresIterator</code> class from earlier in
this chapter, with its own <code class="pcalibre1 pcalibre literal">__next__</code> and <code class="pcalibre1 pcalibre literal">__iter__</code> methods. But
usually you don’t have to work that hard, because you can simply
return a generator object instead. That means <code class="pcalibre1 pcalibre literal">__iter__</code> is a
generator function itself, or it internally calls some other generator
function, returning its value.</p>
<p class="pcalibre1 pcalibre calibre7">Both iterables and iterators must have an <code class="pcalibre1 pcalibre literal">__iter__</code> method. Both
are called with no argument, and both return an iterator object. The
only difference: the one for the iterator returns its <code class="pcalibre1 pcalibre literal">self</code>, while an
iterable’s will create and return a <em class="pcalibre1 calibre8 pcalibre">new</em> iterator. And if you call it
twice, you get two different iterators.</p>
<p class="pcalibre1 pcalibre calibre7">This similarity is intentional, to simplify control code that can
accept either iterators or iterables.  Here’s the mental model you can
safely follow: when Python’s runtime encounters a <code class="pcalibre1 pcalibre literal">for</code> loop, it will
start by invoking <code class="pcalibre1 pcalibre literal">iter(sequence)</code>. This <em class="pcalibre1 calibre8 pcalibre">always</em> returns an iterator:
either <code class="pcalibre1 pcalibre literal">sequence</code> itself, or (if <code class="pcalibre1 pcalibre literal">sequence</code> is only iterable) the
iterator created by <code class="pcalibre1 pcalibre literal">sequence.__iter__()</code>.</p>
<p class="pcalibre1 pcalibre calibre7">Iterables are everywhere in Python. Almost all built-in collection
types are iterable: <code class="pcalibre1 pcalibre literal">list</code>, <code class="pcalibre1 pcalibre literal">tuple</code>, and <code class="pcalibre1 pcalibre literal">set</code>, and even <code class="pcalibre1 pcalibre literal">dict</code>
(though more often you’ll want to use <code class="pcalibre1 pcalibre literal">dict.items()</code> or
<code class="pcalibre1 pcalibre literal">dict.viewitems()</code>).  In your own custom collection classes, sometimes
the easiest way to implement <code class="pcalibre1 pcalibre literal">__iter__()</code> actually involves using
<code class="pcalibre1 pcalibre literal">iter()</code>. For instance, this will not work:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">class</span> <span class="pcalibre1 pcalibre calibre18">BrokenInLoops</span>:
    <span class="pcalibre1 pcalibre calibre18">def</span> __init__(self):
        self.items = [7, 3, 9]
    <span class="pcalibre1 pcalibre calibre18">def</span> __iter__(self):
        <span class="pcalibre1 pcalibre calibre18">return</span> self.items</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">If you try it, you get a <code class="pcalibre1 pcalibre literal">TypeError</code>:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; items = BrokenInLoops()
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre18">for</span> item <span class="pcalibre1 pcalibre calibre18">in</span> items:
...     <span class="pcalibre1 pcalibre calibre18">print</span>(item)
Traceback (most recent call last):
  File <span class="pcalibre1 pcalibre calibre13">"&lt;stdin&gt;"</span>, line 1, <span class="pcalibre1 pcalibre calibre18">in</span> &lt;module&gt;
<span class="pcalibre1 pcalibre calibre18">TypeError</span>: iter() returned non-iterator of type <span class="pcalibre1 pcalibre calibre13">'list'</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">It doesn’t work because <code class="pcalibre1 pcalibre literal">__iter__()</code> is supposed to return an iterator, but a
list object is <em class="pcalibre1 calibre8 pcalibre">not</em> an iterator; it is simply <em class="pcalibre1 calibre8 pcalibre">iterable</em>. You can fix
this with a one-line change: use <code class="pcalibre1 pcalibre literal">iter()</code> to create an iterator object
inside of <code class="pcalibre1 pcalibre literal">__iter__()</code>, and return that object:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">class</span> <span class="pcalibre1 pcalibre calibre18">WorksInLoops</span>:
    <span class="pcalibre1 pcalibre calibre18">def</span> __init__(self):
        self.items = [7, 3, 9]
    <span class="pcalibre1 pcalibre calibre18">def</span> __iter__(self):
        <span class="pcalibre1 pcalibre calibre13"># This class is identical to BrokenInLoops,</span>
        <span class="pcalibre1 pcalibre calibre13"># except for this next line.</span>
        <span class="pcalibre1 pcalibre calibre18">return</span> iter(self.items)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">This makes <code class="pcalibre1 pcalibre literal">WorksInLoops</code> itself iterable, because <code class="pcalibre1 pcalibre literal">__iter__</code>
returns an actual iterator object - making <code class="pcalibre1 pcalibre literal">WorksInLoops</code> follow the
iterator protocol correctly. That <code class="pcalibre1 pcalibre literal">__iter__</code> method generates a
fresh iterator each time:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; items = WorksInLoops()
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre18">for</span> item <span class="pcalibre1 pcalibre calibre18">in</span> items:
...     <span class="pcalibre1 pcalibre calibre18">print</span>(item)
7
3
9</code></pre>
</figure>
</section>
<footer class="pcalibre1 pcalibre calibre15">
<div class="calibre16 pcalibre1 pcalibre"></div><div class="pcalibre1 pcalibre chapter-footer">
<div class="pcalibre1 pcalibre footnotes">
<aside id="calibre_link-38" type="footnote" class="calibre2 pcalibre1 pcalibre">
<p class="pcalibre1 calibre17 pcalibre"><sup class="noteref1 pcalibre1 pcalibre"><a href="#calibre_link-42" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">1</a></sup> From "Summer Rain", by Amy Lowell. <a class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4" href="https://www.poets.org/poetsorg/poem/summer-rain">https://www.poets.org/poetsorg/poem/summer-rain</a></p>
</aside>
<aside id="calibre_link-39" type="footnote" class="calibre2 pcalibre1 pcalibre">
<p class="pcalibre1 calibre17 pcalibre"><sup class="noteref1 pcalibre1 pcalibre"><a href="#calibre_link-43" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">2</a></sup> <a class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4" href="https://www.python.org/dev/peps/pep-0342/">https://www.python.org/dev/peps/pep-0342/</a> and <a class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4" href="https://www.python.org/dev/peps/pep-0380/">https://www.python.org/dev/peps/pep-0380/</a></p>
</aside>
<aside id="calibre_link-40" type="footnote" class="calibre2 pcalibre1 pcalibre">
<p class="pcalibre1 calibre17 pcalibre"><sup class="noteref1 pcalibre1 pcalibre"><a href="#calibre_link-44" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">3</a></sup> If you’re more interested in Python 2, follow along. Every concept in this section fully applies to Python 2.7, with syntax differences we’ll discuss at the end.</p>
</aside>
<aside id="calibre_link-41" type="footnote" class="calibre2 pcalibre1 pcalibre">
<p class="pcalibre1 calibre17 pcalibre"><sup class="noteref1 pcalibre1 pcalibre"><a href="#calibre_link-45" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">4</a></sup> <code class="pcalibre1 pcalibre literal">2to3</code> will replace both <code class="pcalibre1 pcalibre literal">iteritems()</code> and <code class="pcalibre1 pcalibre literal">viewitems()</code> with <code class="pcalibre1 pcalibre literal">items()</code>; but the precise semantics of the converted program will more closely match your Python 2 code if you use <code class="pcalibre1 pcalibre literal">viewitems()</code> to begin with.</p>
</aside>
</div>
</div>
</footer>
</section>
</div>


<div id="calibre_link-158" class="pcalibre1 pcalibre calibre">
<section class="calibre2 pcalibre1 pcalibre" id="calibre_link-170" title="Creating Collections with Comprehensions" type="chapter">
<header id="calibre_link-72" class="calibre2 pcalibre1 pcalibre">
<div class="pcalibre1 pcalibre chapter-header">
<h1 class="pcalibre1 chapter-title pcalibre"> <small class="subtitle pcalibre1 pcalibre"><b class="pcalibre1 pcalibre calibre6">CREATING</b> <b class="pcalibre1 pcalibre calibre6">COLLECTIONS</b> <b class="pcalibre1 pcalibre calibre6">WITH</b> <b class="pcalibre1 pcalibre calibre6">COMPREHENSIONS</b></small></h1>
</div>
</header>
<p class="pcalibre1 pcalibre calibre7">A <em class="pcalibre1 calibre8 pcalibre">list comprehension</em> is a high level, declarative way to create a
list in Python.  They look like this:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; squares = [ n*n <span class="pcalibre1 pcalibre calibre18">for</span> n <span class="pcalibre1 pcalibre calibre18">in</span> range(6) ]
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre18">print</span>(squares)
[0, 1, 4, 9, 16, 25]</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">This is exactly equivalent to the following:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; squares = []
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre18">for</span> n <span class="pcalibre1 pcalibre calibre18">in</span> range(6):
...     squares.append(n*n)
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre18">print</span>(squares)
[0, 1, 4, 9, 16, 25]</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Notice that in the first example, what you type is declaring <em class="pcalibre1 calibre8 pcalibre">what</em>
kind of list you want, while the second is specifying <em class="pcalibre1 calibre8 pcalibre">how</em> to create
it. That’s why we say it is high-level and declarative: it’s as if you
are stating what kind of list you want created, and then let Python
figure out how to build it.</p>
<p class="pcalibre1 pcalibre calibre7">Python lets you write other kinds of comprehensions other than
lists. Here’s a simple dictionary comprehension, for example:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; blocks = { n: <span class="pcalibre1 pcalibre calibre13">"x"</span> * n <span class="pcalibre1 pcalibre calibre18">for</span> n <span class="pcalibre1 pcalibre calibre18">in</span> range(5) }
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre18">print</span>(blocks)
{0: <span class="pcalibre1 pcalibre calibre13">''</span>, 1: <span class="pcalibre1 pcalibre calibre13">'x'</span>, 2: <span class="pcalibre1 pcalibre calibre13">'xx'</span>, 3: <span class="pcalibre1 pcalibre calibre13">'xxx'</span>, 4: <span class="pcalibre1 pcalibre calibre13">'xxxx'</span>}</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">This is exactly equivalent to the following:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; blocks = dict()
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre18">for</span> n <span class="pcalibre1 pcalibre calibre18">in</span> range(5):
...     blocks[n] = <span class="pcalibre1 pcalibre calibre13">"x"</span> * n
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre18">print</span>(blocks)
{0: <span class="pcalibre1 pcalibre calibre13">''</span>, 1: <span class="pcalibre1 pcalibre calibre13">'x'</span>, 2: <span class="pcalibre1 pcalibre calibre13">'xx'</span>, 3: <span class="pcalibre1 pcalibre calibre13">'xxx'</span>, 4: <span class="pcalibre1 pcalibre calibre13">'xxxx'</span>}</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7"> The main
benefits of comprehensions are readability and maintainability. Most
people find them <em class="pcalibre1 calibre8 pcalibre">very</em> readable; even developers who have never
encountered them before can usually correctly guess what it means. And
there is a deeper, cognitive benefit: once you’ve practiced with them
a bit, you will find you can write them with very little mental effort
- keeping more of your attention free for other tasks.</p>
<p class="pcalibre1 pcalibre calibre7">Beyond lists and dictionaries, there are several other forms of
comprehension you will learn about it in this chapter.  As you become
comfortable with them, you will find them to be versatile and very
Pythonic - meaning, you’ll find they fit well into many other Python
idioms and constructs, lending new expressiveness and elegance to your
code.</p>
<section class="calibre2 pcalibre1 pcalibre" title="List Comprehensions">
<h2 id="calibre_link-73" class="pcalibre1 pcalibre calibre1">List Comprehensions</h2>
<p class="pcalibre1 pcalibre calibre7">
A list comprehension is the most widely used and useful kind of
comprehension, and is essentially a way to create and populate a
list. Its structure looks like:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>[ EXPRESSION <span class="pcalibre1 pcalibre calibre18">for</span> VARIABLE <span class="pcalibre1 pcalibre calibre18">in</span> SEQUENCE ]</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7"><em class="pcalibre1 calibre8 pcalibre">EXPRESSION</em> is any Python expression, though in useful
comprehensions, the expression typically has some variable in it. That
variable is stated in the <em class="pcalibre1 calibre8 pcalibre">VARIABLE</em> field. <em class="pcalibre1 calibre8 pcalibre">SEQUENCE</em> defines the
source values the variable enumerates through, creating the final
sequence of calculated values.</p>
<p class="pcalibre1 pcalibre calibre7">Here’s the simple example we glimpsed earlier:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">&gt;&gt;&gt; </span>squares = [ n*n <span class="pcalibre1 pcalibre calibre18">for</span> n <span class="pcalibre1 pcalibre calibre18">in</span> range(6) ]
<span class="pcalibre1 pcalibre calibre18">&gt;&gt;&gt; </span>type(squares)
&lt;class 'list'&gt;
<span class="pcalibre1 pcalibre calibre18">&gt;&gt;&gt; print</span>(squares)
[0, 1, 4, 9, 16, 25]</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Notice the result is just a regular list. In <code class="pcalibre1 pcalibre literal">squares</code>, the expression
is <code class="pcalibre1 pcalibre literal">n*n</code>; the variable is <code class="pcalibre1 pcalibre literal">n</code>; and the source sequence is <code class="pcalibre1 pcalibre literal">range(6)</code>.
The sequence is a <code class="pcalibre1 pcalibre literal">range</code> object; in fact, it can be any
iterable…​ another list or tuple, a generator object, or something
else.</p>
<p class="pcalibre1 pcalibre calibre7">The expression part can be anything that reduces to a
value:</p>
<div class="pcalibre1 pcalibre itemized-list">
<ul class="pcalibre1 calibre14 pcalibre">
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">Arithmetic expressions like <code class="pcalibre1 pcalibre literal">n+3</code></span>
</li>
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">A function call like <code class="pcalibre1 pcalibre literal">f(m)</code>, using <code class="pcalibre1 pcalibre literal">m</code> as the variable</span>
</li>
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">A slice operation (like <code class="pcalibre1 pcalibre literal">s[::-1]</code>, to reverse a string)</span>
</li>
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">Method calls (<code class="pcalibre1 pcalibre literal">foo.bar()</code>, iterating over a sequence of objects)</span>
</li>
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">And more.</span>
</li>
</ul>
</div>
<p class="pcalibre1 pcalibre calibre7">Some complete examples:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13"># First define some source sequences...</span>
... pets = [<span class="pcalibre1 pcalibre calibre13">"dog"</span>, <span class="pcalibre1 pcalibre calibre13">"parakeet"</span>, <span class="pcalibre1 pcalibre calibre13">"cat"</span>, <span class="pcalibre1 pcalibre calibre13">"llama"</span>]
&gt;&gt;&gt; numbers = [ 9, -1, -4, 20, 11, -3 ]
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13"># And a helper function...</span>
... <span class="pcalibre1 pcalibre calibre18">def</span> repeat(s):
...     <span class="pcalibre1 pcalibre calibre18">return</span> s + s
...
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13"># Now, some list comprehensions:</span>
... [ 2*m+3 <span class="pcalibre1 pcalibre calibre18">for</span> m <span class="pcalibre1 pcalibre calibre18">in</span> range(10, 20, 2) ]
[23, 27, 31, 35, 39]
&gt;&gt;&gt; [ abs(num) <span class="pcalibre1 pcalibre calibre18">for</span> num <span class="pcalibre1 pcalibre calibre18">in</span> numbers ]
[9, 1, 4, 20, 11, 3]
&gt;&gt;&gt; [ 10 - x <span class="pcalibre1 pcalibre calibre18">for</span> x <span class="pcalibre1 pcalibre calibre18">in</span> numbers ]
[1, 11, 14, -10, -1, 13]
&gt;&gt;&gt; [ pet.lower() <span class="pcalibre1 pcalibre calibre18">for</span> pet <span class="pcalibre1 pcalibre calibre18">in</span> pets ]
[<span class="pcalibre1 pcalibre calibre13">'dog'</span>, <span class="pcalibre1 pcalibre calibre13">'parakeet'</span>, <span class="pcalibre1 pcalibre calibre13">'cat'</span>, <span class="pcalibre1 pcalibre calibre13">'llama'</span>]
&gt;&gt;&gt; [ <span class="pcalibre1 pcalibre calibre13">"The "</span> + pet <span class="pcalibre1 pcalibre calibre18">for</span> pet <span class="pcalibre1 pcalibre calibre18">in</span> sorted(pets) ]
[<span class="pcalibre1 pcalibre calibre13">'The cat'</span>, <span class="pcalibre1 pcalibre calibre13">'The dog'</span>, <span class="pcalibre1 pcalibre calibre13">'The llama'</span>, <span class="pcalibre1 pcalibre calibre13">'The parakeet'</span>]
&gt;&gt;&gt; [ repeat(pet) <span class="pcalibre1 pcalibre calibre18">for</span> pet <span class="pcalibre1 pcalibre calibre18">in</span> pets ]
[<span class="pcalibre1 pcalibre calibre13">'dogdog'</span>, <span class="pcalibre1 pcalibre calibre13">'parakeetparakeet'</span>, <span class="pcalibre1 pcalibre calibre13">'catcat'</span>, <span class="pcalibre1 pcalibre calibre13">'llamallama'</span>]</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Notice how all these fit the same structure. They all have the
keywords "for" and "in"; those are required in Python, for any
kind of comprehension you may write. These are interleaved among three
fields: the expression; the variable (i.e., the identifier from which
the expression is composed); and the source sequence.</p>
<p class="pcalibre1 pcalibre calibre7">

The order of elements in the final list is determined by the order of
the source sequence. But you can filter out elements by adding an "if"
clause:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre18">def</span> is_palindrome(s):
...     <span class="pcalibre1 pcalibre calibre18">return</span> s == s[::-1]
...
&gt;&gt;&gt; pets = [<span class="pcalibre1 pcalibre calibre13">"dog"</span>, <span class="pcalibre1 pcalibre calibre13">"parakeet"</span>, <span class="pcalibre1 pcalibre calibre13">"cat"</span>, <span class="pcalibre1 pcalibre calibre13">"llama"</span>]
&gt;&gt;&gt; numbers = [ 9, -1, -4, 20, 11, -3 ]
&gt;&gt;&gt; words = [<span class="pcalibre1 pcalibre calibre13">"bib"</span>, <span class="pcalibre1 pcalibre calibre13">"bias"</span>, <span class="pcalibre1 pcalibre calibre13">"dad"</span>, <span class="pcalibre1 pcalibre calibre13">"eye"</span>, <span class="pcalibre1 pcalibre calibre13">"deed"</span>, <span class="pcalibre1 pcalibre calibre13">"tooth"</span>]
&gt;&gt;&gt;
&gt;&gt;&gt; [ n*2 <span class="pcalibre1 pcalibre calibre18">for</span> n <span class="pcalibre1 pcalibre calibre18">in</span> numbers <span class="pcalibre1 pcalibre calibre18">if</span> n % 2 == 0 ]
[-8, 40]
&gt;&gt;&gt;
&gt;&gt;&gt; [pet.upper() <span class="pcalibre1 pcalibre calibre18">for</span> pet <span class="pcalibre1 pcalibre calibre18">in</span> pets <span class="pcalibre1 pcalibre calibre18">if</span> len(pet) == 3]
[<span class="pcalibre1 pcalibre calibre13">'DOG'</span>, <span class="pcalibre1 pcalibre calibre13">'CAT'</span>]
&gt;&gt;&gt;
&gt;&gt;&gt; [n <span class="pcalibre1 pcalibre calibre18">for</span> n <span class="pcalibre1 pcalibre calibre18">in</span> numbers <span class="pcalibre1 pcalibre calibre18">if</span> n &gt; 0]
[9, 20, 11]
&gt;&gt;&gt;
&gt;&gt;&gt; [word <span class="pcalibre1 pcalibre calibre18">for</span> word <span class="pcalibre1 pcalibre calibre18">in</span> words <span class="pcalibre1 pcalibre calibre18">if</span> is_palindrome(word)]
[<span class="pcalibre1 pcalibre calibre13">'bib'</span>, <span class="pcalibre1 pcalibre calibre13">'dad'</span>, <span class="pcalibre1 pcalibre calibre13">'eye'</span>, <span class="pcalibre1 pcalibre calibre13">'deed'</span>]</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">The structure is</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11">[ EXPR for VAR in SEQUENCE if CONDITION ]</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">where <em class="pcalibre1 calibre8 pcalibre">CONDITION</em> is an expression that evaluates to <code class="pcalibre1 pcalibre literal">True</code> or
<code class="pcalibre1 pcalibre literal">False</code>, depending on the variable.<sup class="pcalibre1 pcalibre noteref">[<a href="#calibre_link-159" id="calibre_link-162" type="noteref" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">1</a>]</sup> Note that it
can be either a function applied to the variable
(<code class="pcalibre1 pcalibre literal">is_palindrome(word)</code>), or something more complex (<code class="pcalibre1 pcalibre literal">len(pet) ==
3</code>). Choosing to use a function can improve readability, and also let
you apply filter logic whose code won’t fit in one line.</p>
<p class="pcalibre1 pcalibre calibre7">A list comprehension must always have the "for" word, even if the
beginning expression is just the variable itself. For example, when we
say:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; [word <span class="pcalibre1 pcalibre calibre18">for</span> word <span class="pcalibre1 pcalibre calibre18">in</span> words <span class="pcalibre1 pcalibre calibre18">if</span> is_palindrome(word)]
[<span class="pcalibre1 pcalibre calibre13">'bib'</span>, <span class="pcalibre1 pcalibre calibre13">'dad'</span>, <span class="pcalibre1 pcalibre calibre13">'eye'</span>, <span class="pcalibre1 pcalibre calibre13">'deed'</span>]</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Sometimes people think <code class="pcalibre1 pcalibre literal">word for word in words</code> seems redundant (it
does), and try to shorten it…​ but that doesn’t work:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; [word <span class="pcalibre1 pcalibre calibre18">in</span> words <span class="pcalibre1 pcalibre calibre18">if</span> is_palindrome(word)]
  File <span class="pcalibre1 pcalibre calibre13">"&lt;stdin&gt;"</span>, line 1
    [word <span class="pcalibre1 pcalibre calibre18">in</span> words <span class="pcalibre1 pcalibre calibre18">if</span> is_palindrome(word)]
                                         ^
<span class="pcalibre1 pcalibre calibre18">SyntaxError</span>: invalid syntax
&gt;&gt;&gt;</code></pre>
</figure>
</section>
<section class="calibre2 pcalibre1 pcalibre" title="Formatting For Readability (And More)">
<h2 id="calibre_link-74" class="pcalibre1 pcalibre calibre1">Formatting For Readability (And More)</h2>
<p class="pcalibre1 pcalibre calibre7">


Realistic list comprehensions tend to be too long to fit nicely on a
single line. And they are composed of distinct logical parts, which
can vary independently as the code evolves. This creates a couple of
inconveniences, which are solved by a very convenient fact: <em class="pcalibre1 calibre8 pcalibre">Python’s
normal rules of whitespace are suspended inside the square
brackets</em>. You can exploit this to make them more readable and
maintainable, splitting them across multiple lines:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">def</span> double_short_words(words):
    <span class="pcalibre1 pcalibre calibre18">return</span> [ word + word
             <span class="pcalibre1 pcalibre calibre18">for</span> word <span class="pcalibre1 pcalibre calibre18">in</span> words
             <span class="pcalibre1 pcalibre calibre18">if</span> len(word) &lt; 5 ]</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Another variation, which some people prefer:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">def</span> double_short_words(words):
    <span class="pcalibre1 pcalibre calibre18">return</span> [
        word + word
        <span class="pcalibre1 pcalibre calibre18">for</span> word <span class="pcalibre1 pcalibre calibre18">in</span> words
        <span class="pcalibre1 pcalibre calibre18">if</span> len(word) &lt; 5
        ]</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">What I’ve done here is split the comprehension across separate
lines. You can, and should, do this with any substantial
comprehension. It’s great for several reasons, the most important
being the instant gain in readability. This comprehension has three
separate ideas expressed inside the square brackets: the expression
(<code class="pcalibre1 pcalibre literal">word + word</code>); the sequence (<code class="pcalibre1 pcalibre literal">for word in words</code>); and the filtering
clause (<code class="pcalibre1 pcalibre literal">if len(word) &lt; 5</code>). These are logically separate aspects, and
by splitting them across different lines, it takes less cognitive
effort for a human to read and understand than the one-line
version. It’s effectively pre-parsed for you, as you read the code.</p>
<p class="pcalibre1 pcalibre calibre7">
There’s another benefit: version control and code review diffs are
more pin-pointed. Imagine you and I are on the same development team,
working on this code base in different feature branches. In my branch,
I change the expression to <code class="pcalibre1 pcalibre literal">"word + word + word"</code>; in yours, you
change the threshold to <code class="pcalibre1 pcalibre literal">"len(word) &lt; 7"</code>. If the comprehension is on
one line, version control tools will perceive this as a merge
conflict, and whoever merges last will have to manually fix
it.<sup class="pcalibre1 pcalibre noteref">[<a href="#calibre_link-160" id="calibre_link-163" type="noteref" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">2</a>]</sup>
But since this list comprehension is split across three lines, our
source control tool can automatically merge both our branches. And if
we’re doing code reviews like we should be, the reviewer can
identify the precise change immediately, without having to scan the
line and think.</p>
</section>
<section class="calibre2 pcalibre1 pcalibre" title="Multiple Sources and Filters">
<h2 id="calibre_link-75" class="pcalibre1 pcalibre calibre1">Multiple Sources and Filters</h2>
<p class="pcalibre1 pcalibre calibre7">
 You
can have several <code class="pcalibre1 pcalibre literal">for VAR in SEQUENCE</code> clauses. This lets you
construct lists based on pairs, triplets, etc., from two or more
source sequences:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; colors = [<span class="pcalibre1 pcalibre calibre13">"orange"</span>, <span class="pcalibre1 pcalibre calibre13">"purple"</span>, <span class="pcalibre1 pcalibre calibre13">"pink"</span>]
&gt;&gt;&gt; toys = [<span class="pcalibre1 pcalibre calibre13">"bike"</span>, <span class="pcalibre1 pcalibre calibre13">"basketball"</span>, <span class="pcalibre1 pcalibre calibre13">"skateboard"</span>, <span class="pcalibre1 pcalibre calibre13">"doll"</span>]
&gt;&gt;&gt;
&gt;&gt;&gt; [ color + <span class="pcalibre1 pcalibre calibre13">" "</span> + toy
...   <span class="pcalibre1 pcalibre calibre18">for</span> color <span class="pcalibre1 pcalibre calibre18">in</span> colors
...   <span class="pcalibre1 pcalibre calibre18">for</span> toy <span class="pcalibre1 pcalibre calibre18">in</span> toys ]
[<span class="pcalibre1 pcalibre calibre13">'orange bike'</span>, <span class="pcalibre1 pcalibre calibre13">'orange basketball'</span>, <span class="pcalibre1 pcalibre calibre13">'orange skateboard'</span>,
 <span class="pcalibre1 pcalibre calibre13">'orange doll'</span>, <span class="pcalibre1 pcalibre calibre13">'purple bike'</span>, <span class="pcalibre1 pcalibre calibre13">'purple basketball'</span>,
 <span class="pcalibre1 pcalibre calibre13">'purple skateboard'</span>, <span class="pcalibre1 pcalibre calibre13">'purple doll'</span>, <span class="pcalibre1 pcalibre calibre13">'pink bike'</span>,
 <span class="pcalibre1 pcalibre calibre13">'pink basketball'</span>, <span class="pcalibre1 pcalibre calibre13">'pink skateboard'</span>, <span class="pcalibre1 pcalibre calibre13">'pink doll'</span>]</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Every pair from the two sources, <code class="pcalibre1 pcalibre literal">colors</code> and <code class="pcalibre1 pcalibre literal">toys</code>, is used to
calculate a value in the final list. That final list has 12 elements,
the product of the lengths of the two source lists.</p>
<p class="pcalibre1 pcalibre calibre7">I want you to notice that the two <code class="pcalibre1 pcalibre literal">for</code> clauses are independent of
each other; <code class="pcalibre1 pcalibre literal">colors</code> and <code class="pcalibre1 pcalibre literal">toys</code> are two unrelated lists. Using
multiple <code class="pcalibre1 pcalibre literal">for</code> clauses can sometimes take a different form, where they
are more interdependent. Consider this example:

</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; ranges = [range(1,7), range(4,12,3), range(-5,9,4)]
&gt;&gt;&gt; [ float(num)
...   <span class="pcalibre1 pcalibre calibre18">for</span> subrange <span class="pcalibre1 pcalibre calibre18">in</span> ranges
...   <span class="pcalibre1 pcalibre calibre18">for</span> num <span class="pcalibre1 pcalibre calibre18">in</span> subrange ]
[1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 4.0, 7.0, 10.0, -5.0,
-1.0, 3.0, 7.0]</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">The source sequence - <code class="pcalibre1 pcalibre literal">"ranges"</code> - is a list of range
objects.<sup class="pcalibre1 pcalibre noteref">[<a href="#calibre_link-161" id="calibre_link-164" type="noteref" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">3</a>]</sup>   Now, this list
comprehension has two <code class="pcalibre1 pcalibre literal">for</code> clauses again. But notice one depends on
the other. The source of the second is the variable for the first!</p>
<p class="pcalibre1 pcalibre calibre7">It’s not like the colorful-toys example, whose <code class="pcalibre1 pcalibre literal">for</code> clauses are
independent of each other.  When chained together this way, order
matters:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; [ float(num)
...   <span class="pcalibre1 pcalibre calibre18">for</span> num <span class="pcalibre1 pcalibre calibre18">in</span> subrange
...   <span class="pcalibre1 pcalibre calibre18">for</span> subrange <span class="pcalibre1 pcalibre calibre18">in</span> ranges ]
Traceback (most recent call last):
  File <span class="pcalibre1 pcalibre calibre13">"&lt;stdin&gt;"</span>, line 2, <span class="pcalibre1 pcalibre calibre18">in</span> &lt;module&gt;
<span class="pcalibre1 pcalibre calibre18">NameError</span>: name <span class="pcalibre1 pcalibre calibre13">'subrange'</span> <span class="pcalibre1 pcalibre calibre18">is</span> <span class="pcalibre1 pcalibre calibre18">not</span> defined</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Python parses the list comprehension from left to right. If the first
clause is <code class="pcalibre1 pcalibre literal">for num in subrange</code>, at that point <code class="pcalibre1 pcalibre literal">subrange</code> is not
defined. So you have to put <code class="pcalibre1 pcalibre literal">for subrange in ranges</code> <em class="pcalibre1 calibre8 pcalibre">first</em>. You can
chain more than two <code class="pcalibre1 pcalibre literal">for</code> clauses together like this; the first one
will just need to reference a previously-defined source, and the
others can use sources defined in the previous <code class="pcalibre1 pcalibre literal">for</code> clause, like
<code class="pcalibre1 pcalibre literal">subrange</code> is defined.</p>
<p class="pcalibre1 pcalibre calibre7">Now, that’s for chained <code class="pcalibre1 pcalibre literal">for</code> clauses. If the clauses are independent,
does the order matter at all? It does, just in a different way. What’s
the difference between these two list comprehensions:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; colors = [<span class="pcalibre1 pcalibre calibre13">"orange"</span>, <span class="pcalibre1 pcalibre calibre13">"purple"</span>, <span class="pcalibre1 pcalibre calibre13">"pink"</span>]
&gt;&gt;&gt; toys = [<span class="pcalibre1 pcalibre calibre13">"bike"</span>, <span class="pcalibre1 pcalibre calibre13">"basketball"</span>, <span class="pcalibre1 pcalibre calibre13">"skateboard"</span>, <span class="pcalibre1 pcalibre calibre13">"doll"</span>]
&gt;&gt;&gt;
&gt;&gt;&gt; [ color + <span class="pcalibre1 pcalibre calibre13">" "</span> + toy
...   <span class="pcalibre1 pcalibre calibre18">for</span> color <span class="pcalibre1 pcalibre calibre18">in</span> colors
...   <span class="pcalibre1 pcalibre calibre18">for</span> toy <span class="pcalibre1 pcalibre calibre18">in</span> toys ]
[<span class="pcalibre1 pcalibre calibre13">'orange bike'</span>, <span class="pcalibre1 pcalibre calibre13">'orange basketball'</span>, <span class="pcalibre1 pcalibre calibre13">'orange skateboard'</span>,
<span class="pcalibre1 pcalibre calibre13">'orange doll'</span>, <span class="pcalibre1 pcalibre calibre13">'purple bike'</span>, <span class="pcalibre1 pcalibre calibre13">'purple basketball'</span>,
<span class="pcalibre1 pcalibre calibre13">'purple skateboard'</span>, <span class="pcalibre1 pcalibre calibre13">'purple doll'</span>, <span class="pcalibre1 pcalibre calibre13">'pink bike'</span>,
<span class="pcalibre1 pcalibre calibre13">'pink basketball'</span>, <span class="pcalibre1 pcalibre calibre13">'pink skateboard'</span>, <span class="pcalibre1 pcalibre calibre13">'pink doll'</span>]
&gt;&gt;&gt;
&gt;&gt;&gt; [ color + <span class="pcalibre1 pcalibre calibre13">" "</span> + toy
...   <span class="pcalibre1 pcalibre calibre18">for</span> toy <span class="pcalibre1 pcalibre calibre18">in</span> toys
...   <span class="pcalibre1 pcalibre calibre18">for</span> color <span class="pcalibre1 pcalibre calibre18">in</span> colors ]
[<span class="pcalibre1 pcalibre calibre13">'orange bike'</span>, <span class="pcalibre1 pcalibre calibre13">'purple bike'</span>, <span class="pcalibre1 pcalibre calibre13">'pink bike'</span>, <span class="pcalibre1 pcalibre calibre13">'orange</span>
basketball<span class="pcalibre1 pcalibre calibre13">', '</span>purple basketball<span class="pcalibre1 pcalibre calibre13">', '</span>pink basketball<span class="pcalibre1 pcalibre calibre13">',</span>
<span class="pcalibre1 pcalibre calibre13">'orange skateboard'</span>, <span class="pcalibre1 pcalibre calibre13">'purple skateboard'</span>, <span class="pcalibre1 pcalibre calibre13">'pink</span>
skateboard<span class="pcalibre1 pcalibre calibre13">', '</span>orange doll<span class="pcalibre1 pcalibre calibre13">', '</span>purple doll<span class="pcalibre1 pcalibre calibre13">', '</span>pink doll<span class="pcalibre1 pcalibre calibre13">']</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">The order here doesn’t matter in the sense it does for chained <code class="pcalibre1 pcalibre literal">for</code>
clauses, where you <em class="pcalibre1 calibre8 pcalibre">must</em> put things in a certain order, or your
program won’t run. Here, you have a choice. And that choice <em class="pcalibre1 calibre8 pcalibre">does</em>
effect the order of elements in the final comprehension. The first
element in each is "orange bike". And notice the second element is
different. Think a moment, and ask yourself: why? Why is the first
element the same in both comprehensions? And why is it only the
<em class="pcalibre1 calibre8 pcalibre">second</em> element that’s different?</p>
<p class="pcalibre1 pcalibre calibre7">It has to do with which sequence is held constant while the other
varies. It’s the same logic that applies when nesting regular <code class="pcalibre1 pcalibre literal">for</code>
loops:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13"># Nested one way...</span>
... build_colors_toys = []
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre18">for</span> color <span class="pcalibre1 pcalibre calibre18">in</span> colors:
...     <span class="pcalibre1 pcalibre calibre18">for</span> toy <span class="pcalibre1 pcalibre calibre18">in</span> toys:
...         build_colors_toys.append(color + <span class="pcalibre1 pcalibre calibre13">" "</span> + toy)
&gt;&gt;&gt; build_colors_toys[0]
<span class="pcalibre1 pcalibre calibre13">'orange bike'</span>
&gt;&gt;&gt; build_colors_toys[1]
<span class="pcalibre1 pcalibre calibre13">'orange basketball'</span>
&gt;&gt;&gt;
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13"># And nested the other way.</span>
... build_toys_colors = []
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre18">for</span> toy <span class="pcalibre1 pcalibre calibre18">in</span> toys:
...     <span class="pcalibre1 pcalibre calibre18">for</span> color <span class="pcalibre1 pcalibre calibre18">in</span> colors:
...         build_toys_colors.append(color + <span class="pcalibre1 pcalibre calibre13">" "</span> + toy)
&gt;&gt;&gt; build_toys_colors[0]
<span class="pcalibre1 pcalibre calibre13">'orange bike'</span>
&gt;&gt;&gt; build_toys_colors[1]
<span class="pcalibre1 pcalibre calibre13">'purple bike'</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">The second <code class="pcalibre1 pcalibre literal">for</code> clause in the list comprehension corresponds to the
innermost <code class="pcalibre1 pcalibre literal">for</code> loop. Its values vary through their range more rapidly
than the outer one.</p>
<p class="pcalibre1 pcalibre calibre7">In addition to using many <code class="pcalibre1 pcalibre literal">for</code> clauses, you can have more than one
<code class="pcalibre1 pcalibre literal">if</code> clause, for multiple levels of filtering. Just write several of
them in sequence:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; numbers = [ 9, -1, -4, 20, 17, -3 ]
&gt;&gt;&gt; odd_positives = [
...     num <span class="pcalibre1 pcalibre calibre18">for</span> num <span class="pcalibre1 pcalibre calibre18">in</span> numbers
...     <span class="pcalibre1 pcalibre calibre18">if</span> num &gt; 0
...     <span class="pcalibre1 pcalibre calibre18">if</span> num % 2 == 1
... ]
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre18">print</span>(odd_positives)
[9, 17]</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">

Here, I’ve placed each <code class="pcalibre1 pcalibre literal">if</code> clause on its own line, for readability -
but I could have put both on one line. When you have
more than one <code class="pcalibre1 pcalibre literal">if</code> clause, each element must meet the criteria of
<em class="pcalibre1 calibre8 pcalibre">all</em> of them to make it into the final list. In other words, <code class="pcalibre1 pcalibre literal">if</code>
clauses are "and-ed" together, not "or-ed" together.</p>
<p class="pcalibre1 pcalibre calibre7">What if you want to do "or" - to include elements matching at least
one of the <code class="pcalibre1 pcalibre literal">if</code> clause criteria, omitting only those not matching
either? List comprehensions don’t allow you do to that directly. The
comprehension mini-language is not as expressive as Python itself, and
there are lists you might need to construct which cannot be expressed
as a comprehension.</p>
<p class="pcalibre1 pcalibre calibre7">But sometimes you can cheat a bit by defining helper functions. For
example, here’s how you can filter based on whether the number is a
multiple of 2 <strong class="pcalibre1 pcalibre calibre9">or</strong> 3:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; numbers = [ 9, -1, -4, 20, 11, -3 ]
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre18">def</span> is_mult_of_2_or_3(num):
...     <span class="pcalibre1 pcalibre calibre18">return</span> (num % 2 == 0) <span class="pcalibre1 pcalibre calibre18">or</span> (num % 3 == 0)
...
&gt;&gt;&gt; [
...     num <span class="pcalibre1 pcalibre calibre18">for</span> num <span class="pcalibre1 pcalibre calibre18">in</span> numbers
...     <span class="pcalibre1 pcalibre calibre18">if</span> is_mult_of_2_or_3(num)
... ]
[9, -4, 20, -3]</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">We discuss this more in the "Limitations" section, later in the chapter.</p>
<p class="pcalibre1 pcalibre calibre7">You can use multiple <code class="pcalibre1 pcalibre literal">for</code> and <code class="pcalibre1 pcalibre literal">if</code> clauses together:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; weights = [0.2, 0.5, 0.9]
&gt;&gt;&gt; values = [27.5, 13.4]
&gt;&gt;&gt; offsets = [4.3, 7.1, 9.5]
&gt;&gt;&gt;
&gt;&gt;&gt; [ (weight, value, offset)
...   <span class="pcalibre1 pcalibre calibre18">for</span> weight <span class="pcalibre1 pcalibre calibre18">in</span> weights
...   <span class="pcalibre1 pcalibre calibre18">for</span> value <span class="pcalibre1 pcalibre calibre18">in</span> values
...   <span class="pcalibre1 pcalibre calibre18">for</span> offset <span class="pcalibre1 pcalibre calibre18">in</span> offsets
...   <span class="pcalibre1 pcalibre calibre18">if</span> offset &gt; 5.0
...   <span class="pcalibre1 pcalibre calibre18">if</span> weight * value &lt; offset ]
[(0.2, 27.5, 7.1), (0.2, 27.5, 9.5), (0.2, 13.4, 7.1),
(0.2, 13.4, 9.5), (0.5, 13.4, 7.1), (0.5, 13.4, 9.5)]</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">The only rule is that the first <code class="pcalibre1 pcalibre literal">for</code> clause must come before the
first <code class="pcalibre1 pcalibre literal">if</code> clause. Other than that, you can interleave <code class="pcalibre1 pcalibre literal">for</code> and <code class="pcalibre1 pcalibre literal">if</code>
clauses in any order, though most people seem to find it more readable
to group all the <code class="pcalibre1 pcalibre literal">for</code> clauses together at first, then the <code class="pcalibre1 pcalibre literal">if</code>
clauses together at the end.</p>
</section>
<section class="calibre2 pcalibre1 pcalibre" title="Comprehensions and Generators">
<h2 id="calibre_link-76" class="pcalibre1 pcalibre calibre1">Comprehensions and Generators</h2>
<p class="pcalibre1 pcalibre calibre7">

List comprehensions create lists:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">&gt;&gt;&gt; </span>squares = [ n*n <span class="pcalibre1 pcalibre calibre18">for</span> n <span class="pcalibre1 pcalibre calibre18">in</span> range(6) ]
<span class="pcalibre1 pcalibre calibre18">&gt;&gt;&gt; </span>type(squares)
&lt;class 'list'&gt;</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">When you need a list, that’s great, but sometimes you don’t <em class="pcalibre1 calibre8 pcalibre">need</em> a
list, and you’d prefer something more scalable. It’s like the
situation near the start of the generators chapter:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre13"># This again.</span>
NUM_SQUARES = 10*1000*1000
many_squares = [ n*n <span class="pcalibre1 pcalibre calibre18">for</span> n <span class="pcalibre1 pcalibre calibre18">in</span> range(NUM_SQUARES) ]
<span class="pcalibre1 pcalibre calibre18">for</span> number <span class="pcalibre1 pcalibre calibre18">in</span> many_squares:
    do_something_with(number)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">The entire <code class="pcalibre1 pcalibre literal">many_squares</code> list must be fully created - all memory for
it must be allocated, and every element calculated - before
<code class="pcalibre1 pcalibre literal">do_something_with</code> is called even <em class="pcalibre1 calibre8 pcalibre">once</em>. And memory usage goes
through the roof.</p>
<p class="pcalibre1 pcalibre calibre7">You know one solution: write a generator function, and call it. But
there’s an easier option: write a <em class="pcalibre1 calibre8 pcalibre">generator expression</em>. This is the
official name for it, but it really should be called a "generator
comprehension". Syntactically, it looks just like a list comprehension
- except you use parentheses instead of square brackets:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">&gt;&gt;&gt; </span>generated_squares = ( n*n <span class="pcalibre1 pcalibre calibre18">for</span> n <span class="pcalibre1 pcalibre calibre18">in</span> range(NUM_SQUARES) )
<span class="pcalibre1 pcalibre calibre18">&gt;&gt;&gt; </span>type(generated_squares)
&lt;class 'generator'&gt;</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">This "generator expression" creates a <em class="pcalibre1 calibre8 pcalibre">generator object</em>, in the exact
same way a list comprehension creates a list. Any list comprehension
you can write, you can use to create an equivalent generator object,
just by swapping <code class="pcalibre1 pcalibre literal">"("</code> and <code class="pcalibre1 pcalibre literal">")"</code> for <code class="pcalibre1 pcalibre literal">"["</code> and <code class="pcalibre1 pcalibre literal">"]"</code>.</p>
<p class="pcalibre1 pcalibre calibre7">And you’re creating the object directly, without having to define a
generator function to call. In other words, a generator expression is
a convenient shortcut when you need a quick generator object:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre13"># This...</span>
many_squares = ( n*n <span class="pcalibre1 pcalibre calibre18">for</span> n <span class="pcalibre1 pcalibre calibre18">in</span> range(NUM_SQUARES) )

<span class="pcalibre1 pcalibre calibre13"># ... is EXACTLY EQUIVALENT to this:</span>
<span class="pcalibre1 pcalibre calibre18">def</span> gen_many_squares(limit):
    <span class="pcalibre1 pcalibre calibre18">for</span> n <span class="pcalibre1 pcalibre calibre18">in</span> range(limit):
        <span class="pcalibre1 pcalibre calibre18">yield</span> n * n
many_squares = gen_many_squares(NUM_SQUARES)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">As far as Python is concerned, there is no difference.</p>
<p class="pcalibre1 pcalibre calibre7">

</p>
<p class="pcalibre1 pcalibre calibre7">Everything you know about list comprehensions applies to generator
expressions: multiple <code class="pcalibre1 pcalibre literal">for</code> clauses, <code class="pcalibre1 pcalibre literal">if</code> clauses, etc. You only need
to type the parentheses.</p>
<p class="pcalibre1 pcalibre calibre7">In fact, sometimes you can even omit them. When passing a generator
expression as an argument to a function, you will sometimes find
yourself typing <code class="pcalibre1 pcalibre literal">"(("</code> followed by <code class="pcalibre1 pcalibre literal">"))"</code>. In that situation, Python
lets you omit the inner pair. Imagine, for example, you are sorting a
list of customer email addresses, looking at only those customers
whose status is "active":</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13"># User is a class with "email" and "is_active" fields.</span>
... <span class="pcalibre1 pcalibre calibre13"># all_users is a list of User objects.</span>

&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13"># Sorted list of active user's email addresses.</span>
... <span class="pcalibre1 pcalibre calibre13"># Passing in a generator expression.</span>
&gt;&gt;&gt; sorted((user.email <span class="pcalibre1 pcalibre calibre18">for</span> user <span class="pcalibre1 pcalibre calibre18">in</span> all_users
...          <span class="pcalibre1 pcalibre calibre18">if</span> user.is_active))
[<span class="pcalibre1 pcalibre calibre13">'fred@a.com'</span>, <span class="pcalibre1 pcalibre calibre13">'sandy@f.net'</span>, <span class="pcalibre1 pcalibre calibre13">'tim@d.com'</span>]
&gt;&gt;&gt;
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13"># Omitting the inner parentheses.</span>
... <span class="pcalibre1 pcalibre calibre13"># Still passing in a generator expression!</span>
&gt;&gt;&gt; sorted(user.email <span class="pcalibre1 pcalibre calibre18">for</span> user <span class="pcalibre1 pcalibre calibre18">in</span> all_users
...        <span class="pcalibre1 pcalibre calibre18">if</span> user.is_active)
[<span class="pcalibre1 pcalibre calibre13">'fred@a.com'</span>, <span class="pcalibre1 pcalibre calibre13">'sandy@f.net'</span>, <span class="pcalibre1 pcalibre calibre13">'tim@d.com'</span>]</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Notice how readable and natural this is (or will be, once you’ve
practiced a bit). One thing to watch out for: you can only inline a
generator expression this way when passed to a function or method of
one argument. Otherwise, you get a syntax error:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt;
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13"># Reverse that list. Whoops...</span>
... sorted(user.email <span class="pcalibre1 pcalibre calibre18">for</span> user <span class="pcalibre1 pcalibre calibre18">in</span> all_users
...         <span class="pcalibre1 pcalibre calibre18">if</span> user.is_active, reverse=True)
  File <span class="pcalibre1 pcalibre calibre13">"&lt;stdin&gt;"</span>, line 2
<span class="pcalibre1 pcalibre calibre18">SyntaxError</span>: Generator expression must be parenthesized <span class="pcalibre1 pcalibre calibre18">if</span> <span class="pcalibre1 pcalibre calibre18">not</span> sole argument</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Python can’t unambiguously interpret what you mean here, so you must
use the inner parentheses:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13"># Okay, THIS will get the reversed list.</span>
... sorted((user.email <span class="pcalibre1 pcalibre calibre18">for</span> user <span class="pcalibre1 pcalibre calibre18">in</span> all_users
...         <span class="pcalibre1 pcalibre calibre18">if</span> user.is_active), reverse=True)
[<span class="pcalibre1 pcalibre calibre13">'tim@d.com'</span>, <span class="pcalibre1 pcalibre calibre13">'sandy@f.net'</span>, <span class="pcalibre1 pcalibre calibre13">'fred@a.com'</span>]</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">And of course, sometimes it’s more readable to assign the generator
expression to a variable:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; active_emails = (
...        user.email <span class="pcalibre1 pcalibre calibre18">for</span> user <span class="pcalibre1 pcalibre calibre18">in</span> all_users
...        <span class="pcalibre1 pcalibre calibre18">if</span> user.is_active
... )

&gt;&gt;&gt; sorted(active_emails, reverse=True)
[<span class="pcalibre1 pcalibre calibre13">'tim@d.com'</span>, <span class="pcalibre1 pcalibre calibre13">'sandy@f.net'</span>, <span class="pcalibre1 pcalibre calibre13">'fred@a.com'</span>]</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Generator expressions without parentheses suggest a unified way of
thinking about comprehensions, which link generator expressions and
list comprehensions together. Here’s a generator expression for a
sequence of squares:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>( n**2 <span class="pcalibre1 pcalibre calibre18">for</span> n <span class="pcalibre1 pcalibre calibre18">in</span> range(10) )</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">And here it is again, passed to the built-in <code class="pcalibre1 pcalibre literal">list()</code> function:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>list( n**2 <span class="pcalibre1 pcalibre calibre18">for</span> n <span class="pcalibre1 pcalibre calibre18">in</span> range(10) )</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">And here it is as a list comprehension:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>[ n**2 <span class="pcalibre1 pcalibre calibre18">for</span> n <span class="pcalibre1 pcalibre calibre18">in</span> range(10) ]</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">When you understand generator expressions, it’s easy to see list
comprehensions as a derivative data structure. And the same applies
for dictionary and set comprehensions (covered next). With this
insight, you start seeing new opportunities to use all of them in your
own code, improving its readability, maintainability, and performance
in the process.</p>
<section class="calibre2 pcalibre1 pcalibre" title="Generator Expression or List Comprehension?">
<h3 id="calibre_link-171" class="pcalibre1 calibre21 pcalibre">Generator Expression or List Comprehension?</h3>
<p class="pcalibre1 pcalibre calibre7">  If
generator expressions are so great, why would you use list
comprehensions? Generally speaking, when deciding which to use, your
code will be more scalable and responsive if you use a generator
expression. Except, of course, when you actually need a list. There
are several considerations.</p>
<p class="pcalibre1 pcalibre calibre7">First, if the sequence is unlikely to be very big - and by big, I mean
a minimum of thousands of elements long - you probably won’t benefit
from using a generator expression. That’s just not big enough for
scalability to matter. They’re also immutable. If you need random
access, or to go through the sequence twice, or you might need to
append or remove elements, generator expressions won’t work.</p>
<p class="pcalibre1 pcalibre calibre7">This is especially important when writing methods or functions whose
return value is a sequence. Do you return a generator expression, or a
list comprehension? In theory, there’s no reason to ever return a list
instead of a generator object; a list can be trivially created by
passing it to <code class="pcalibre1 pcalibre literal">list()</code>. In practice, the interface may be such that
the caller will really want an actual list. Also, if you are
constructing the return value as a list within the function, it’s
silly to return a generator expression over it - just return the
actual list.</p>
<p class="pcalibre1 pcalibre calibre7">And if your intention is to create a library usable by people who may
not be advanced Pythonistas, that can be an argument for returning
lists. Almost all programmers are familiar with list-like data
structures. But fewer are familiar with how generators work in Python,
and may - quite reasonably - get confused when confronted with a
generator object.</p>
</section>
</section>
<section class="calibre2 pcalibre1 pcalibre" title="Dictionaries, Sets, and Tuples">
<h2 id="calibre_link-77" class="pcalibre1 pcalibre calibre1">Dictionaries, Sets, and Tuples</h2>
<p class="pcalibre1 pcalibre calibre7">Just like a list comprehension creates a list, a dictionary
comprehension creates a dictionary. You saw an example at the
beginning of this chapter; here’s another. Suppose you have this
<code class="pcalibre1 pcalibre literal">Student</code> class:
</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">class</span> <span class="pcalibre1 pcalibre calibre18">Student</span>:
    <span class="pcalibre1 pcalibre calibre18">def</span> __init__(self, name, gpa, major):
        self.name = name
        self.gpa = gpa
        self.major = major</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Given a list <code class="pcalibre1 pcalibre literal">students</code> of student objects, we can write a dictionary
comprehension mapping student names to their GPAs:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; { student.name: student.gpa <span class="pcalibre1 pcalibre calibre18">for</span> student <span class="pcalibre1 pcalibre calibre18">in</span> students }
{<span class="pcalibre1 pcalibre calibre13">'Jim Smith'</span>: 3.6, <span class="pcalibre1 pcalibre calibre13">'Ryan Spencer'</span>: 3.1,
 <span class="pcalibre1 pcalibre calibre13">'Penny Gilmore'</span>: 3.9, <span class="pcalibre1 pcalibre calibre13">'Alisha Jones'</span>: 2.5,
 <span class="pcalibre1 pcalibre calibre13">'Todd Reynolds'</span>: 3.4}</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">The syntax differs from that of list comprehensions in two
ways. Instead of square brackets, you’re using curly brackets - which
makes sense, since this creates a dictionary. The other difference is
the expression field, whose format is <code class="pcalibre1 pcalibre literal">"key: value"</code>, since a <code class="pcalibre1 pcalibre literal">dict</code> has
key-value pairs. So the structure is</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>{ KEY : VALUE <span class="pcalibre1 pcalibre calibre18">for</span> VARIABLE <span class="pcalibre1 pcalibre calibre18">in</span> SEQUENCE }</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">These are the only differences. <em class="pcalibre1 calibre8 pcalibre">Everything</em> else you learned about
list comprehensions applies, including filtering with <code class="pcalibre1 pcalibre literal">if</code> clauses:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre18">def</span> invert_name(name):
...     first, last = name.split(<span class="pcalibre1 pcalibre calibre13">" "</span>, 1)
...     <span class="pcalibre1 pcalibre calibre18">return</span> last + <span class="pcalibre1 pcalibre calibre13">", "</span> + first
...
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13"># Get "lastname, firstname" of high-GPA students.</span>
... { invert_name(student.name): student.gpa
...   <span class="pcalibre1 pcalibre calibre18">for</span> student <span class="pcalibre1 pcalibre calibre18">in</span> students
...   <span class="pcalibre1 pcalibre calibre18">if</span> student.gpa &gt; 3.5 }
{<span class="pcalibre1 pcalibre calibre13">'Smith, Jim'</span>: 3.6, <span class="pcalibre1 pcalibre calibre13">'Gilmore, Penny'</span>: 3.9}</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">You can create sets too. Set comprehensions look exactly like a list
comprehension, but with curly braces instead of square brackets:
</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13"># A list of student majors...</span>
... [ student.major <span class="pcalibre1 pcalibre calibre18">for</span> student <span class="pcalibre1 pcalibre calibre18">in</span> students ]
[<span class="pcalibre1 pcalibre calibre13">'Computer Science'</span>, <span class="pcalibre1 pcalibre calibre13">'Economics'</span>, <span class="pcalibre1 pcalibre calibre13">'Computer Science'</span>,
 <span class="pcalibre1 pcalibre calibre13">'Economics'</span>, <span class="pcalibre1 pcalibre calibre13">'Basket Weaving'</span>]
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13"># And the same as a set:</span>
... { student.major <span class="pcalibre1 pcalibre calibre18">for</span> student <span class="pcalibre1 pcalibre calibre18">in</span> students }
{<span class="pcalibre1 pcalibre calibre13">'Economics'</span>, <span class="pcalibre1 pcalibre calibre13">'Computer Science'</span>, <span class="pcalibre1 pcalibre calibre13">'Basket Weaving'</span>}
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13"># You can also use the set() built-in.</span>
... set(student.major <span class="pcalibre1 pcalibre calibre18">for</span> student <span class="pcalibre1 pcalibre calibre18">in</span> students)
{<span class="pcalibre1 pcalibre calibre13">'Economics'</span>, <span class="pcalibre1 pcalibre calibre13">'Computer Science'</span>, <span class="pcalibre1 pcalibre calibre13">'Basket Weaving'</span>}</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">(How does Python distinguish between a set and dict comprehension?
Because the <code class="pcalibre1 pcalibre literal">dict</code>​'s expression is a key-value pair, while a
<code class="pcalibre1 pcalibre literal">set</code>​'s has a single value.)</p>
<p class="pcalibre1 pcalibre calibre7">
What about tuple comprehensions? This is fun: strictly speaking,
Python doesn’t support them. However, you can pretend it does by using
<code class="pcalibre1 pcalibre literal">tuple()</code>:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; tuple(student.gpa <span class="pcalibre1 pcalibre calibre18">for</span> student <span class="pcalibre1 pcalibre calibre18">in</span> students
...       <span class="pcalibre1 pcalibre calibre18">if</span> student.major == <span class="pcalibre1 pcalibre calibre13">"Computer Science"</span>)
(3.6, 2.5)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">This creates a tuple, <em class="pcalibre1 calibre8 pcalibre">but it’s not a tuple comprehension</em>. You’re
calling the <code class="pcalibre1 pcalibre literal">tuple</code> constructor, and passing it a single
argument. What’s that argument? A generator expression! In other
words, you’re doing this:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">&gt;&gt;&gt; </span>cs_students = (
<span class="pcalibre1 pcalibre calibre18">... </span>    student.gpa <span class="pcalibre1 pcalibre calibre18">for</span> student <span class="pcalibre1 pcalibre calibre18">in</span> students
<span class="pcalibre1 pcalibre calibre18">... </span>    <span class="pcalibre1 pcalibre calibre18">if</span> student.major == <span class="pcalibre1 pcalibre calibre13">"Computer Science"</span>
<span class="pcalibre1 pcalibre calibre18">... </span>    )
<span class="pcalibre1 pcalibre calibre18">&gt;&gt;&gt; </span>type(cs_students)
&lt;class 'generator'&gt;
<span class="pcalibre1 pcalibre calibre18">&gt;&gt;&gt; </span>tuple(cs_students)
(3.6, 2.5)
&gt;&gt;&gt;
<span class="pcalibre1 pcalibre calibre18">&gt;&gt;&gt; </span><span class="pcalibre1 pcalibre calibre13"># Same as:</span>
<span class="pcalibre1 pcalibre calibre18">... </span>tuple((student.gpa <span class="pcalibre1 pcalibre calibre18">for</span> student <span class="pcalibre1 pcalibre calibre18">in</span> students
<span class="pcalibre1 pcalibre calibre18">... </span>       <span class="pcalibre1 pcalibre calibre18">if</span> student.major == <span class="pcalibre1 pcalibre calibre13">"Computer Science"</span>))
(3.6, 2.5)
<span class="pcalibre1 pcalibre calibre18">&gt;&gt;&gt; </span><span class="pcalibre1 pcalibre calibre13"># But you can omit the inner parentheses.</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7"><code class="pcalibre1 pcalibre literal">tuple</code>​'s constructor takes an iterator as an argument. The
<code class="pcalibre1 pcalibre literal">cs_students</code> is a generator object (created by the generator
expression), and a generator object is an iterator. So you can
<em class="pcalibre1 calibre8 pcalibre">pretend</em> like Python has tuple comprehensions, using <code class="pcalibre1 pcalibre literal">"tuple("</code> as the
opener and <code class="pcalibre1 pcalibre literal">")"</code> as the close. In fact, this also gives you alternate
ways to create dictionary and set comprehensions:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13"># Same as:</span>
... <span class="pcalibre1 pcalibre calibre13"># { student.name: student.gpa for student in students }</span>
&gt;&gt;&gt; dict((student.name, student.gpa)
...      <span class="pcalibre1 pcalibre calibre18">for</span> student <span class="pcalibre1 pcalibre calibre18">in</span> students)
{<span class="pcalibre1 pcalibre calibre13">'Jim Smith'</span>: 3.6, <span class="pcalibre1 pcalibre calibre13">'Penny Gilmore'</span>: 3.9,
 <span class="pcalibre1 pcalibre calibre13">'Alisha Jones'</span>: 2.5, <span class="pcalibre1 pcalibre calibre13">'Ryan Spencer'</span>: 3.1,
 <span class="pcalibre1 pcalibre calibre13">'Todd Reynolds'</span>: 3.4}
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13"># Same as:</span>
... <span class="pcalibre1 pcalibre calibre13"># { student.major for student in students }</span>
&gt;&gt;&gt; set(student.major <span class="pcalibre1 pcalibre calibre18">for</span> student <span class="pcalibre1 pcalibre calibre18">in</span> students)
{<span class="pcalibre1 pcalibre calibre13">'Computer Science'</span>, <span class="pcalibre1 pcalibre calibre13">'Basket Weaving'</span>, <span class="pcalibre1 pcalibre calibre13">'Economics'</span>}</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Remember, when you pass a generator expression into a function, you
can omit the inner parentheses.  That’s why you can, for example, type</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>tuple(f(x) <span class="pcalibre1 pcalibre calibre18">for</span> x <span class="pcalibre1 pcalibre calibre18">in</span> numbers)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">instead of</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>tuple((f(x) <span class="pcalibre1 pcalibre calibre18">for</span> x <span class="pcalibre1 pcalibre calibre18">in</span> numbers))</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">One last point. Generator expressions are a scalable analogue of list
comprehensions; is there any such equivalent for dicts or sets? No, it
turns out. If you need to lazily generate key-value pairs or unique
elements, your best bet is to write a generator function.</p>
</section>
<section class="calibre2 pcalibre1 pcalibre" title="Limits of Comprehensions">
<h2 id="calibre_link-78" class="pcalibre1 pcalibre calibre1">Limits of Comprehensions</h2>
<p class="pcalibre1 pcalibre calibre7">

Comprehensions have a few wrinkles people sometimes trip
over. Consider the following code:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>
<span class="pcalibre1 pcalibre calibre13"># Read in the lines of a file, stripping leading and</span>
<span class="pcalibre1 pcalibre calibre13"># trailing whitespace, skipping any empty or</span>
<span class="pcalibre1 pcalibre calibre13"># whitespace-only lines.</span>
trimmed_lines = []
<span class="pcalibre1 pcalibre calibre18">for</span> line <span class="pcalibre1 pcalibre calibre18">in</span> open(<span class="pcalibre1 pcalibre calibre13">'wombat-story.txt'</span>):
    line = line.strip()
    <span class="pcalibre1 pcalibre calibre18">if</span> line != <span class="pcalibre1 pcalibre calibre13">""</span>:
        trimmed_lines.append(line)

<span class="pcalibre1 pcalibre calibre18">print</span>(<span class="pcalibre1 pcalibre calibre13">"Got {} lines"</span>.format(len(trimmed_lines)))</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Straightforward enough - we’re building a list named
<code class="pcalibre1 pcalibre literal">trimmed_lines</code>. The resulting list has all leading and trailing
whitespace removed from its elements, skipping any empty lines (or
lines that were just whitespace to begin with). It’s not hard to
imagine needing to do something like this in a real program.</p>
<p class="pcalibre1 pcalibre calibre7">Now…​ how would you do this using a list comprehension? Here’s a first
try:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">with</span> open(<span class="pcalibre1 pcalibre calibre13">'wombat-story.txt'</span>) <span class="pcalibre1 pcalibre calibre18">as</span> story:
    trimmed_lines = [
        line.strip()
        <span class="pcalibre1 pcalibre calibre18">for</span> line <span class="pcalibre1 pcalibre calibre18">in</span> story
        <span class="pcalibre1 pcalibre calibre18">if</span> line.strip() != <span class="pcalibre1 pcalibre calibre13">""</span>
        ]

<span class="pcalibre1 pcalibre calibre18">print</span>(<span class="pcalibre1 pcalibre calibre13">"Got {} lines"</span>.format(len(trimmed_lines)))</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">This works. Notice, though, that <code class="pcalibre1 pcalibre literal">line.strip()</code> appears twice. That’s
wasting CPU cycles compared to the for-loop version, which only calls
<code class="pcalibre1 pcalibre literal">line.strip()</code> once. Stripping whitespace from a string isn’t <em class="pcalibre1 calibre8 pcalibre">that</em>
expensive, computationally speaking. But sooner or later, you will
want to do something where this matters:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; values = [
...     expensive_function(n)
...     <span class="pcalibre1 pcalibre calibre18">for</span> n <span class="pcalibre1 pcalibre calibre18">in</span> range(BIG_NUMBER)
...     <span class="pcalibre1 pcalibre calibre18">if</span> expensive_function(n) &gt; 0
...     ]</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">So how can you create this as a list comprehension, while calling
<code class="pcalibre1 pcalibre literal">expensive_function</code> only once?  It turns out there is no direct way
to do this. There some perhaps-too-clever solutions, such as memoizing
(which can easily overuse memory), nesting a generator expression
inside (probably the best choice), or making an intermediate list (if
it’s small).</p>
<p class="pcalibre1 pcalibre calibre7">If the sequence you need fits the pattern above, you might consider
building it the old-fashioned way, using a <code class="pcalibre1 pcalibre literal">for</code> loop or a generator
function. Or if you still want to use a comprehension, use an
intermediate generator expression. The result is fairly readable and
understandable (at least for you, having read this far):</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; intermediate_values = (
...     expensive_function(n)
...     <span class="pcalibre1 pcalibre calibre18">for</span> n <span class="pcalibre1 pcalibre calibre18">in</span> range(10000)
... )
&gt;&gt;&gt;
&gt;&gt;&gt; values = [
...     intermediate_value
...     <span class="pcalibre1 pcalibre calibre18">for</span> intermediate_value <span class="pcalibre1 pcalibre calibre18">in</span> intermediate_values
...     <span class="pcalibre1 pcalibre calibre18">if</span> intermediate_value &gt; 0
...     ]</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Another limitation is that comprehensions must be built on one element
at a time. The best way to see this is to imagine a list composed of
inlined key-value pairs - flattened, in other words, so even-indexed
elements are keys, and each key’s value comes right after it. Imagine
a function that converts this to a dictionary:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13"># Price per pound of fruits &amp; vegetables, in dollars.</span>
... prices_flat_list = [
...     <span class="pcalibre1 pcalibre calibre13">"orange"</span>, 0.70, <span class="pcalibre1 pcalibre calibre13">"banana"</span>, 0.86,
...     <span class="pcalibre1 pcalibre calibre13">"cantaloupe"</span>, 0.63, <span class="pcalibre1 pcalibre calibre13">"bok choy"</span>, 1.56,
...     <span class="pcalibre1 pcalibre calibre13">"coconuts"</span>, 1.06 ]

&gt;&gt;&gt; list2dict(prices_flat_list)
{<span class="pcalibre1 pcalibre calibre13">'banana'</span>: 0.86, <span class="pcalibre1 pcalibre calibre13">'bok choy'</span>: 1.56, <span class="pcalibre1 pcalibre calibre13">'cantaloupe'</span>: 0.63, <span class="pcalibre1 pcalibre calibre13">'orange'</span>: 0.7, <span class="pcalibre1 pcalibre calibre13">'coconuts'</span>: 1.06}</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Here’s one way to implement <code class="pcalibre1 pcalibre literal">list2dict</code>:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre13"># Converts a "flattened" list into an "unflattened" dict.</span>
<span class="pcalibre1 pcalibre calibre18">def</span> list2dict(flattened):
    <span class="pcalibre1 pcalibre calibre18">assert</span> len(flattened) % 2 == 0,
        <span class="pcalibre1 pcalibre calibre13">"Input must be list of key-value pairs"</span>
    unflattened = dict()
    <span class="pcalibre1 pcalibre calibre18">for</span> i <span class="pcalibre1 pcalibre calibre18">in</span> range(0, len(flattened), 2):
        key, value = flattened[i], flattened[i+1]
        unflattened[key] = value
    <span class="pcalibre1 pcalibre calibre18">return</span> unflattened</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Look at <code class="pcalibre1 pcalibre literal">list2dict</code>​'s for loop. It runs through the even index
numbers of elements in <code class="pcalibre1 pcalibre literal">flattened</code>, rather than the elements of
<code class="pcalibre1 pcalibre literal">flattened</code> directly. This allows it to refer to two different list
elements each time through the for loop.  But this turns out to be
something which just can’t be expressed in the semantics of a Python
comprehension. Generally, a comprehension operates by looking at each
element in some source sequence, one at a time; it can’t peek at
neighboring elements.</p>
<p class="pcalibre1 pcalibre calibre7">Another example: a function grouping the elements of a sequence by
some criteria - for example, the first letter of a string:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; names = [<span class="pcalibre1 pcalibre calibre13">"Joe"</span>, <span class="pcalibre1 pcalibre calibre13">"Jim"</span>, <span class="pcalibre1 pcalibre calibre13">"Todd"</span>,
...     <span class="pcalibre1 pcalibre calibre13">"Tiffany"</span>, <span class="pcalibre1 pcalibre calibre13">"Zelma"</span>, <span class="pcalibre1 pcalibre calibre13">"Gerry"</span>, <span class="pcalibre1 pcalibre calibre13">"Gina"</span>]
&gt;&gt;&gt; grouped_names = group_by_first_letter(names)
&gt;&gt;&gt; grouped_names[<span class="pcalibre1 pcalibre calibre13">'j'</span>]
[<span class="pcalibre1 pcalibre calibre13">'Joe'</span>, <span class="pcalibre1 pcalibre calibre13">'Jim'</span>]
&gt;&gt;&gt; grouped_names[<span class="pcalibre1 pcalibre calibre13">'z'</span>]
[<span class="pcalibre1 pcalibre calibre13">'Zelma'</span>]</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Here’s one way to implement the grouping function:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">from</span> <span class="pcalibre1 pcalibre calibre18">collections</span> <span class="pcalibre1 pcalibre calibre18">import</span> defaultdict
<span class="pcalibre1 pcalibre calibre18">def</span> group_by_first_letter(items):
    grouped = defaultdict(list)
    <span class="pcalibre1 pcalibre calibre18">for</span> item <span class="pcalibre1 pcalibre calibre18">in</span> items:
        key = item[0].lower()
        grouped[key].append(item)
    <span class="pcalibre1 pcalibre calibre18">return</span> grouped</code></pre>
</figure>
<p class="pcalibre1 calibre7 pcalibre7">Again, the semantics of Python comprehensions aren’t built to support
this kind of algorithm. In functional programming terms,
comprehensions can use map and filter operations, but not reduce or
fold. Fortunately, this covers many use cases. I point out these
limitations to help you avoid wasting time trying to figure them out;
in spite of them, I find comprehensions to be a valuable part of my
daily Python toolbox, and I’m sure you will too.</p>
</section>
<footer class="pcalibre1 pcalibre calibre15">
<div class="calibre16 pcalibre1 pcalibre"></div><div class="pcalibre1 pcalibre chapter-footer">
<div class="pcalibre1 pcalibre footnotes">
<aside id="calibre_link-159" type="footnote" class="calibre2 pcalibre1 pcalibre">
<p class="pcalibre1 calibre17 pcalibre"><sup class="noteref1 pcalibre1 pcalibre"><a href="#calibre_link-162" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">1</a></sup> Technically, the condition doesn’t have to depend on the variable, but it’s hard to imagine building a useful list comprehension this way.</p>
</aside>
<aside id="calibre_link-160" type="footnote" class="calibre2 pcalibre1 pcalibre">
<p class="pcalibre1 calibre17 pcalibre"><sup class="noteref1 pcalibre1 pcalibre"><a href="#calibre_link-163" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">2</a></sup> I like to think future version control tools will automatically resolve this kind of situation. I believe it will require the tool to have some knowledge of the language syntax, so it can parse and reason about different clauses in a line of code.</p>
</aside>
<aside id="calibre_link-161" type="footnote" class="calibre2 pcalibre1 pcalibre">
<p class="pcalibre1 calibre17 pcalibre"><sup class="noteref1 pcalibre1 pcalibre"><a href="#calibre_link-164" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">3</a></sup> Refresher: The <code class="pcalibre1 pcalibre literal">range</code> built-in returns an iterator over a sequence of integers, and can be called with 1, 2, or 3 arguments. The most general form is <code class="pcalibre1 pcalibre literal">range(start, stop, step)</code>, beginning at <code class="pcalibre1 pcalibre literal">start</code>, going up to <em class="pcalibre1 calibre8 pcalibre">but not including</em> <code class="pcalibre1 pcalibre literal">stop</code>, in increments of <code class="pcalibre1 pcalibre literal">step</code>. Called with 2 arguments, the step-size defaults to one; with one argument, that argument is the <code class="pcalibre1 pcalibre literal">stop</code>, and the sequence starts at zero.  In Python 2, use <code class="pcalibre1 pcalibre literal">xrange</code> instead of <code class="pcalibre1 pcalibre literal">range</code>.</p>
</aside>
</div>
</div>
</footer>
</section>
</div>


<div id="calibre_link-147" class="pcalibre1 pcalibre calibre">
<section class="calibre2 pcalibre1 pcalibre" id="calibre_link-172" title="Advanced Functions" type="chapter">
<header id="calibre_link-79" class="calibre2 pcalibre1 pcalibre">
<div class="pcalibre1 pcalibre chapter-header">
<h1 class="pcalibre1 chapter-title pcalibre"> <small class="subtitle pcalibre1 pcalibre"><b class="pcalibre1 pcalibre calibre6">ADVANCED</b> <b class="pcalibre1 pcalibre calibre6">FUNCTIONS</b></small></h1>
</div>
</header>
<p class="pcalibre1 pcalibre calibre7">
In this chapter, we go beyond the basics of using functions. I’ll
assume you can define and work with functions taking default
arguments:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre18">def</span> foo(a, b, x=3, y=2):
...     <span class="pcalibre1 pcalibre calibre18">return</span> (a+b)/(x+y)
...
&gt;&gt;&gt; foo(5, 0)
1.0
&gt;&gt;&gt; foo(10, 2, y=3)
2.0
&gt;&gt;&gt; foo(b=4, x=8, a=1)
0.5</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Notice the last way <code class="pcalibre1 pcalibre literal">foo</code> is called: with the arguments out of order,
and everything specified by key-value pairs. Not everyone knows that
you can call <em class="pcalibre1 calibre8 pcalibre">any</em> function in Python this way. So long as the value
of each argument is unambiguously specified, Python doesn’t care how
you call the function (and this case, we specify <code class="pcalibre1 pcalibre literal">b</code>, <code class="pcalibre1 pcalibre literal">x</code> and <code class="pcalibre1 pcalibre literal">a</code> out
of order, letting <code class="pcalibre1 pcalibre literal">y</code> be its default value). We’ll leverage this
flexibility later.</p>
<p class="pcalibre1 pcalibre calibre7">This chapter’s topics are useful and valuable on their own. And they
are important building blocks for some <em class="pcalibre1 calibre8 pcalibre">extremely</em> powerful
patterns, which you learn in later chapters. Let’s get started!</p>
<section class="calibre2 pcalibre1 pcalibre" title="Accepting &amp; Passing Variable Arguments">
<h2 id="calibre_link-80" class="pcalibre1 pcalibre calibre1">Accepting &amp; Passing Variable Arguments</h2>
<p class="pcalibre1 pcalibre calibre7">


The <code class="pcalibre1 pcalibre literal">foo</code> function above can be called with either 2, 3, or 4
arguments.  Sometimes you want to define a function that can take
<em class="pcalibre1 calibre8 pcalibre">any</em> number of arguments - zero or more, in other words. In Python,
it looks like this:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre13"># Note the asterisk. That's the magic part</span>
<span class="pcalibre1 pcalibre calibre18">def</span> takes_any_args(*args):
    <span class="pcalibre1 pcalibre calibre18">print</span>(<span class="pcalibre1 pcalibre calibre13">"Type of args: "</span> + str(type(args)))
    <span class="pcalibre1 pcalibre calibre18">print</span>(<span class="pcalibre1 pcalibre calibre13">"Value of args: "</span> + str(args))</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">See carefully the syntax here. <code class="pcalibre1 pcalibre literal">takes_any_args</code> is just like a
regular function, except you put an asterisk right before the argument
<code class="pcalibre1 pcalibre literal">args</code>. Within the function, <code class="pcalibre1 pcalibre literal">args</code> is a tuple:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">&gt;&gt;&gt; </span>takes_any_args(<span class="pcalibre1 pcalibre calibre13">"x"</span>, <span class="pcalibre1 pcalibre calibre13">"y"</span>, <span class="pcalibre1 pcalibre calibre13">"z"</span>)
Type of args: &lt;class 'tuple'&gt;
Value of args: ('x', 'y', 'z')
<span class="pcalibre1 pcalibre calibre18">&gt;&gt;&gt; </span>takes_any_args(1)
Type of args: &lt;class 'tuple'&gt;
Value of args: (1,)
<span class="pcalibre1 pcalibre calibre18">&gt;&gt;&gt; </span>takes_any_args()
Type of args: &lt;class 'tuple'&gt;
Value of args: ()
<span class="pcalibre1 pcalibre calibre18">&gt;&gt;&gt; </span>takes_any_args(5, 4, 3, 2, 1)
Type of args: &lt;class 'tuple'&gt;
Value of args: (5, 4, 3, 2, 1)
<span class="pcalibre1 pcalibre calibre18">&gt;&gt;&gt; </span>takes_any_args([<span class="pcalibre1 pcalibre calibre13">"first"</span>, <span class="pcalibre1 pcalibre calibre13">"list"</span>], [<span class="pcalibre1 pcalibre calibre13">"another"</span>,<span class="pcalibre1 pcalibre calibre13">"list"</span>])
Type of args: &lt;class 'tuple'&gt;
Value of args: (['first', 'list'], ['another', 'list'])</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">If you call the function with no arguments, <code class="pcalibre1 pcalibre literal">args</code> is an empty
tuple. Otherwise, it is a tuple composed of those arguments passed, in
order. This is different from declaring a function that takes a single
argument, which happens to be of type list or tuple:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">&gt;&gt;&gt; def</span> takes_a_list(items):
<span class="pcalibre1 pcalibre calibre18">... </span>    <span class="pcalibre1 pcalibre calibre18">print</span>(<span class="pcalibre1 pcalibre calibre13">"Type of items: "</span> + str(type(items)))
<span class="pcalibre1 pcalibre calibre18">... </span>    <span class="pcalibre1 pcalibre calibre18">print</span>(<span class="pcalibre1 pcalibre calibre13">"Value of items: "</span> + str(items))
<span class="pcalibre1 pcalibre calibre18">...</span>
<span class="pcalibre1 pcalibre calibre18">&gt;&gt;&gt; </span>takes_a_list([<span class="pcalibre1 pcalibre calibre13">"x"</span>, <span class="pcalibre1 pcalibre calibre13">"y"</span>, <span class="pcalibre1 pcalibre calibre13">"z"</span>])
Type of items: &lt;class 'list'&gt;
Value of items: ['x', 'y', 'z']
<span class="pcalibre1 pcalibre calibre18">&gt;&gt;&gt; </span>takes_any_args([<span class="pcalibre1 pcalibre calibre13">"x"</span>, <span class="pcalibre1 pcalibre calibre13">"y"</span>, <span class="pcalibre1 pcalibre calibre13">"z"</span>])
Type of args: &lt;class 'tuple'&gt;
Value of args: (['x', 'y', 'z'],)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">In these calls to <code class="pcalibre1 pcalibre literal">takes_a_list</code> and <code class="pcalibre1 pcalibre literal">takes_any_args</code>, the argument
<code class="pcalibre1 pcalibre literal">items</code> is a list of strings.  We’re calling both functions the exact
same way, but what happens in each function is different. Within
<code class="pcalibre1 pcalibre literal">takes_any_args</code>, the tuple named <code class="pcalibre1 pcalibre literal">args</code> has one element - and that
element is the list <code class="pcalibre1 pcalibre literal">["x", "y", "z"]</code>. But in <code class="pcalibre1 pcalibre literal">takes_a_list</code>, <code class="pcalibre1 pcalibre literal">items</code>
is the list itself.</p>
<p class="pcalibre1 pcalibre calibre7">This <code class="pcalibre1 pcalibre literal">*args</code> idiom gives you some <em class="pcalibre1 calibre8 pcalibre">very</em> helpful programming
patterns. You can work with arguments as an abstract sequence, while
providing a potentially more natural interface for whomever calls the
function.</p>
<p class="pcalibre1 pcalibre calibre7">Above, I’ve always named the argument <code class="pcalibre1 pcalibre literal">args</code> in the function
signature.  Writing <code class="pcalibre1 pcalibre literal">*args</code> is a well-followed convention, but you
can choose a different name - the asterisk is what makes it a variable
argument. For instance, this takes paths of several files as
arguments:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">def</span> read_files(*paths):
    data = <span class="pcalibre1 pcalibre calibre13">""</span>
    <span class="pcalibre1 pcalibre calibre18">for</span> path <span class="pcalibre1 pcalibre calibre18">in</span> paths:
        <span class="pcalibre1 pcalibre calibre18">with</span> open(path) <span class="pcalibre1 pcalibre calibre18">as</span> handle:
            data += handle.read()
    <span class="pcalibre1 pcalibre calibre18">return</span> data</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Most Python programmers use <code class="pcalibre1 pcalibre literal">*args</code> unless there is a reason to name
it something else.<sup class="pcalibre1 pcalibre noteref">[<a href="#calibre_link-148" id="calibre_link-153" type="noteref" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">1</a>]</sup> That reason is usually readability; <code class="pcalibre1 pcalibre literal">read_files</code> is a good
example. If naming it something other than <code class="pcalibre1 pcalibre literal">args</code> makes the code more
understandable, do it.</p>
<h3 class="pcalibre1 calibre21 pcalibre" id="calibre_link-173">Argument Unpacking</h3>
<p class="pcalibre1 pcalibre calibre7">

The star modifier works in the other direction too. Intriguingly, you
can use it with <em class="pcalibre1 calibre8 pcalibre">any</em> function. For example, suppose a library
provides this function:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">def</span> order_book(title, author, isbn):
    <span class="pcalibre1 pcalibre calibre13">"""</span>
<span class="pcalibre1 pcalibre calibre13">    Place an order for a book.</span>
<span class="pcalibre1 pcalibre calibre13">    """</span>
    <span class="pcalibre1 pcalibre calibre18">print</span>(<span class="pcalibre1 pcalibre calibre13">"Ordering '{}' by {} ({})"</span>.format(
        title, author, isbn))
    <span class="pcalibre1 pcalibre calibre13"># ...</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Notice there’s no asterisk. Suppose in another, completely different
library, you fetch the book info from this function:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">def</span> get_required_textbook(class_id):
    <span class="pcalibre1 pcalibre calibre13">"""</span>
<span class="pcalibre1 pcalibre calibre13">    Returns a tuple (title, author, ISBN)</span>
<span class="pcalibre1 pcalibre calibre13">    """</span>
    <span class="pcalibre1 pcalibre calibre13"># ...</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Again, no asterisk. Now, one way you can bridge these two functions is
to store the tuple result from <code class="pcalibre1 pcalibre literal">get_required_textbook</code>, then
unpack it element by element:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; book_info = get_required_textbook(4242)
&gt;&gt;&gt; order_book(book_info[0], book_info[1], book_info[2])
Ordering <span class="pcalibre1 pcalibre calibre13">'Writing Great Code'</span> by Randall Hyde (1593270038)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Writing code this way is tedious and error-prone; not ideal.</p>
<p class="pcalibre1 pcalibre calibre7">Fortunately, Python provides a better way.  Let’s look at a different
function:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">def</span> normal_function(a, b, c):
    <span class="pcalibre1 pcalibre calibre18">print</span>(<span class="pcalibre1 pcalibre calibre13">"a: {} b: {} c: {}"</span>.format(a,b,c))</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">No trick here - it really is a normal, boring function, taking
three arguments. If we have those three arguments as a list or tuple,
Python can automatically "unpack" them for us. We just need to pass
in that collection, prefixed with an asterisk:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; numbers = (7, 5, 3)
&gt;&gt;&gt; normal_function(*numbers)
a: 7 b: 5 c: 3</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Again, <code class="pcalibre1 pcalibre literal">normal_function</code> is just a regular function. We did not use
an asterisk on the <code class="pcalibre1 pcalibre literal">def</code> line. But when we call it, we take a tuple
called <code class="pcalibre1 pcalibre literal">numbers</code>, and pass it in with the asterisk in front. This is
then unpacked <em class="pcalibre1 calibre8 pcalibre">within the function</em> to the arguments <code class="pcalibre1 pcalibre literal">a</code>, <code class="pcalibre1 pcalibre literal">b</code>, and
<code class="pcalibre1 pcalibre literal">c</code>.</p>
<p class="pcalibre1 pcalibre calibre7">There is a duality here. We can use the asterisk syntax both in
<em class="pcalibre1 calibre8 pcalibre">defining</em> a function, and in <em class="pcalibre1 calibre8 pcalibre">calling</em> a function. The syntax looks
very similar. But realize they are doing two different things. One is
packing arguments into a tuple automatically - called "variable
arguments"; the other is <em class="pcalibre1 calibre8 pcalibre">un</em>-packing them - called "argument
unpacking".  Be clear on the distinction between the two in your mind.</p>
<p class="pcalibre1 pcalibre calibre7">Armed with this complete understanding, we can bridge the two book
functions in a much better way:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; book_info = get_required_textbook(4242)
&gt;&gt;&gt; order_book(*book_info)
Ordering <span class="pcalibre1 pcalibre calibre13">'Writing Great Code'</span> by Randall Hyde (1593270038)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">This is more concise (less tedious to type), and more maintainable. As
you get used to the concepts, you’ll find it increasingly natural and
easy to use in the code you write.</p>
<h3 class="pcalibre1 calibre21 pcalibre" id="calibre_link-174">Variable Keyword Arguments</h3>
<p class="pcalibre1 pcalibre calibre7">So far we have just looked at functions with <em class="pcalibre1 calibre8 pcalibre">positional</em>
arguments - the kind where you declare a function like <code class="pcalibre1 pcalibre literal">def foo(a,
b):</code>, and then invoke it like <code class="pcalibre1 pcalibre literal">foo(7, 2)</code>. You know that a=7 and b=2
within the function, because of the order of the arguments. Of course,
Python also has keyword arguments:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre18">def</span> get_rental_cars(size, doors=4,
...         transmission=<span class="pcalibre1 pcalibre calibre13">'automatic'</span>):
...     template = <span class="pcalibre1 pcalibre calibre13">"Looking for a {}-door {} car with {} transmission...."</span>
...     <span class="pcalibre1 pcalibre calibre18">print</span>(template.format(doors, size, transmission))
...
&gt;&gt;&gt; get_rental_cars(<span class="pcalibre1 pcalibre calibre13">"economy"</span>, transmission=<span class="pcalibre1 pcalibre calibre13">'manual'</span>)
Looking <span class="pcalibre1 pcalibre calibre18">for</span> a 4-door economy car <span class="pcalibre1 pcalibre calibre18">with</span> manual transmission....</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">And remember, Python lets you call <em class="pcalibre1 calibre8 pcalibre">any</em> function just using keyword
arguments:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre18">def</span> bar(x, y, z):
...     <span class="pcalibre1 pcalibre calibre18">return</span> x + y * z
...
&gt;&gt;&gt; bar(z=2, y=3, x=4)
10</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">These keyword arguments won’t be captured by the <code class="pcalibre1 pcalibre literal">*args</code>
idiom. Instead, Python provides a different syntax - using two
asterisks instead of one:</p>
<p class="pcalibre1 pcalibre calibre7">
</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">def</span> print_kwargs(**kwargs):
    <span class="pcalibre1 pcalibre calibre18">for</span> key, value <span class="pcalibre1 pcalibre calibre18">in</span> kwargs.items():
        <span class="pcalibre1 pcalibre calibre18">print</span>(<span class="pcalibre1 pcalibre calibre13">"{} -&gt; {}"</span>.format(key, value))</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">The variable <code class="pcalibre1 pcalibre literal">kwargs</code> is a <em class="pcalibre1 calibre8 pcalibre">dictionary</em>. (In contrast to <code class="pcalibre1 pcalibre literal">args</code> -
remember, that was a tuple.) It’s just a regular <code class="pcalibre1 pcalibre literal">dict</code>, so we can
iterate through its key-value pairs with <code class="pcalibre1 pcalibre literal">.items()</code>:<sup class="pcalibre1 pcalibre noteref">[<a href="#calibre_link-149" id="calibre_link-154" type="noteref" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">2</a>]</sup></p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; print_kwargs(hero=<span class="pcalibre1 pcalibre calibre13">"Homer"</span>, antihero=<span class="pcalibre1 pcalibre calibre13">"Bart"</span>,
...     genius=<span class="pcalibre1 pcalibre calibre13">"Lisa"</span>)
hero -&gt; Homer
antihero -&gt; Bart
genius -&gt; Lisa</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">The arguments to <code class="pcalibre1 pcalibre literal">print_kwargs</code> are key-value pairs. This is regular
Python syntax for calling functions; what’s interesting is happening
<em class="pcalibre1 calibre8 pcalibre">inside</em> the function. There, a variable called <code class="pcalibre1 pcalibre literal">kwargs</code> is
defined. It’s a Python dictionary, consisting of the key-value pairs
passed in when the function was called.</p>
<p class="pcalibre1 pcalibre calibre7">Here’s another example, which has a regular positional argument,
followed by arbitrary key-value pairs:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">def</span> set_config_defaults(config, **kwargs):
    <span class="pcalibre1 pcalibre calibre18">for</span> key, value <span class="pcalibre1 pcalibre calibre18">in</span> kwargs.items():
        <span class="pcalibre1 pcalibre calibre13"># Do not overwrite existing values.</span>
        <span class="pcalibre1 pcalibre calibre18">if</span> key <span class="pcalibre1 pcalibre calibre18">not</span> <span class="pcalibre1 pcalibre calibre18">in</span> config:
            config[key] = value</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">This is perfectly valid. You can define a function that takes some
normal arguments, followed by zero or more key-value pairs:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; config = {<span class="pcalibre1 pcalibre calibre13">"verbosity"</span>: 3, <span class="pcalibre1 pcalibre calibre13">"theme"</span>: <span class="pcalibre1 pcalibre calibre13">"Blue Steel"</span>}
&gt;&gt;&gt; set_config_defaults(config, bass=11, verbosity=2)
&gt;&gt;&gt; config
{<span class="pcalibre1 pcalibre calibre13">'verbosity'</span>: 3, <span class="pcalibre1 pcalibre calibre13">'theme'</span>: <span class="pcalibre1 pcalibre calibre13">'Blue Steel'</span>, <span class="pcalibre1 pcalibre calibre13">'bass'</span>: 11}</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Like with <code class="pcalibre1 pcalibre literal">*args</code>, naming this variable <code class="pcalibre1 pcalibre literal">kwargs</code> is just a strong
convention; you can choose a different name if that improves
readability.</p>
<h3 class="pcalibre1 calibre21 pcalibre" id="calibre_link-175">Keyword Unpacking</h3>
<p class="pcalibre1 pcalibre calibre7">
Just like with <code class="pcalibre1 pcalibre literal">*args</code>, double-star works the other way too. We can
take a regular function, and pass it a dictionary using two asterisks:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre18">def</span> normal_function(a, b, c):
...     <span class="pcalibre1 pcalibre calibre18">print</span>(<span class="pcalibre1 pcalibre calibre13">"a: {} b: {} c: {}"</span>.format(a,b,c))
...
&gt;&gt;&gt; numbers = {<span class="pcalibre1 pcalibre calibre13">"a"</span>: 7, <span class="pcalibre1 pcalibre calibre13">"b"</span>: 5, <span class="pcalibre1 pcalibre calibre13">"c"</span>: 3}
&gt;&gt;&gt; normal_function(**numbers)
a: 7 b: 5 c: 3</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Note the keys of the dictionary <em class="pcalibre1 calibre8 pcalibre">must</em> match up with how the function
was declared. Otherwise you get an error:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; bad_numbers = {<span class="pcalibre1 pcalibre calibre13">"a"</span>: 7, <span class="pcalibre1 pcalibre calibre13">"b"</span>: 5, <span class="pcalibre1 pcalibre calibre13">"z"</span>: 3}
&gt;&gt;&gt; normal_function(**bad_numbers)
Traceback (most recent call last):
  File <span class="pcalibre1 pcalibre calibre13">"&lt;stdin&gt;"</span>, line 1, <span class="pcalibre1 pcalibre calibre18">in</span> &lt;module&gt;
<span class="pcalibre1 pcalibre calibre18">TypeError</span>: normal_function() got an unexpected keyword argument <span class="pcalibre1 pcalibre calibre13">'z'</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">This is called <em class="pcalibre1 calibre8 pcalibre">keyword argument unpacking</em>.  It works regardless of
whether that function has default values for some of its arguments or
not. So long as the value of each argument is specified one way or
another, you have valid code:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre18">def</span> another_function(x, y, z=2):
...     <span class="pcalibre1 pcalibre calibre18">print</span>(<span class="pcalibre1 pcalibre calibre13">"x: {} y: {} z: {}"</span>.format(x,y,z))
...
&gt;&gt;&gt; all_numbers = {<span class="pcalibre1 pcalibre calibre13">"x"</span>: 2, <span class="pcalibre1 pcalibre calibre13">"y"</span>: 7, <span class="pcalibre1 pcalibre calibre13">"z"</span>: 10}
&gt;&gt;&gt; some_numbers = {<span class="pcalibre1 pcalibre calibre13">"x"</span>: 2, <span class="pcalibre1 pcalibre calibre13">"y"</span>: 7}
&gt;&gt;&gt; missing_numbers = {<span class="pcalibre1 pcalibre calibre13">"x"</span>: 2}
&gt;&gt;&gt; another_function(**all_numbers)
x: 2 y: 7 z: 10
&gt;&gt;&gt; another_function(**some_numbers)
x: 2 y: 7 z: 2
&gt;&gt;&gt; another_function(**missing_numbers)
Traceback (most recent call last):
  File <span class="pcalibre1 pcalibre calibre13">"&lt;stdin&gt;"</span>, line 1, <span class="pcalibre1 pcalibre calibre18">in</span> &lt;module&gt;
<span class="pcalibre1 pcalibre calibre18">TypeError</span>: another_function() missing 1 required positional argument: <span class="pcalibre1 pcalibre calibre13">'y'</span></code></pre>
</figure>
<h3 class="pcalibre1 calibre21 pcalibre" id="calibre_link-176">Combining Positional and Keyword Arguments</h3>
<p class="pcalibre1 pcalibre calibre7"> You can combine the syntax to use both
positional and keyword arguments. In a function signature, just
separate <code class="pcalibre1 pcalibre literal">*args</code> and <code class="pcalibre1 pcalibre literal">**kwargs</code> by a comma:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre18">def</span> general_function(*args, **kwargs):
...     <span class="pcalibre1 pcalibre calibre18">for</span> arg <span class="pcalibre1 pcalibre calibre18">in</span> args:
...         <span class="pcalibre1 pcalibre calibre18">print</span>(arg)
...     <span class="pcalibre1 pcalibre calibre18">for</span> key, value <span class="pcalibre1 pcalibre calibre18">in</span> kwargs.items():
...         <span class="pcalibre1 pcalibre calibre18">print</span>(<span class="pcalibre1 pcalibre calibre13">"{} -&gt; {}"</span>.format(key, value))
...
&gt;&gt;&gt; general_function(<span class="pcalibre1 pcalibre calibre13">"foo"</span>, <span class="pcalibre1 pcalibre calibre13">"bar"</span>, x=7, y=33)
foo
bar
y -&gt; 33
x -&gt; 7</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">This usage - declaring a function like <code class="pcalibre1 pcalibre literal">def general_function(*args,
**kwargs)</code> - is the most general way to define a function in Python. A
function so declared can be called in any way, with any valid
combination of keyword and non-keyword arguments - including no
arguments.</p>
<p class="pcalibre1 pcalibre calibre7">Similarly, you can call a function using both - and both will be unpacked:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre18">def</span> addup(a, b, c=1, d=2, e=3):
...     <span class="pcalibre1 pcalibre calibre18">return</span> a + b + c + d + e
...
&gt;&gt;&gt; nums = (3, 4)
&gt;&gt;&gt; extras = {<span class="pcalibre1 pcalibre calibre13">"d"</span>: 5, <span class="pcalibre1 pcalibre calibre13">"e"</span>: 2}
&gt;&gt;&gt; addup(*nums, **extras)
15</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">There’s one last point to understand, on argument ordering. When you
<code class="pcalibre1 pcalibre literal">def</code> the function, you specify the arguments in this order:</p>
<div class="pcalibre1 pcalibre itemized-list">
<ul class="pcalibre1 calibre14 pcalibre">
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">Named, regular (non-keyword) arguments, then</span>
</li>
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">the <code class="pcalibre1 pcalibre literal">*args</code> non-keyword variable arguments, then</span>
</li>
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">the <code class="pcalibre1 pcalibre literal">**kwargs</code> keyword variable arguments, and finally</span>
</li>
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">required keyword-only arguments.</span>
</li>
</ul>
</div>
<p class="pcalibre1 pcalibre calibre7">You can omit any of these when defining a function. But
any that are present <em class="pcalibre1 calibre8 pcalibre">must</em> be in this order.</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre13"># All these are valid function definitions.</span>
<span class="pcalibre1 pcalibre calibre18">def</span> combined1(a, b, *args): <span class="pcalibre1 pcalibre calibre18">pass</span>
<span class="pcalibre1 pcalibre calibre18">def</span> combined2(x, y, z, **kwargs): <span class="pcalibre1 pcalibre calibre18">pass</span>
<span class="pcalibre1 pcalibre calibre18">def</span> combined3(*args, **kwargs): <span class="pcalibre1 pcalibre calibre18">pass</span>
<span class="pcalibre1 pcalibre calibre18">def</span> combined4(x, *args): <span class="pcalibre1 pcalibre calibre18">pass</span>
<span class="pcalibre1 pcalibre calibre18">def</span> combined5(u, v, w, *args, **kwargs): <span class="pcalibre1 pcalibre calibre18">pass</span>
<span class="pcalibre1 pcalibre calibre18">def</span> combined6(*args, x, y): <span class="pcalibre1 pcalibre calibre18">pass</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Violating this order will cause errors:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre18">def</span> bad_combo(**kwargs, *args): <span class="pcalibre1 pcalibre calibre18">pass</span>
  File <span class="pcalibre1 pcalibre calibre13">"&lt;stdin&gt;"</span>, line 1
    <span class="pcalibre1 pcalibre calibre18">def</span> bad_combo(**kwargs, *args): <span class="pcalibre1 pcalibre calibre18">pass</span>
                          ^
<span class="pcalibre1 pcalibre calibre18">SyntaxError</span>: invalid syntax</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">
Sometimes you might want to define a function that takes 0 or more
positional arguments, and 1 or more <em class="pcalibre1 calibre8 pcalibre">required</em> keyword arguments.  You
can define a function like this with <code class="pcalibre1 pcalibre literal">*args</code> followed by regular
arguments, forming a special category, called <em class="pcalibre1 calibre8 pcalibre">keyword-only
arguments</em>.<sup class="pcalibre1 pcalibre noteref">[<a href="#calibre_link-150" id="calibre_link-155" type="noteref" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">3</a>]</sup>  If present, whenever that function is called, all
must specified as key-value pairs, <em class="pcalibre1 calibre8 pcalibre">after</em> the non-keyword arguments:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre18">def</span> read_data_from_files(*paths, format):
...     <span class="pcalibre1 pcalibre calibre13">"""Read and merge data from several files,</span>
<span class="pcalibre1 pcalibre calibre13">...     which are in XML, JSON, or YAML format."""</span>
...     <span class="pcalibre1 pcalibre calibre13"># ...</span>
...
&gt;&gt;&gt; housing_files = [<span class="pcalibre1 pcalibre calibre13">"houses.json"</span>, <span class="pcalibre1 pcalibre calibre13">"condos.json"</span>]
&gt;&gt;&gt; housing_data = read_data_from_files(
...     *housing_files, format=<span class="pcalibre1 pcalibre calibre13">"json"</span>)
&gt;&gt;&gt; commodities_data = read_data_from_files(
        <span class="pcalibre1 pcalibre calibre13">"commodities.xml"</span>, format=<span class="pcalibre1 pcalibre calibre13">"xml"</span>)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">See how <code class="pcalibre1 pcalibre literal">format</code>​'s value is specified with a key-value pair. If you
try passing it without <code class="pcalibre1 pcalibre literal">format=</code> in front, you get an error:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; commodities_data = read_data_from_files(
...     <span class="pcalibre1 pcalibre calibre13">"commodities.xml"</span>, <span class="pcalibre1 pcalibre calibre13">"xml"</span>)
Traceback (most recent call last):
  File <span class="pcalibre1 pcalibre calibre13">"&lt;stdin&gt;"</span>, line 2, <span class="pcalibre1 pcalibre calibre18">in</span> &lt;module&gt;
<span class="pcalibre1 pcalibre calibre18">TypeError</span>: read_data_from_files() missing 1 required keyword-only argument: <span class="pcalibre1 pcalibre calibre13">'format'</span></code></pre>
</figure>
</section>
<section class="calibre2 pcalibre1 pcalibre" title="Functions As Objects">
<h2 id="calibre_link-81" class="pcalibre1 pcalibre calibre1">Functions As Objects</h2>
<p class="pcalibre1 pcalibre calibre7"></p>
<p class="pcalibre1 pcalibre calibre7">In Python, functions are ordinary objects - just like an integer, a
list, or an instance of a class you create. The implications are
profound, letting you do certain <em class="pcalibre1 calibre8 pcalibre">very</em> useful things with
functions. Leveraging this is one of those secrets separating
average Python developers from great ones, because of the <em class="pcalibre1 calibre8 pcalibre">extremely</em>
powerful abstractions which follow.</p>
<p class="pcalibre1 pcalibre calibre7"><strong class="pcalibre1 pcalibre calibre9">Once you get this, it can change the way you write software forever.</strong>
In fact, these advanced patterns for using functions in Python largely
transfer to other languages you will use in the future.</p>
<p class="pcalibre1 pcalibre calibre7">To explain, let’s start by laying out a problematic situation, and how
to solve it. Imagine you have a list of strings representing numbers:</p>
<p class="pcalibre1 pcalibre calibre7"></p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>nums = [<span class="pcalibre1 pcalibre calibre13">"12"</span>, <span class="pcalibre1 pcalibre calibre13">"7"</span>, <span class="pcalibre1 pcalibre calibre13">"30"</span>, <span class="pcalibre1 pcalibre calibre13">"14"</span>, <span class="pcalibre1 pcalibre calibre13">"3"</span>]</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Suppose we want to find the biggest integer in this list. The <code class="pcalibre1 pcalibre literal">max</code>
builtin does not help us:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; max(nums)
<span class="pcalibre1 pcalibre calibre13">'7'</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">
This isn’t a bug, of course; since the objects in <code class="pcalibre1 pcalibre literal">nums</code> are strings,
<code class="pcalibre1 pcalibre literal">max</code> compares each element lexicographically.<sup class="pcalibre1 pcalibre noteref">[<a href="#calibre_link-151" id="calibre_link-156" type="noteref" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">4</a>]</sup>
By that criteria, "7" is greater than "30", for the same reason "g"
comes after "ca" alphabetically. Essentially, <code class="pcalibre1 pcalibre literal">max</code> is evaluating the
element by a different criteria than what we want.</p>
<p class="pcalibre1 pcalibre calibre7">Since <code class="pcalibre1 pcalibre literal">max</code>​'s algorithm is simple, let’s roll our own that compares
based on the integer value of the string:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre18">def</span> max_by_int_value(items):
...     <span class="pcalibre1 pcalibre calibre13"># For simplicity, assume len(items) &gt; 0</span>
...     biggest = items[0]
...     <span class="pcalibre1 pcalibre calibre18">for</span> item <span class="pcalibre1 pcalibre calibre18">in</span> items[1:]:
...         <span class="pcalibre1 pcalibre calibre18">if</span> int(item) &gt; int(biggest):
...             biggest = item
...     <span class="pcalibre1 pcalibre calibre18">return</span> biggest
...
&gt;&gt;&gt; max_by_int_value(nums)
<span class="pcalibre1 pcalibre calibre13">'30'</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">This gives us what we want: it returns the element in the original
list which is maximal, as evaluated by our criteria. Now imagine
working with different data, where you have different criteria. For
example, a list of actual integers:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>integers = [3, -2, 7, -1, -20]</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Suppose we want to find the number with the greatest <em class="pcalibre1 calibre8 pcalibre">absolute value</em>
- i.e., distance from zero. That would be -20 here, but standard <code class="pcalibre1 pcalibre literal">max</code>
won’t do that:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; max(integers)
7</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Again, let’s roll our own, using the built-in <code class="pcalibre1 pcalibre literal">abs</code> function:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre18">def</span> max_by_abs(items):
...     biggest = items[0]
...     <span class="pcalibre1 pcalibre calibre18">for</span> item <span class="pcalibre1 pcalibre calibre18">in</span> items[1:]:
...         <span class="pcalibre1 pcalibre calibre18">if</span> abs(item) &gt; abs(biggest):
...             biggest = item
...     <span class="pcalibre1 pcalibre calibre18">return</span> biggest
...
&gt;&gt;&gt; max_by_abs(integers)
-20</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">One more example - a list of dictionary objects:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>student_joe = {<span class="pcalibre1 pcalibre calibre13">'gpa'</span>: 3.7, <span class="pcalibre1 pcalibre calibre13">'major'</span>: <span class="pcalibre1 pcalibre calibre13">'physics'</span>,
               <span class="pcalibre1 pcalibre calibre13">'name'</span>: <span class="pcalibre1 pcalibre calibre13">'Joe Smith'</span>}
student_jane = {<span class="pcalibre1 pcalibre calibre13">'gpa'</span>: 3.8, <span class="pcalibre1 pcalibre calibre13">'major'</span>: <span class="pcalibre1 pcalibre calibre13">'chemistry'</span>,
                <span class="pcalibre1 pcalibre calibre13">'name'</span>: <span class="pcalibre1 pcalibre calibre13">'Jane Jones'</span>}
student_zoe = {<span class="pcalibre1 pcalibre calibre13">'gpa'</span>: 3.4, <span class="pcalibre1 pcalibre calibre13">'major'</span>: <span class="pcalibre1 pcalibre calibre13">'literature'</span>,
               <span class="pcalibre1 pcalibre calibre13">'name'</span>: <span class="pcalibre1 pcalibre calibre13">'Zoe Fox'</span>}
students = [student_joe, student_jane, student_zoe]</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Now, what if we want the record of the student with the highest GPA?
Here’s a suitable max function:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre18">def</span> max_by_gpa(items):
...     biggest = items[0]
...     <span class="pcalibre1 pcalibre calibre18">for</span> item <span class="pcalibre1 pcalibre calibre18">in</span> items[1:]:
...         <span class="pcalibre1 pcalibre calibre18">if</span> item[<span class="pcalibre1 pcalibre calibre13">"gpa"</span>] &gt; biggest[<span class="pcalibre1 pcalibre calibre13">"gpa"</span>]:
...             biggest = item
...     <span class="pcalibre1 pcalibre calibre18">return</span> biggest
...
&gt;&gt;&gt; max_by_gpa(students)
{<span class="pcalibre1 pcalibre calibre13">'name'</span>: <span class="pcalibre1 pcalibre calibre13">'Jane Jones'</span>, <span class="pcalibre1 pcalibre calibre13">'gpa'</span>: 3.8, <span class="pcalibre1 pcalibre calibre13">'major'</span>: <span class="pcalibre1 pcalibre calibre13">'chemistry'</span>}</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Just one line of code is different between <code class="pcalibre1 pcalibre literal">max_by_int_value</code>,
<code class="pcalibre1 pcalibre literal">max_by_abs</code>, and <code class="pcalibre1 pcalibre literal">max_by_gpa</code>: the comparison
line. <code class="pcalibre1 pcalibre literal">max_by_int_value</code> says <code class="pcalibre1 pcalibre literal">if int(item) &gt; int(biggest)</code>;
<code class="pcalibre1 pcalibre literal">max_by_abs</code> says <code class="pcalibre1 pcalibre literal">if abs(item) &gt; abs(biggest)</code>; and <code class="pcalibre1 pcalibre literal">max_by_gpa</code>
compares <code class="pcalibre1 pcalibre literal">item["gpa"]</code> to <code class="pcalibre1 pcalibre literal">biggest["gpa"]</code>. Other than that, these
<code class="pcalibre1 pcalibre literal">max</code> functions are identical.</p>
<p class="pcalibre1 pcalibre calibre7">I don’t know about you, but having nearly-identical functions like
this drives me nuts. The way out is to realize the comparison is
based on a value <em class="pcalibre1 calibre8 pcalibre">derived</em> from the element - not the value of the
element itself. In other words: each cycle through the for loop, the
two elements are <strong class="pcalibre1 pcalibre calibre9">not</strong> themselves compared. What is compared is some
derived, calculated value: <code class="pcalibre1 pcalibre literal">int(item)</code>, or <code class="pcalibre1 pcalibre literal">abs(item)</code>, or
<code class="pcalibre1 pcalibre literal">item["gpa"]</code>.</p>
<p class="pcalibre1 pcalibre calibre7">It turns out we can abstract out that calculation, using what we’ll
call a <em class="pcalibre1 calibre8 pcalibre">key function</em>. A key function is a function that takes exactly
one argument - an element in the list. It returns the derived value
used in the comparison. In fact, <code class="pcalibre1 pcalibre literal">int</code> works like a function, even
though it’s technically a type, because <code class="pcalibre1 pcalibre literal">int("42")</code> returns
<code class="pcalibre1 pcalibre literal">42</code>.<sup class="pcalibre1 pcalibre noteref">[<a href="#calibre_link-152" id="calibre_link-157" type="noteref" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">5</a>]</sup>  So types and other callables work, as long
as we can invoke it like a one-argument function.</p>
<p class="pcalibre1 pcalibre calibre7">This lets us define a very generic max function:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre18">def</span> max_by_key(items, key):
...     biggest = items[0]
...     <span class="pcalibre1 pcalibre calibre18">for</span> item <span class="pcalibre1 pcalibre calibre18">in</span> items[1:]:
...         <span class="pcalibre1 pcalibre calibre18">if</span> key(item) &gt; key(biggest):
...             biggest = item
...     <span class="pcalibre1 pcalibre calibre18">return</span> biggest
...
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13"># Old way:</span>
... max_by_int_value(nums)
<span class="pcalibre1 pcalibre calibre13">'30'</span>
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13"># New way:</span>
... max_by_key(nums, int)
<span class="pcalibre1 pcalibre calibre13">'30'</span>
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13"># Old way:</span>
... max_by_abs(integers)
-20
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13"># New way:</span>
... max_by_key(integers, abs)
-20</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Pay attention: you are passing the function object itself - <code class="pcalibre1 pcalibre literal">int</code> and
<code class="pcalibre1 pcalibre literal">abs</code>. You are <em class="pcalibre1 calibre8 pcalibre">not</em> invoking the key function in any direct way. In
other words, you write <code class="pcalibre1 pcalibre literal">int</code>, not <code class="pcalibre1 pcalibre literal">int()</code>. This function object is
then called as needed by <code class="pcalibre1 pcalibre literal">max_by_key</code>, to calculate the derived value:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>        <span class="pcalibre1 pcalibre calibre13"># key is actually int, abs, etc.</span>
        <span class="pcalibre1 pcalibre calibre18">if</span> key(item) &gt; key(biggest):</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">For sorting the students by GPA, we need a function extracting the
"gpa" key from each student dictionary. There is no built-in function
that does this, but we can define our own and pass it in:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13"># Old way:</span>
... max_by_gpa(students)
{<span class="pcalibre1 pcalibre calibre13">'gpa'</span>: 3.8, <span class="pcalibre1 pcalibre calibre13">'name'</span>: <span class="pcalibre1 pcalibre calibre13">'Jane Jones'</span>, <span class="pcalibre1 pcalibre calibre13">'major'</span>: <span class="pcalibre1 pcalibre calibre13">'chemistry'</span>}

&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13"># New way:</span>
... <span class="pcalibre1 pcalibre calibre18">def</span> get_gpa(who):
...     <span class="pcalibre1 pcalibre calibre18">return</span> who[<span class="pcalibre1 pcalibre calibre13">"gpa"</span>]
...
&gt;&gt;&gt; max_by_key(students, get_gpa)
{<span class="pcalibre1 pcalibre calibre13">'gpa'</span>: 3.8, <span class="pcalibre1 pcalibre calibre13">'name'</span>: <span class="pcalibre1 pcalibre calibre13">'Jane Jones'</span>, <span class="pcalibre1 pcalibre calibre13">'major'</span>: <span class="pcalibre1 pcalibre calibre13">'chemistry'</span>}</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Again, notice <code class="pcalibre1 pcalibre literal">get_gpa</code> is a function object, and we are passing that
function itself to <code class="pcalibre1 pcalibre literal">max_by_key</code>. We never invoke <code class="pcalibre1 pcalibre literal">get_gpa</code> directly;
<code class="pcalibre1 pcalibre literal">max_by_key</code> does that automatically.</p>
<p class="pcalibre1 pcalibre calibre7">You may be realizing now just how powerful this can be. In Python,
functions are simply objects - just as much as an integer, or a
string, or an instance of a class is an object. You can store
functions in variables; pass them as arguments to other functions; and
even return them from other function and method calls. This all
provides new ways for you to encapsulate and control the behavior of
your code.</p>
<p class="pcalibre1 pcalibre calibre7">The Python standard library demonstrates some excellent ways to use
such functional patterns. Let’s look at a key (ha!) example.</p>
</section>
<section class="calibre2 pcalibre1 pcalibre" title="Key Functions in Python">
<h2 id="calibre_link-82" class="pcalibre1 pcalibre calibre1">Key Functions in Python</h2>
<p class="pcalibre1 pcalibre calibre7">

Earlier, we saw the built-in <code class="pcalibre1 pcalibre literal">max</code> doesn’t magically do what we want
when sorting a list of numbers-as-strings:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; nums = [<span class="pcalibre1 pcalibre calibre13">"12"</span>, <span class="pcalibre1 pcalibre calibre13">"7"</span>, <span class="pcalibre1 pcalibre calibre13">"30"</span>, <span class="pcalibre1 pcalibre calibre13">"14"</span>, <span class="pcalibre1 pcalibre calibre13">"3"</span>]
&gt;&gt;&gt; max(nums)
<span class="pcalibre1 pcalibre calibre13">'7'</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Again, this isn’t a bug - <code class="pcalibre1 pcalibre literal">max</code> just compares elements according to
the data type, and <code class="pcalibre1 pcalibre literal">"7" &gt; "12"</code> evaluates to <code class="pcalibre1 pcalibre literal">True</code>. But it turns out
<code class="pcalibre1 pcalibre literal">max</code> is customizable. You can pass it a key function!</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; max(nums, key=int)
<span class="pcalibre1 pcalibre calibre13">'30'</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">The value of <code class="pcalibre1 pcalibre literal">key</code> is a function taking one argument - an element in
the list - and returning a value for comparison. But <code class="pcalibre1 pcalibre literal">max</code> isn’t the
only built-in accepting a key function. <code class="pcalibre1 pcalibre literal">min</code> and <code class="pcalibre1 pcalibre literal">sorted</code> do as well:</p>
<p class="pcalibre1 pcalibre calibre7">

</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13"># Default behavior...</span>
... min(nums)
<span class="pcalibre1 pcalibre calibre13">'12'</span>
&gt;&gt;&gt; sorted(nums)
[<span class="pcalibre1 pcalibre calibre13">'12'</span>, <span class="pcalibre1 pcalibre calibre13">'14'</span>, <span class="pcalibre1 pcalibre calibre13">'3'</span>, <span class="pcalibre1 pcalibre calibre13">'30'</span>, <span class="pcalibre1 pcalibre calibre13">'7'</span>]
&gt;&gt;&gt;
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13"># And with a key function:</span>
... min(nums, key=int)
<span class="pcalibre1 pcalibre calibre13">'3'</span>
&gt;&gt;&gt; sorted(nums, key=int)
[<span class="pcalibre1 pcalibre calibre13">'3'</span>, <span class="pcalibre1 pcalibre calibre13">'7'</span>, <span class="pcalibre1 pcalibre calibre13">'12'</span>, <span class="pcalibre1 pcalibre calibre13">'14'</span>, <span class="pcalibre1 pcalibre calibre13">'30'</span>]</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Many algorithms can be cleanly expressed using <code class="pcalibre1 pcalibre literal">min</code>, <code class="pcalibre1 pcalibre literal">max</code>, or
<code class="pcalibre1 pcalibre literal">sorted</code>, along with an appropriate key function. Sometimes a built-in
(like <code class="pcalibre1 pcalibre literal">int</code> or <code class="pcalibre1 pcalibre literal">abs</code>) will provide what you need, but often you’ll
want to create a custom function. Since this is so commonly needed,
the <code class="pcalibre1 pcalibre literal">operator</code> module provides some helpers. Let’s revisit the example
of a list of student records.
</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; student_joe = {<span class="pcalibre1 pcalibre calibre13">'gpa'</span>: 3.7, <span class="pcalibre1 pcalibre calibre13">'major'</span>: <span class="pcalibre1 pcalibre calibre13">'physics'</span>,
        <span class="pcalibre1 pcalibre calibre13">'name'</span>: <span class="pcalibre1 pcalibre calibre13">'Joe Smith'</span>}
&gt;&gt;&gt; student_jane = {<span class="pcalibre1 pcalibre calibre13">'gpa'</span>: 3.8, <span class="pcalibre1 pcalibre calibre13">'major'</span>: <span class="pcalibre1 pcalibre calibre13">'chemistry'</span>,
        <span class="pcalibre1 pcalibre calibre13">'name'</span>: <span class="pcalibre1 pcalibre calibre13">'Jane Jones'</span>}
&gt;&gt;&gt; student_zoe = {<span class="pcalibre1 pcalibre calibre13">'gpa'</span>: 3.4, <span class="pcalibre1 pcalibre calibre13">'major'</span>: <span class="pcalibre1 pcalibre calibre13">'literature'</span>,
        <span class="pcalibre1 pcalibre calibre13">'name'</span>: <span class="pcalibre1 pcalibre calibre13">'Zoe Fox'</span>}
&gt;&gt;&gt; students = [student_joe, student_jane, student_zoe]
&gt;&gt;&gt;
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre18">def</span> get_gpa(who):
...     <span class="pcalibre1 pcalibre calibre18">return</span> who[<span class="pcalibre1 pcalibre calibre13">"gpa"</span>]
...
&gt;&gt;&gt; sorted(students, key=get_gpa)
[{<span class="pcalibre1 pcalibre calibre13">'gpa'</span>: 3.4, <span class="pcalibre1 pcalibre calibre13">'major'</span>: <span class="pcalibre1 pcalibre calibre13">'literature'</span>, <span class="pcalibre1 pcalibre calibre13">'name'</span>: <span class="pcalibre1 pcalibre calibre13">'Zoe Fox'</span>},
 {<span class="pcalibre1 pcalibre calibre13">'gpa'</span>: 3.7, <span class="pcalibre1 pcalibre calibre13">'major'</span>: <span class="pcalibre1 pcalibre calibre13">'physics'</span>, <span class="pcalibre1 pcalibre calibre13">'name'</span>: <span class="pcalibre1 pcalibre calibre13">'Joe Smith'</span>},
 {<span class="pcalibre1 pcalibre calibre13">'gpa'</span>: 3.8, <span class="pcalibre1 pcalibre calibre13">'major'</span>: <span class="pcalibre1 pcalibre calibre13">'chemistry'</span>, <span class="pcalibre1 pcalibre calibre13">'name'</span>: <span class="pcalibre1 pcalibre calibre13">'Jane Jones'</span>}]</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">This is effective, and a fine way to solve the problem. Alternatively,
the <code class="pcalibre1 pcalibre literal">operator</code> module’s <code class="pcalibre1 pcalibre literal">itemgetter</code> creates and
returns a key function that looks up a named dictionary field:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre18">from</span> <span class="pcalibre1 pcalibre calibre18">operator</span> <span class="pcalibre1 pcalibre calibre18">import</span> itemgetter
&gt;&gt;&gt;
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13"># Sort by GPA...</span>
... sorted(students, key=itemgetter(<span class="pcalibre1 pcalibre calibre13">"gpa"</span>))
[{<span class="pcalibre1 pcalibre calibre13">'gpa'</span>: 3.4, <span class="pcalibre1 pcalibre calibre13">'major'</span>: <span class="pcalibre1 pcalibre calibre13">'literature'</span>, <span class="pcalibre1 pcalibre calibre13">'name'</span>: <span class="pcalibre1 pcalibre calibre13">'Zoe Fox'</span>},
 {<span class="pcalibre1 pcalibre calibre13">'gpa'</span>: 3.7, <span class="pcalibre1 pcalibre calibre13">'major'</span>: <span class="pcalibre1 pcalibre calibre13">'physics'</span>, <span class="pcalibre1 pcalibre calibre13">'name'</span>: <span class="pcalibre1 pcalibre calibre13">'Joe Smith'</span>},
 {<span class="pcalibre1 pcalibre calibre13">'gpa'</span>: 3.8, <span class="pcalibre1 pcalibre calibre13">'major'</span>: <span class="pcalibre1 pcalibre calibre13">'chemistry'</span>, <span class="pcalibre1 pcalibre calibre13">'name'</span>: <span class="pcalibre1 pcalibre calibre13">'Jane Jones'</span>}]
&gt;&gt;&gt;
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13"># Now sort by major:</span>
... sorted(students, key=itemgetter(<span class="pcalibre1 pcalibre calibre13">"major"</span>))
[{<span class="pcalibre1 pcalibre calibre13">'gpa'</span>: 3.8, <span class="pcalibre1 pcalibre calibre13">'major'</span>: <span class="pcalibre1 pcalibre calibre13">'chemistry'</span>, <span class="pcalibre1 pcalibre calibre13">'name'</span>: <span class="pcalibre1 pcalibre calibre13">'Jane Jones'</span>},
 {<span class="pcalibre1 pcalibre calibre13">'gpa'</span>: 3.4, <span class="pcalibre1 pcalibre calibre13">'major'</span>: <span class="pcalibre1 pcalibre calibre13">'literature'</span>, <span class="pcalibre1 pcalibre calibre13">'name'</span>: <span class="pcalibre1 pcalibre calibre13">'Zoe Fox'</span>},
 {<span class="pcalibre1 pcalibre calibre13">'gpa'</span>: 3.7, <span class="pcalibre1 pcalibre calibre13">'major'</span>: <span class="pcalibre1 pcalibre calibre13">'physics'</span>, <span class="pcalibre1 pcalibre calibre13">'name'</span>: <span class="pcalibre1 pcalibre calibre13">'Joe Smith'</span>}]</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Notice <code class="pcalibre1 pcalibre literal">itemgetter</code> is a function that creates and returns a
function - itself a good example of how to work with function
objects. In other words, the following two key functions are
completely equivalent:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre13"># What we did above:</span>
<span class="pcalibre1 pcalibre calibre18">def</span> get_gpa(who):
    <span class="pcalibre1 pcalibre calibre18">return</span> who[<span class="pcalibre1 pcalibre calibre13">"gpa"</span>]

<span class="pcalibre1 pcalibre calibre13"># Using itemgetter instead:</span>
<span class="pcalibre1 pcalibre calibre18">from</span> <span class="pcalibre1 pcalibre calibre18">operator</span> <span class="pcalibre1 pcalibre calibre18">import</span> itemgetter
get_gpa = itemgetter(<span class="pcalibre1 pcalibre calibre13">"gpa"</span>)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">This is how you use <code class="pcalibre1 pcalibre literal">itemgetter</code> when the sequence elements are
dictionaries. It also works when the elements are tuples or lists -
just pass a number index instead:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13"># Same data, but as a list of tuples.</span>
... student_rows = [
...      (<span class="pcalibre1 pcalibre calibre13">"Joe Smith"</span>, <span class="pcalibre1 pcalibre calibre13">"physics"</span>, 3.7),
...      (<span class="pcalibre1 pcalibre calibre13">"Jane Jones"</span>, <span class="pcalibre1 pcalibre calibre13">"chemistry"</span>, 3.8),
...      (<span class="pcalibre1 pcalibre calibre13">"Zoe Fox"</span>, <span class="pcalibre1 pcalibre calibre13">"literature"</span>, 3.4),
...      ]
&gt;&gt;&gt;
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13"># GPA is the 3rd item in the tuple, i.e. index 2.</span>
... <span class="pcalibre1 pcalibre calibre13"># Highest GPA:</span>
... max(student_rows, key=itemgetter(2))
(<span class="pcalibre1 pcalibre calibre13">'Jane Jones'</span>, <span class="pcalibre1 pcalibre calibre13">'chemistry'</span>, 3.8)
&gt;&gt;&gt;
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13"># Sort by major:</span>
... sorted(student_rows, key=itemgetter(1))
[(<span class="pcalibre1 pcalibre calibre13">'Jane Jones'</span>, <span class="pcalibre1 pcalibre calibre13">'chemistry'</span>, 3.8),
 (<span class="pcalibre1 pcalibre calibre13">'Zoe Fox'</span>, <span class="pcalibre1 pcalibre calibre13">'literature'</span>, 3.4),
 (<span class="pcalibre1 pcalibre calibre13">'Joe Smith'</span>, <span class="pcalibre1 pcalibre calibre13">'physics'</span>, 3.7)]</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7"><code class="pcalibre1 pcalibre literal">operator</code> also provides <code class="pcalibre1 pcalibre literal">attrgetter</code>, for
keying off an attribute of the element, and
<code class="pcalibre1 pcalibre literal">methodcaller</code> for keying off a method’s
return value - useful when the sequence elements are instances of your
own class:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre18">class</span> <span class="pcalibre1 pcalibre calibre18">Student</span>:
...     <span class="pcalibre1 pcalibre calibre18">def</span> __init__(self, name, major, gpa):
...         self.name = name
...         self.major = major
...         self.gpa = gpa
...     <span class="pcalibre1 pcalibre calibre18">def</span> __repr__(self):
...         <span class="pcalibre1 pcalibre calibre18">return</span> <span class="pcalibre1 pcalibre calibre13">"{}: {}"</span>.format(self.name, self.gpa)
...
&gt;&gt;&gt; student_objs = [
...      Student(<span class="pcalibre1 pcalibre calibre13">"Joe Smith"</span>, <span class="pcalibre1 pcalibre calibre13">"physics"</span>, 3.7),
...      Student(<span class="pcalibre1 pcalibre calibre13">"Jane Jones"</span>, <span class="pcalibre1 pcalibre calibre13">"chemistry"</span>, 3.8),
...      Student(<span class="pcalibre1 pcalibre calibre13">"Zoe Fox"</span>, <span class="pcalibre1 pcalibre calibre13">"literature"</span>, 3.4),
...      ]
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre18">from</span> <span class="pcalibre1 pcalibre calibre18">operator</span> <span class="pcalibre1 pcalibre calibre18">import</span> attrgetter
&gt;&gt;&gt; sorted(student_objs, key=attrgetter(<span class="pcalibre1 pcalibre calibre13">"gpa"</span>))
[Zoe Fox: 3.4, Joe Smith: 3.7, Jane Jones: 3.8]</code></pre>
</figure>
</section>
<footer class="pcalibre1 pcalibre calibre15">
<div class="calibre16 pcalibre1 pcalibre"></div><div class="pcalibre1 pcalibre chapter-footer">
<div class="pcalibre1 pcalibre footnotes">
<aside id="calibre_link-148" type="footnote" class="calibre2 pcalibre1 pcalibre">
<p class="pcalibre1 calibre17 pcalibre"><sup class="noteref1 pcalibre1 pcalibre"><a href="#calibre_link-153" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">1</a></sup> This seems to be deeply ingrained; once I abbreviated it <code class="pcalibre1 pcalibre literal">*a</code>, only to have my code reviewer demand I change it to <code class="pcalibre1 pcalibre literal">*args</code>. They wouldn’t approve it until I changed it, so I did.</p>
</aside>
<aside id="calibre_link-149" type="footnote" class="calibre2 pcalibre1 pcalibre">
<p class="pcalibre1 calibre17 pcalibre"><sup class="noteref1 pcalibre1 pcalibre"><a href="#calibre_link-154" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">2</a></sup> Or <code class="pcalibre1 pcalibre literal">.viewitems()</code>, if you’re using Python 2.</p>
</aside>
<aside id="calibre_link-150" type="footnote" class="calibre2 pcalibre1 pcalibre">
<p class="pcalibre1 calibre17 pcalibre"><sup class="noteref1 pcalibre1 pcalibre"><a href="#calibre_link-155" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">3</a></sup> These are newly available in Python 3. For Python 2, it’s an error to define a function with any regular arguments after <code class="pcalibre1 pcalibre literal">*args</code>.</p>
</aside>
<aside id="calibre_link-151" type="footnote" class="calibre2 pcalibre1 pcalibre">
<p class="pcalibre1 calibre17 pcalibre"><sup class="noteref1 pcalibre1 pcalibre"><a href="#calibre_link-156" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">4</a></sup> Meaning, alphabetically, but generalizing beyond the letters of the alphabet.</p>
</aside>
<aside id="calibre_link-152" type="footnote" class="calibre2 pcalibre1 pcalibre">
<p class="pcalibre1 calibre17 pcalibre"><sup class="noteref1 pcalibre1 pcalibre"><a href="#calibre_link-157" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">5</a></sup> Python uses the word <em class="pcalibre1 calibre8 pcalibre">callable</em> to describe something that can be invoked like a function. This can be an actual function, a type or class name, or an object defining the <code class="pcalibre1 pcalibre literal">__call__</code> magic method. Key functions are frequently actual functions, but can be any callable.</p>
</aside>
</div>
</div>
</footer>
</section>
</div>


<div id="calibre_link-6" class="pcalibre1 pcalibre calibre">
<section class="calibre2 pcalibre1 pcalibre" id="calibre_link-177" title="Decorators" type="chapter">
<header id="calibre_link-83" class="calibre2 pcalibre1 pcalibre">
<div class="pcalibre1 pcalibre chapter-header">
<h1 class="pcalibre1 chapter-title pcalibre"> <small class="subtitle pcalibre1 pcalibre"><b class="pcalibre1 pcalibre calibre6">DECORATORS</b></small></h1>
</div>
</header>
<p class="pcalibre1 pcalibre calibre7">
Python supports a powerful tool called the <em class="pcalibre1 calibre8 pcalibre">decorator</em>.  Decorators
let you add rich features to groups of functions and classes, without
modifying them at all; untangle distinct, frustratingly intertwined
concerns in your code, in ways not otherwise possible; and build
powerful, extensible software frameworks. Many of the most popular and
important Python libraries in the world leverage decorators. This
chapter teaches you how to do the same.</p>
<p class="pcalibre1 pcalibre calibre7">A decorator is something you apply to a function or method. You’ve
probably seen decorators before. There’s a decorator called
<code class="pcalibre1 pcalibre literal">property</code> often used in classes:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre18">class</span> <span class="pcalibre1 pcalibre calibre18">Person</span>:
...     <span class="pcalibre1 pcalibre calibre18">def</span> __init__(self, first_name, last_name):
...         self.first_name = first_name
...         self.last_name = last_name
...
...     @property
...     <span class="pcalibre1 pcalibre calibre18">def</span> full_name(self):
...         <span class="pcalibre1 pcalibre calibre18">return</span> self.first_name + <span class="pcalibre1 pcalibre calibre13">" "</span> + self.last_name
...
&gt;&gt;&gt; person = Person(<span class="pcalibre1 pcalibre calibre13">"John"</span>, <span class="pcalibre1 pcalibre calibre13">"Smith"</span>)
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre18">print</span>(person.full_name)
John Smith</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">(Note what’s printed: <code class="pcalibre1 pcalibre literal">person.full_name</code>, not <code class="pcalibre1 pcalibre literal">person.full_name()</code>.)
Another example: in the Flask web framework, here is
how you define a simple home page:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>@app.route(<span class="pcalibre1 pcalibre calibre13">"/"</span>)
<span class="pcalibre1 pcalibre calibre18">def</span> hello():
    <span class="pcalibre1 pcalibre calibre18">return</span> <span class="pcalibre1 pcalibre calibre13">"&lt;html&gt;&lt;body&gt;Hello World!&lt;/body&gt;&lt;/html&gt;"</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">The <code class="pcalibre1 pcalibre literal">app.route("/")</code> is a decorator, applied here to the function
called <code class="pcalibre1 pcalibre literal">hello</code>.  So an HTTP GET request to the root URL ("/") will be
handled by the <code class="pcalibre1 pcalibre literal">hello</code> function.</p>
<p class="pcalibre1 pcalibre calibre7">A decorator works by <strong class="pcalibre1 pcalibre calibre9">adding behavior <em class="pcalibre1 calibre8 pcalibre">around</em></strong> a function - meaning,
lines of code which are executed before that function begins, after it
returns, or both. It does not alter any lines of code <em class="pcalibre1 calibre8 pcalibre">inside</em> the
function. Typically, when you go to the trouble to define a decorator,
you plan use it on at least two different functions, usually
more. Otherwise you’d just put the extra code inside the lone
function, and not bother writing a decorator.</p>
<p class="pcalibre1 pcalibre calibre7">Using decorators is simple and easy; even someone new to programming
can learn that quickly. Our objective is different: to give you the
ability to <em class="pcalibre1 calibre8 pcalibre">write</em> your own decorators, in many different useful
forms. This is not a beginner topic; it barely qualifies as
intermediate. It requires a deep understanding of several
sophisticated Python features, and how they play together. Most Python
developers never learn how to create them. In this chapter, you
will.<sup class="pcalibre1 pcalibre noteref">[<a href="#calibre_link-7" id="calibre_link-15" type="noteref" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">1</a>]</sup></p>
<section class="calibre2 pcalibre1 pcalibre" title="The Basic Decorator">
<h2 id="calibre_link-84" class="pcalibre1 pcalibre calibre1">The Basic Decorator</h2>
<p class="pcalibre1 pcalibre calibre7">Once a decorator is written, using it is easy. You just write <code class="pcalibre1 pcalibre literal">@</code> and
the decorator name, on the line before you define a function:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>@some_decorator
<span class="pcalibre1 pcalibre calibre18">def</span> some_function(arg):
    <span class="pcalibre1 pcalibre calibre13"># blah blah</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">This applies the decorator called <code class="pcalibre1 pcalibre literal">some_decorator</code> to
<code class="pcalibre1 pcalibre literal">some_function</code>.<sup class="pcalibre1 pcalibre noteref">[<a href="#calibre_link-8" id="calibre_link-16" type="noteref" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">2</a>]</sup> Now, it turns out this syntax with the @
symbol is a shorthand.  In essence, when byte-compiling your code,
Python will translate the above into this:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">def</span> some_function(arg):
    <span class="pcalibre1 pcalibre calibre13"># blah blah</span>
some_function = some_decorator(some_function)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">This is valid Python code too, and what people did before the <code class="pcalibre1 pcalibre literal">@</code>
syntax came along. The key here is the last line:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>some_function = some_decorator(some_function)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">
First, understand that <strong class="pcalibre1 pcalibre calibre9">a decorator is just a function</strong>. That’s it. It
happens to be a function taking one argument, which is the function
object being decorated. It then returns a different function. In the
code snippet above is you defining a function, initially called
<code class="pcalibre1 pcalibre literal">some_function</code>. That function object is passed to <code class="pcalibre1 pcalibre literal">some_decorator</code>,
which returns a <em class="pcalibre1 calibre8 pcalibre">different</em> function object, which is finally stored
in <code class="pcalibre1 pcalibre literal">some_function</code>.</p>
<p class="pcalibre1 pcalibre calibre7">To keep us sane, let’s define some terminology:</p>
<div class="pcalibre1 pcalibre itemized-list">
<ul class="pcalibre1 calibre14 pcalibre">
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">The <strong class="pcalibre1 pcalibre calibre9">decorator</strong> is what comes after the @. It’s a function.</span>
</li>
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">The <strong class="pcalibre1 pcalibre calibre9">bare function</strong> is what’s <code class="pcalibre1 pcalibre literal">def</code>​'ed on the next
line. It is, obviously, also a function.</span>
</li>
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">The end result is the <strong class="pcalibre1 pcalibre calibre9">decorated function</strong>. It’s the final function
you actually call in your code.<sup class="pcalibre1 pcalibre noteref">[<a href="#calibre_link-9" id="calibre_link-17" type="noteref" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">3</a>]</sup></span>
</li>
</ul>
</div>
<p class="pcalibre1 pcalibre calibre7">Your mastery of decorators will be most graceful if you remember one
thing: a decorator is just a normal, boring function. It happens to be
a function taking exactly one argument, which is itself a
function. And when called, the decorator returns a <em class="pcalibre1 calibre8 pcalibre">different</em>
function.</p>
<p class="pcalibre1 pcalibre calibre7">Let’s make this concrete. Here’s a simple decorator which logs a
message to stdout, every time the decorated function is called.</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">def</span> printlog(func):
    <span class="pcalibre1 pcalibre calibre18">def</span> wrapper(arg):
        <span class="pcalibre1 pcalibre calibre18">print</span>(<span class="pcalibre1 pcalibre calibre13">'CALLING: {}'</span>.format(func.__name__))
        <span class="pcalibre1 pcalibre calibre18">return</span> func(arg)
    <span class="pcalibre1 pcalibre calibre18">return</span> wrapper

@printlog
<span class="pcalibre1 pcalibre calibre18">def</span> foo(x):
    <span class="pcalibre1 pcalibre calibre18">print</span>(x + 2)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Notice this decorator creates a new function, called <code class="pcalibre1 pcalibre literal">wrapper</code>,
and returns that. This is then assigned to the variable
<code class="pcalibre1 pcalibre literal">foo</code>, replacing the undecorated, bare function:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre13"># Remember, this...</span>
@printlog
<span class="pcalibre1 pcalibre calibre18">def</span> foo(x):
    <span class="pcalibre1 pcalibre calibre18">print</span>(x + 2)

<span class="pcalibre1 pcalibre calibre13"># ...is the exact same as this:</span>
<span class="pcalibre1 pcalibre calibre18">def</span> foo(x):
    <span class="pcalibre1 pcalibre calibre18">print</span>(x + 2)
foo = printlog(foo)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Here’s the result:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; foo(3)
CALLING: foo
5</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">At a high level, the body of <code class="pcalibre1 pcalibre literal">printlog</code> does two things: define a
function called <code class="pcalibre1 pcalibre literal">wrapper</code>, then return it.  Many decorators will
follow that structure. Notice <code class="pcalibre1 pcalibre literal">printlog</code> does not modify the behavior
of the original function <code class="pcalibre1 pcalibre literal">foo</code> itself; all <code class="pcalibre1 pcalibre literal">wrapper</code> does is print a
message to standard out, before calling the original (bare)
function.</p>
<p class="pcalibre1 pcalibre calibre7">Once you’ve applied a decorator, the bare function isn’t directly
accessible anymore; you can’t call it in your code. Its name now
applies to the decorated version. But that decorated function
internally retains a reference to the bare function, calling it inside
<code class="pcalibre1 pcalibre literal">wrapper</code>.</p>
<p class="pcalibre1 pcalibre calibre7">This version of <code class="pcalibre1 pcalibre literal">printlog</code> has a big shortcoming, though. Look what
happens when I apply it to a different function:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; @printlog
... <span class="pcalibre1 pcalibre calibre18">def</span> baz(x, y):
...     <span class="pcalibre1 pcalibre calibre18">return</span> x ** y
...
&gt;&gt;&gt; baz(3,2)
Traceback (most recent call last):
  File <span class="pcalibre1 pcalibre calibre13">"&lt;stdin&gt;"</span>, line 1, <span class="pcalibre1 pcalibre calibre18">in</span> &lt;module&gt;
<span class="pcalibre1 pcalibre calibre18">TypeError</span>: wrapper() takes 1 positional argument but 2 were given</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Can you spot what went wrong?</p>
<p class="pcalibre1 pcalibre calibre7"><code class="pcalibre1 pcalibre literal">printlog</code> is built to wrap a function taking exactly one
argument. But <code class="pcalibre1 pcalibre literal">baz</code> has two, so when the decorated function is called,
the whole thing blows up. There’s no reason <code class="pcalibre1 pcalibre literal">printlog</code> needs to have
this restriction; all it’s doing is printing the function name. You
fix it by declaring <code class="pcalibre1 pcalibre literal">wrapper</code> with variable arguments:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre13"># A MUCH BETTER printlog.</span>
<span class="pcalibre1 pcalibre calibre18">def</span> printlog(func):
    <span class="pcalibre1 pcalibre calibre18">def</span> wrapper(*args, **kwargs):
        <span class="pcalibre1 pcalibre calibre18">print</span>(<span class="pcalibre1 pcalibre calibre13">'CALLING: {}'</span>.format(func.__name__))
        <span class="pcalibre1 pcalibre calibre18">return</span> func(*args, **kwargs)
    <span class="pcalibre1 pcalibre calibre18">return</span> wrapper</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">This decorator is compatible with <em class="pcalibre1 calibre8 pcalibre">any</em> Python function:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; @printlog
... <span class="pcalibre1 pcalibre calibre18">def</span> foo(x):
...     <span class="pcalibre1 pcalibre calibre18">print</span>(x + 2)
...
&gt;&gt;&gt; @printlog
... <span class="pcalibre1 pcalibre calibre18">def</span> baz(x, y):
...     <span class="pcalibre1 pcalibre calibre18">return</span> x ** y
...
&gt;&gt;&gt; foo(7)
CALLING: foo
9
&gt;&gt;&gt; baz(3, 2)
CALLING: baz
9</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">A decorator written this way, using variable arguments, will
potentially work with functions and methods written <em class="pcalibre1 calibre8 pcalibre">years</em> later - code
the original developer never imagined. This structure has proven very
powerful and versatile.</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre13"># The prototypical form of Python decorators.</span>
<span class="pcalibre1 pcalibre calibre18">def</span> prototype_decorator(func):
    <span class="pcalibre1 pcalibre calibre18">def</span> wrapper(*args, **kwargs):
        <span class="pcalibre1 pcalibre calibre18">return</span> func(*args, **kwargs)
    <span class="pcalibre1 pcalibre calibre18">return</span> wrapper</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">We don’t always do this, though. Sometimes you are writing a decorator
that only applies to a function or method with a very specific kind of
signature, and it would be an error to use it anywhere else. So feel
free to break this rule when you have a reason.</p>
<p class="pcalibre1 pcalibre calibre7">Decorators apply to methods just as well as to functions. And you
often don’t need to change anything: when the wrapper has a
signature of <code class="pcalibre1 pcalibre literal">wrapper(*args, **kwargs)</code>, like <code class="pcalibre1 pcalibre literal">printlog</code> does, it
works just fine with any object’s method. But sometimes you will see
code like this:

</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre13"># Not really necessary.</span>
<span class="pcalibre1 pcalibre calibre18">def</span> printlog_for_method(func):
    <span class="pcalibre1 pcalibre calibre18">def</span> wrapper(self, *args, **kwargs):
        <span class="pcalibre1 pcalibre calibre18">print</span>(<span class="pcalibre1 pcalibre calibre13">'CALLING: {}'</span>.format(func.__name__))
        <span class="pcalibre1 pcalibre calibre18">return</span> func(self, *args, **kwargs)
    <span class="pcalibre1 pcalibre calibre18">return</span> wrapper</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">This is a bit interesting. This <code class="pcalibre1 pcalibre literal">wrapper</code> has one required argument,
named <code class="pcalibre1 pcalibre literal">self</code>. And it works fine when applied to a method. But for the
decorator I’ve written here, that <code class="pcalibre1 pcalibre literal">self</code> is completely unnecessary,
and in fact has a downside.</p>
<p class="pcalibre1 pcalibre calibre7">Simply defining <code class="pcalibre1 pcalibre literal">wrapper(*args, **kwargs)</code> causes <code class="pcalibre1 pcalibre literal">self</code> to be
considered one of the <code class="pcalibre1 pcalibre literal">args</code>; such a decorator works just as well with
both functions and methods.  But if a wrapper is defined to require
<code class="pcalibre1 pcalibre literal">self</code>, that means it must always be called with at least one
argument. Suddenly you have a decorator that cannot be applied to
functions without at least one argument. (That it’s named <code class="pcalibre1 pcalibre literal">self</code>
doesn’t matter; it’s just a temporary name for that first argument,
inside the scope of <code class="pcalibre1 pcalibre literal">wrapper</code>.) You can apply this decorator to any
method, and to some functions. But if you apply it a function that
takes <em class="pcalibre1 calibre8 pcalibre">no</em> arguments, you’ll get a run-time error.</p>
<p class="pcalibre1 pcalibre calibre7">Now, here’s a different decorator:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre13"># This is more sensible.</span>
<span class="pcalibre1 pcalibre calibre18">def</span> enhanced_printlog_for_method(func):
    <span class="pcalibre1 pcalibre calibre18">def</span> wrapper(self, *args, **kwargs):
        <span class="pcalibre1 pcalibre calibre18">print</span>(<span class="pcalibre1 pcalibre calibre13">'CALLING: {} on object ID {}'</span>.format(
            func.__name__, id(self)))
        <span class="pcalibre1 pcalibre calibre18">return</span> func(self, *args, **kwargs)
    <span class="pcalibre1 pcalibre calibre18">return</span> wrapper</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">It could be applied like this:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">class</span> <span class="pcalibre1 pcalibre calibre18">Invoice</span>:
    <span class="pcalibre1 pcalibre calibre18">def</span> __init__(self, id_number, total):
        self.id_number = id_number
        self.total = total
        self.owed = total
    @enhanced_printlog_for_method
    <span class="pcalibre1 pcalibre calibre18">def</span> record_payment(self, amount):
        self.owed -= amount

inv = Invoice(42, 117.55)
<span class="pcalibre1 pcalibre calibre18">print</span>(<span class="pcalibre1 pcalibre calibre13">"ID of inv: {}"</span>.format(id(inv)))
inv.record_payment(55.35)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Here’s the output when you execute:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11">ID of inv: 4320786472
CALLING: record_payment on object ID 4320786472</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">This is a different story, because this <code class="pcalibre1 pcalibre literal">wrapper</code>​'s body
explicitly uses the current object - a concept that only makes sense
for methods. That makes the <code class="pcalibre1 pcalibre literal">self</code> argument perfectly appropriate. It
prevents you from using this decorator on some functions, but it would
actually be an error to apply it to a non-method anyway.</p>
<p class="pcalibre1 pcalibre calibre7">When writing a decorator for methods, I recommend you get in the habit
of making your wrapper only take <code class="pcalibre1 pcalibre literal">*args</code> and <code class="pcalibre1 pcalibre literal">**kwargs</code>, except
when you have a clear reason to do differently. After you’ve written
decorators for a while, you’ll be surprised at how often you end up
using old decorators on new functions, in ways you never imagined at
first. A signature of <code class="pcalibre1 pcalibre literal">wrapper(*args, **kwargs)</code> preserves that
flexibility. If the decorator turns out to need an explicit <code class="pcalibre1 pcalibre literal">self</code>
argument, it’s easy enough to put that in.</p>
</section>
<section class="calibre2 pcalibre1 pcalibre" title="Data In Decorators">
<h2 id="calibre_link-85" class="pcalibre1 pcalibre calibre1">Data In Decorators</h2>
<p class="pcalibre1 pcalibre calibre7">

Some of the most valuable decorator patterns rely on using variables
inside the decorator function itself. This is <em class="pcalibre1 calibre8 pcalibre">not</em> the same as using
variables inside the <em class="pcalibre1 calibre8 pcalibre">wrapper</em> function. Let me explain.</p>
<p class="pcalibre1 pcalibre calibre7">Imagine you need to keep a running average of what some function
returns. And further, you need to do this for a family of functions or
methods. We can write a decorator called <code class="pcalibre1 pcalibre literal">running_average</code> to handle
this - as you read, note carefully how <code class="pcalibre1 pcalibre literal">data</code> is defined and used:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">def</span> running_average(func):
    data = {<span class="pcalibre1 pcalibre calibre13">"total"</span> : 0, <span class="pcalibre1 pcalibre calibre13">"count"</span> : 0}
    <span class="pcalibre1 pcalibre calibre18">def</span> wrapper(*args, **kwargs):
        val = func(*args, **kwargs)
        data[<span class="pcalibre1 pcalibre calibre13">"total"</span>] += val
        data[<span class="pcalibre1 pcalibre calibre13">"count"</span>] += 1
        <span class="pcalibre1 pcalibre calibre18">print</span>(<span class="pcalibre1 pcalibre calibre13">"Average of {} so far: {:.01f}"</span>.format(
             func.__name__, data[<span class="pcalibre1 pcalibre calibre13">"total"</span>] / data[<span class="pcalibre1 pcalibre calibre13">"count"</span>]))
        <span class="pcalibre1 pcalibre calibre18">return</span> func(*args, **kwargs)
    <span class="pcalibre1 pcalibre calibre18">return</span> wrapper</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Each time the function is called, the average of all calls so far is
printed out.<sup class="pcalibre1 pcalibre noteref">[<a href="#calibre_link-10" id="calibre_link-18" type="noteref" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">4</a>]</sup> Decorator functions are
called once for each function they are applied to. Then, each time
that function is called in the code, the <code class="pcalibre1 pcalibre literal">wrapper</code> function is what’s
actually executed.  So imagine applying it to a function like this:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>@running_average
<span class="pcalibre1 pcalibre calibre18">def</span> foo(x):
    <span class="pcalibre1 pcalibre calibre18">return</span> x + 2</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">This creates an internal dictionary, named <code class="pcalibre1 pcalibre literal">data</code>, used to keep track
of <code class="pcalibre1 pcalibre literal">foo</code>​'s metrics. Running <code class="pcalibre1 pcalibre literal">foo</code> several times produces:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; foo(1)
Average of foo so far: 3.00
3
&gt;&gt;&gt; foo(10)
Average of foo so far: 7.50
12
&gt;&gt;&gt; foo(1)
Average of foo so far: 6.00
3
&gt;&gt;&gt; foo(1)
Average of foo so far: 5.25
3</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">The placement of <code class="pcalibre1 pcalibre literal">data</code> is important. Pop quiz:</p>
<div class="pcalibre1 pcalibre itemized-list">
<ul class="pcalibre1 calibre14 pcalibre">
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">What happens if you move the line defining <code class="pcalibre1 pcalibre literal">data</code> up one line,
outside the <code class="pcalibre1 pcalibre literal">running_average</code> function?</span>
</li>
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">What happens if you that line down, into the <code class="pcalibre1 pcalibre literal">wrapper</code> function?</span>
</li>
</ul>
</div>
<p class="pcalibre1 pcalibre calibre7">Looking at the code above, decide on your answers to these questions
before reading further.</p>
<p class="pcalibre1 pcalibre calibre7">Here’s what it looks like if you create <code class="pcalibre1 pcalibre literal">data</code> outside the decorator:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre13"># This version has a bug.</span>
data = {<span class="pcalibre1 pcalibre calibre13">"total"</span> : 0, <span class="pcalibre1 pcalibre calibre13">"count"</span> : 0}
<span class="pcalibre1 pcalibre calibre18">def</span> outside_data_running_average(func):
    <span class="pcalibre1 pcalibre calibre18">def</span> wrapper(*args, **kwargs):
        val = func(*args, **kwargs)
        data[<span class="pcalibre1 pcalibre calibre13">"total"</span>] += val
        data[<span class="pcalibre1 pcalibre calibre13">"count"</span>] += 1
        <span class="pcalibre1 pcalibre calibre18">print</span>(<span class="pcalibre1 pcalibre calibre13">"Average of {} so far: {:.01f}"</span>.format(
             func.__name__, data[<span class="pcalibre1 pcalibre calibre13">"total"</span>] / data[<span class="pcalibre1 pcalibre calibre13">"count"</span>]))
        <span class="pcalibre1 pcalibre calibre18">return</span> func(*args, **kwargs)
    <span class="pcalibre1 pcalibre calibre18">return</span> wrapper</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">If we do this, <em class="pcalibre1 calibre8 pcalibre">every</em> decorated function shares the exact same <code class="pcalibre1 pcalibre literal">data</code>
dictionary! This actually doesn’t matter if you only ever decorate
just one function.  But you never bother to write a decorator unless
it’s going to be applied to at least two:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>@outside_data_running_average
<span class="pcalibre1 pcalibre calibre18">def</span> foo(x):
    <span class="pcalibre1 pcalibre calibre18">return</span> x + 2

@outside_data_running_average
<span class="pcalibre1 pcalibre calibre18">def</span> bar(x):
    <span class="pcalibre1 pcalibre calibre18">return</span> 3 * x</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">And that produces a problem:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13"># First call to foo...</span>
... foo(1)
Average of foo so far: 3.0
3
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13"># First call to bar...</span>
... bar(10)
Average of bar so far: 16.5
30
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13"># Second foo should still average 3.00!</span>
... foo(1)
Average of foo so far: 12.0</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Because <code class="pcalibre1 pcalibre literal">outside_data_running_average</code> uses the <em class="pcalibre1 calibre8 pcalibre">same</em> <code class="pcalibre1 pcalibre literal">data</code>
dictionary for all the functions it decorates, the statistics are
conflated.</p>
<p class="pcalibre1 pcalibre calibre7">Now, the other situation: what if you define <code class="pcalibre1 pcalibre literal">data</code> inside <code class="pcalibre1 pcalibre literal">wrapper</code>?</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre13"># This version has a DIFFERENT bug.</span>
<span class="pcalibre1 pcalibre calibre18">def</span> running_average_data_in_wrapper(func):
    <span class="pcalibre1 pcalibre calibre18">def</span> wrapper(*args, **kwargs):
        data = {<span class="pcalibre1 pcalibre calibre13">"total"</span> : 0, <span class="pcalibre1 pcalibre calibre13">"count"</span> : 0}
        val = func(*args, **kwargs)
        data[<span class="pcalibre1 pcalibre calibre13">"total"</span>] += val
        data[<span class="pcalibre1 pcalibre calibre13">"count"</span>] += 1
        <span class="pcalibre1 pcalibre calibre18">print</span>(<span class="pcalibre1 pcalibre calibre13">"Average of {} so far: {:.01f}"</span>.format(
             func.__name__, data[<span class="pcalibre1 pcalibre calibre13">"total"</span>] / data[<span class="pcalibre1 pcalibre calibre13">"count"</span>]))
        <span class="pcalibre1 pcalibre calibre18">return</span> func(*args, **kwargs)
    <span class="pcalibre1 pcalibre calibre18">return</span> wrapper

@running_average_data_in_wrapper
<span class="pcalibre1 pcalibre calibre18">def</span> foo(x):
    <span class="pcalibre1 pcalibre calibre18">return</span> x + 2</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Look at the average as we call this decorated function multiple times:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; foo(1)
Average of foo so far: 3.0
3
&gt;&gt;&gt; foo(5)
Average of foo so far: 7.0
7
&gt;&gt;&gt; foo(20)
Average of foo so far: 22.0
22</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Do you see why the running average is wrong? The <code class="pcalibre1 pcalibre literal">data</code> dictionary is
reset <em class="pcalibre1 calibre8 pcalibre">every time the decorated function is called</em>. This is why it’s
important to consider the scope when implementing your
decorator. Here’s the correct version again (repeated so you don’t
have to skip back):</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">def</span> running_average(func):
    data = {<span class="pcalibre1 pcalibre calibre13">"total"</span> : 0, <span class="pcalibre1 pcalibre calibre13">"count"</span> : 0}
    <span class="pcalibre1 pcalibre calibre18">def</span> wrapper(*args, **kwargs):
        val = func(*args, **kwargs)
        data[<span class="pcalibre1 pcalibre calibre13">"total"</span>] += val
        data[<span class="pcalibre1 pcalibre calibre13">"count"</span>] += 1
        <span class="pcalibre1 pcalibre calibre18">print</span>(<span class="pcalibre1 pcalibre calibre13">"Average of {} so far: {:.01f}"</span>.format(
             func.__name__, data[<span class="pcalibre1 pcalibre calibre13">"total"</span>] / data[<span class="pcalibre1 pcalibre calibre13">"count"</span>]))
        <span class="pcalibre1 pcalibre calibre18">return</span> func(*args, **kwargs)
    <span class="pcalibre1 pcalibre calibre18">return</span> wrapper</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">So when exactly is <code class="pcalibre1 pcalibre literal">running_average</code> executed? The decorator function
itself is executed <strong class="pcalibre1 pcalibre calibre9">exactly once</strong> for <strong class="pcalibre1 pcalibre calibre9">every</strong> function it
decorates. If you decorate N functions, <code class="pcalibre1 pcalibre literal">running_average</code> is executed
N times, so we get N different <code class="pcalibre1 pcalibre literal">data</code> dictionaries, each tied to one
of the resulting decorated functions. This has nothing to do with how
many times a decorated function is executed. The decorated function
is, basically, one of the created <code class="pcalibre1 pcalibre literal">wrapper</code> functions. That <code class="pcalibre1 pcalibre literal">wrapper</code>
can be executed many times, using the same <code class="pcalibre1 pcalibre literal">data</code> dictionary that was
in scope when that <code class="pcalibre1 pcalibre literal">wrapper</code> was defined.</p>
<p class="pcalibre1 pcalibre calibre7">This is why <code class="pcalibre1 pcalibre literal">running_average</code> produces the correct behavior:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>@running_average
<span class="pcalibre1 pcalibre calibre18">def</span> foo(x):
    <span class="pcalibre1 pcalibre calibre18">return</span> x + 2

@running_average
<span class="pcalibre1 pcalibre calibre18">def</span> bar(x):
    <span class="pcalibre1 pcalibre calibre18">return</span> 3 * x</code></pre>
</figure>
<figure class="pcalibre1 pcalibre footnotes">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13"># First call to foo...</span>
... foo(1)
Average of foo so far: 3.0
3
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13"># First call to bar...</span>
... bar(10)
Average of bar so far: 30.0
30
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13"># Second foo gives correct average this time!</span>
... foo(1)
Average of foo so far: 3.0
3</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Now, what if you want to peek into <code class="pcalibre1 pcalibre literal">data</code>? The way we’ve written
<code class="pcalibre1 pcalibre literal">running_average</code>, you can’t. <code class="pcalibre1 pcalibre literal">data</code> persists because of the
reference inside of <code class="pcalibre1 pcalibre literal">wrapper</code>, but there is no way you can access it
directly in normal Python code. But when you <em class="pcalibre1 calibre8 pcalibre">do</em> need to do this,
there is a very easy solution: simply assign <code class="pcalibre1 pcalibre literal">data</code> as an attribute to
<code class="pcalibre1 pcalibre literal">wrapper</code>. For example:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre13"># collectstats is much like running_average, but lets</span>
<span class="pcalibre1 pcalibre calibre13"># you access the data dictionary directly, instead</span>
<span class="pcalibre1 pcalibre calibre13"># of printing it out.</span>
<span class="pcalibre1 pcalibre calibre18">def</span> collectstats(func):
    data = {<span class="pcalibre1 pcalibre calibre13">"total"</span> : 0, <span class="pcalibre1 pcalibre calibre13">"count"</span> : 0}
    <span class="pcalibre1 pcalibre calibre18">def</span> wrapper(*args, **kwargs):
        val = func(*args, **kwargs)
        data[<span class="pcalibre1 pcalibre calibre13">"total"</span>] += val
        data[<span class="pcalibre1 pcalibre calibre13">"count"</span>] += 1
        <span class="pcalibre1 pcalibre calibre18">return</span> func(*args, **kwargs)
    wrapper.data = data
    <span class="pcalibre1 pcalibre calibre18">return</span> wrapper</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">See that line <code class="pcalibre1 pcalibre literal">wrapper.data = data</code>?  Yes, you can do that. A function
in Python is just an object, and in Python, you can add new attributes
to objects by just assigning them. This conveniently annotates the
decorated function:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>@collectstats
<span class="pcalibre1 pcalibre calibre18">def</span> foo(x):
    <span class="pcalibre1 pcalibre calibre18">return</span> x + 2</code></pre>
</figure>
<figure class="pcalibre1 pcalibre footnotes">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; foo.data
{<span class="pcalibre1 pcalibre calibre13">'total'</span>: 0, <span class="pcalibre1 pcalibre calibre13">'count'</span>: 0}
&gt;&gt;&gt; foo(1)
3
&gt;&gt;&gt; foo.data
{<span class="pcalibre1 pcalibre calibre13">'total'</span>: 3, <span class="pcalibre1 pcalibre calibre13">'count'</span>: 1}
&gt;&gt;&gt; foo(2)
4
&gt;&gt;&gt; foo.data
{<span class="pcalibre1 pcalibre calibre13">'total'</span>: 7, <span class="pcalibre1 pcalibre calibre13">'count'</span>: 2}</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">It’s clear now why <code class="pcalibre1 pcalibre literal">collectstats</code> doesn’t contain any print statement:
you don’t need one! We can check the accumulated numbers at any time,
because this decorator annotates the function itself, with that <code class="pcalibre1 pcalibre literal">data</code>
attribute.</p>
<p class="pcalibre1 pcalibre calibre7">Let’s switch to a another problem you might run into, and how you
deal with it. Here’s an decorator that counts how many times a function
has been called:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre13"># Watch out, this has a bug...</span>
count = 0
<span class="pcalibre1 pcalibre calibre18">def</span> countcalls(func):
    <span class="pcalibre1 pcalibre calibre18">def</span> wrapper(*args, **kwargs):
        <span class="pcalibre1 pcalibre calibre18">global</span> count
        count += 1
        <span class="pcalibre1 pcalibre calibre18">print</span>(<span class="pcalibre1 pcalibre calibre13">'# of calls: {}'</span>.format(count))
        <span class="pcalibre1 pcalibre calibre18">return</span> func(*args, **kwargs)
    <span class="pcalibre1 pcalibre calibre18">return</span> wrapper

@countcalls
<span class="pcalibre1 pcalibre calibre18">def</span> foo(x): <span class="pcalibre1 pcalibre calibre18">return</span> x + 2

@countcalls
<span class="pcalibre1 pcalibre calibre18">def</span> bar(x): <span class="pcalibre1 pcalibre calibre18">return</span> 3 * x</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">This version of <code class="pcalibre1 pcalibre literal">countcalls</code> has a bug. Do you see it?</p>
<p class="pcalibre1 pcalibre calibre7">That’s right: it stores <code class="pcalibre1 pcalibre literal">count</code> as a global variable, meaning every
function that is decorated will use that same variable:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; foo(1)
<span class="pcalibre1 pcalibre calibre13"># of calls: 1</span>
3
&gt;&gt;&gt; foo(2)
<span class="pcalibre1 pcalibre calibre13"># of calls: 2</span>
4
&gt;&gt;&gt; bar(3)
<span class="pcalibre1 pcalibre calibre13"># of calls: 3</span>
9
&gt;&gt;&gt; bar(4)
<span class="pcalibre1 pcalibre calibre13"># of calls: 4</span>
12
&gt;&gt;&gt; foo(5)
<span class="pcalibre1 pcalibre calibre13"># of calls: 5</span>
7</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">The solution is trickier than it seems. Here’s one attempt:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre13"># Move count inside countcalls, and remove the</span>
<span class="pcalibre1 pcalibre calibre13"># "global count" line. But it still has a bug...</span>
<span class="pcalibre1 pcalibre calibre18">def</span> countcalls(func):
    count = 0
    <span class="pcalibre1 pcalibre calibre18">def</span> wrapper(*args, **kwargs):
        count += 1
        <span class="pcalibre1 pcalibre calibre18">print</span>(<span class="pcalibre1 pcalibre calibre13">'# of calls: {}'</span>.format(count))
        <span class="pcalibre1 pcalibre calibre18">return</span> func(*args, **kwargs)
    <span class="pcalibre1 pcalibre calibre18">return</span> wrapper</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">But that just creates a different problem:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; foo(1)
Traceback (most recent call last):
  File <span class="pcalibre1 pcalibre calibre13">"&lt;stdin&gt;"</span>, line 1, <span class="pcalibre1 pcalibre calibre18">in</span> &lt;module&gt;
  File <span class="pcalibre1 pcalibre calibre13">"&lt;stdin&gt;"</span>, line 6, <span class="pcalibre1 pcalibre calibre18">in</span> wrapper
<span class="pcalibre1 pcalibre calibre18">UnboundLocalError</span>: local variable <span class="pcalibre1 pcalibre calibre13">'count'</span> referenced before assignment</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">We can’t use <code class="pcalibre1 pcalibre literal">global</code>, because it’s not global. But in Python 3, we
can use the <code class="pcalibre1 pcalibre literal">nonlocal</code> keyword:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre13"># Final working version!</span>
<span class="pcalibre1 pcalibre calibre18">def</span> countcalls(func):
    count = 0
    <span class="pcalibre1 pcalibre calibre18">def</span> wrapper(*args, **kwargs):
        nonlocal count
        count += 1
        <span class="pcalibre1 pcalibre calibre18">print</span>(<span class="pcalibre1 pcalibre calibre13">'# of calls: {}'</span>.format(count))
        <span class="pcalibre1 pcalibre calibre18">return</span> func(*args, **kwargs)
    <span class="pcalibre1 pcalibre calibre18">return</span> wrapper</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">This finally works correctly:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; foo(1)
<span class="pcalibre1 pcalibre calibre13"># of calls: 1</span>
3
&gt;&gt;&gt; foo(2)
<span class="pcalibre1 pcalibre calibre13"># of calls: 2</span>
4
&gt;&gt;&gt; bar(3)
<span class="pcalibre1 pcalibre calibre13"># of calls: 1</span>
9
&gt;&gt;&gt; bar(4)
<span class="pcalibre1 pcalibre calibre13"># of calls: 2</span>
12
&gt;&gt;&gt; foo(5)
<span class="pcalibre1 pcalibre calibre13"># of calls: 3</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Applying <code class="pcalibre1 pcalibre literal">nonlocal</code> gives the <code class="pcalibre1 pcalibre literal">count</code> variable a
special scope that is part-way between local and global. Essentially,
Python will search for the nearest enclosing scope that defines a
variable named <code class="pcalibre1 pcalibre literal">count</code>, and use it like it’s a
global.<sup class="pcalibre1 pcalibre noteref">[<a href="#calibre_link-11" id="calibre_link-19" type="noteref" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">5</a>]</sup></p>
<p class="pcalibre1 pcalibre calibre7">You may be wondering why we didn’t need to use <code class="pcalibre1 pcalibre literal">nonlocal</code> with the
first version of <code class="pcalibre1 pcalibre literal">running_average</code> above - here it is again, for
reference:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">def</span> running_average(func):
    data = {<span class="pcalibre1 pcalibre calibre13">"total"</span> : 0, <span class="pcalibre1 pcalibre calibre13">"count"</span> : 0}
    <span class="pcalibre1 pcalibre calibre18">def</span> wrapper(*args, **kwargs):
        val = func(*args, **kwargs)
        data[<span class="pcalibre1 pcalibre calibre13">"total"</span>] += val
        data[<span class="pcalibre1 pcalibre calibre13">"count"</span>] += 1
        <span class="pcalibre1 pcalibre calibre18">print</span>(<span class="pcalibre1 pcalibre calibre13">"Average of {} so far: {:.01f}"</span>.format(
             func.__name__, data[<span class="pcalibre1 pcalibre calibre13">"total"</span>] / data[<span class="pcalibre1 pcalibre calibre13">"count"</span>]))
        <span class="pcalibre1 pcalibre calibre18">return</span> func(*args, **kwargs)
    <span class="pcalibre1 pcalibre calibre18">return</span> wrapper</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">When we have a line like <code class="pcalibre1 pcalibre literal">count += 1</code>, that’s actually modifying the
value of the <code class="pcalibre1 pcalibre literal">count</code> variable itself - because it really means <code class="pcalibre1 pcalibre literal">count =
count + 1</code>. And whenever you modify (instead of just read) a variable
that was created in a larger scope, Python requires you to declare
that’s what you actually want, with <code class="pcalibre1 pcalibre literal">global</code> or <code class="pcalibre1 pcalibre literal">nonlocal</code>.</p>
<p class="pcalibre1 pcalibre calibre7">Here’s the sneaky thing: when we write <code class="pcalibre1 pcalibre literal">data["count"] += 1</code>, <strong class="pcalibre1 pcalibre calibre9">that is
not actually modifying <code class="pcalibre1 pcalibre literal">data</code>!</strong> Or rather, it’s not modifying the
<em class="pcalibre1 calibre8 pcalibre">variable</em> named <code class="pcalibre1 pcalibre literal">data</code>, which points to a dictionary object.
Instead, the statement <code class="pcalibre1 pcalibre literal">data["count"] += 1</code> invokes a <em class="pcalibre1 calibre8 pcalibre">method</em> on the
<code class="pcalibre1 pcalibre literal">data</code> object. This does change the state of the dictionary, but it
doesn’t make <code class="pcalibre1 pcalibre literal">data</code> point to a <em class="pcalibre1 calibre8 pcalibre">different</em> dictionary. But <code class="pcalibre1 pcalibre literal">count +=1</code>
makes <code class="pcalibre1 pcalibre literal">count</code> point to a different integer, so we need to use
<code class="pcalibre1 pcalibre literal">nonlocal</code> there.</p>
<section class="calibre2 pcalibre1 pcalibre" title="Data in Decorators for Python 2">
<h3 id="calibre_link-178" class="pcalibre1 calibre21 pcalibre">Data in Decorators for Python 2</h3>
<p class="pcalibre1 pcalibre calibre7">The <code class="pcalibre1 pcalibre literal">nonlocal</code> keyword didn’t exist before version 3.0, so Python 2
has no way to say "this variable is partway between local and
global". But you have several workarounds.</p>
<p class="pcalibre1 pcalibre calibre7">My favorite technique is to assign the variable as an
attribute to the <code class="pcalibre1 pcalibre literal">wrapper</code> function:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">def</span> countcalls(func):
    <span class="pcalibre1 pcalibre calibre18">def</span> wrapper(*args, **kwargs):
        wrapper.count += 1
        <span class="pcalibre1 pcalibre calibre18">print</span>(<span class="pcalibre1 pcalibre calibre13">'# of calls: {}'</span>.format(wrapper.count))
        <span class="pcalibre1 pcalibre calibre18">return</span> func(*args, **kwargs)
    wrapper.count = 0
    <span class="pcalibre1 pcalibre calibre18">return</span> wrapper</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Instead of a variable named <code class="pcalibre1 pcalibre literal">count</code>, the <code class="pcalibre1 pcalibre literal">wrapper</code> function object
gets an attribute named <code class="pcalibre1 pcalibre literal">count</code>. So everywhere inside <code class="pcalibre1 pcalibre literal">wrapper</code>, I
reference the variable as <code class="pcalibre1 pcalibre literal">wrapper.count</code>. One interesting thing is
that this <code class="pcalibre1 pcalibre literal">wrapper.count</code> variable is initialized <em class="pcalibre1 calibre8 pcalibre">after</em> the function
is defined, just before the final <code class="pcalibre1 pcalibre literal">return</code> line in
<code class="pcalibre1 pcalibre literal">countcalls</code>. Python has no problem with this; the attribute doesn’t
exist when <code class="pcalibre1 pcalibre literal">wrapper</code> is defined, but so long as it exists when the
decorated function is <em class="pcalibre1 calibre8 pcalibre">called</em> for the first time, no error will
result.</p>
<p class="pcalibre1 pcalibre calibre7">This is my favorite solution, and what I use in my own Python 2
code. It’s not commonly used, however, so I will explain a couple of
other techniques you may see.  One is to use
<code class="pcalibre1 pcalibre literal">hasattr</code> to check whether <code class="pcalibre1 pcalibre literal">wrapper.count</code> exists
yet, and if not, initialize it:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">def</span> countcalls(func):
    <span class="pcalibre1 pcalibre calibre18">def</span> wrapper(*args, **kwargs):
        <span class="pcalibre1 pcalibre calibre18">if</span> <span class="pcalibre1 pcalibre calibre18">not</span> hasattr(wrapper, <span class="pcalibre1 pcalibre calibre13">'count'</span>):
            wrapper.count = 0
        wrapper.count += 1
        <span class="pcalibre1 pcalibre calibre18">print</span>(<span class="pcalibre1 pcalibre calibre13">'# of calls: {}'</span>.format(wrapper.count))
        <span class="pcalibre1 pcalibre calibre18">return</span> func(*args, **kwargs)
    <span class="pcalibre1 pcalibre calibre18">return</span> wrapper</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">This has a slight performance disadvantage, because <code class="pcalibre1 pcalibre literal">hasattr</code> will be
called every time the decorated function is invoked, while the first
approach does not. It’s unlikely to matter unless you’re deeply
inside some nested for-loop, though.</p>
<p class="pcalibre1 pcalibre calibre7">Alternatively - and this one has no performance disadvantage
- you can create a <code class="pcalibre1 pcalibre literal">list</code> object just outside of <code class="pcalibre1 pcalibre literal">wrapper</code>​'s scope,
and treat its first element like the variable you want to change:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">def</span> countcalls(func):
    count_container = [0]
    <span class="pcalibre1 pcalibre calibre18">def</span> wrapper(*args, **kwargs):
        <span class="pcalibre1 pcalibre calibre18">print</span>(<span class="pcalibre1 pcalibre calibre13">'# of calls: {}'</span>.format(count_container[0]))
        count_container[0] += 1
        <span class="pcalibre1 pcalibre calibre18">return</span> func(*args, **kwargs)
    <span class="pcalibre1 pcalibre calibre18">return</span> wrapper

@countcalls
<span class="pcalibre1 pcalibre calibre18">def</span> foo(x): <span class="pcalibre1 pcalibre calibre18">return</span> x + 2

@countcalls
<span class="pcalibre1 pcalibre calibre18">def</span> bar(x): <span class="pcalibre1 pcalibre calibre18">return</span> 3 * x</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Basically, everywhere the Python 3 version would say <code class="pcalibre1 pcalibre literal">count</code>, your
code will say <code class="pcalibre1 pcalibre literal">count_container[0]</code>. This works without needing
<code class="pcalibre1 pcalibre literal">global</code> or <code class="pcalibre1 pcalibre literal">nonlocal</code>, because the <code class="pcalibre1 pcalibre literal">count_container</code> <em class="pcalibre1 calibre8 pcalibre">contents</em> are
modified, but it doesn’t modify what the <code class="pcalibre1 pcalibre literal">count_container</code> <em class="pcalibre1 calibre8 pcalibre">variable</em>
points to. In other words, it’s always the same list; you’re just
changing the first (and only) element in that list. A bit clunky, but
probably closest in spirit to what you can do in Python 3 with
<code class="pcalibre1 pcalibre literal">nonlocal</code>.</p>
</section>
</section>
<section class="calibre2 pcalibre1 pcalibre" title="Decorators That Take Arguments">
<h2 id="calibre_link-86" class="pcalibre1 pcalibre calibre1">Decorators That Take Arguments</h2>
<p class="pcalibre1 pcalibre calibre7">
Early in the chapter I showed you an example decorator from the
Flask framework:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>@app.route(<span class="pcalibre1 pcalibre calibre13">"/"</span>)
<span class="pcalibre1 pcalibre calibre18">def</span> hello():
    <span class="pcalibre1 pcalibre calibre18">return</span> <span class="pcalibre1 pcalibre calibre13">"&lt;html&gt;&lt;body&gt;Hello World!&lt;/body&gt;&lt;/html&gt;"</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">This is different from any decorator we’ve implemented so far, because
it actually takes an argument. How do we write decorators that can do
this? For example, imagine a family of decorators adding a
number to the return value of a function:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">def</span> add2(func):
    <span class="pcalibre1 pcalibre calibre18">def</span> wrapper(n):
        <span class="pcalibre1 pcalibre calibre18">return</span> func(n) + 2
    <span class="pcalibre1 pcalibre calibre18">return</span> wrapper

<span class="pcalibre1 pcalibre calibre18">def</span> add4(func):
    <span class="pcalibre1 pcalibre calibre18">def</span> wrapper(n):
        <span class="pcalibre1 pcalibre calibre18">return</span> func(n) + 4
    <span class="pcalibre1 pcalibre calibre18">return</span> wrapper

@add2
<span class="pcalibre1 pcalibre calibre18">def</span> foo(x):
    <span class="pcalibre1 pcalibre calibre18">return</span> x ** 2

@add4
<span class="pcalibre1 pcalibre calibre18">def</span> bar(n):
    <span class="pcalibre1 pcalibre calibre18">return</span> n * 2</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">There is literally only one character difference between <code class="pcalibre1 pcalibre literal">add2</code> and
<code class="pcalibre1 pcalibre literal">add4</code>; it’s very repetitive, and poorly maintainable. Wouldn’t it be
better if we can do something like this:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>@add(2)
<span class="pcalibre1 pcalibre calibre18">def</span> foo(x):
    <span class="pcalibre1 pcalibre calibre18">return</span> x ** 2

@add(4)
<span class="pcalibre1 pcalibre calibre18">def</span> bar(n):
    <span class="pcalibre1 pcalibre calibre18">return</span> n * 2</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">We can. The key is to understand that <code class="pcalibre1 pcalibre literal">add</code> is actually <em class="pcalibre1 calibre8 pcalibre">not</em> a
decorator; it is a function that <em class="pcalibre1 calibre8 pcalibre">returns</em> a decorator. In other
words, <code class="pcalibre1 pcalibre literal">add</code> is a function that returns another function. (Since the
returned decorator is, itself, a function).</p>
<p class="pcalibre1 pcalibre calibre7">To make this work, we write a function called <code class="pcalibre1 pcalibre literal">add</code>, which creates and
returns the decorator:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">def</span> add(increment):
    <span class="pcalibre1 pcalibre calibre18">def</span> decorator(func):
        <span class="pcalibre1 pcalibre calibre18">def</span> wrapper(n):
            <span class="pcalibre1 pcalibre calibre18">return</span> func(n) + increment
        <span class="pcalibre1 pcalibre calibre18">return</span> wrapper
    <span class="pcalibre1 pcalibre calibre18">return</span> decorator</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">It’s easiest to understand from the inside out:</p>
<div class="pcalibre1 pcalibre itemized-list">
<ul class="pcalibre1 calibre14 pcalibre">
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">The <code class="pcalibre1 pcalibre literal">wrapper</code> function is just like in the other decorators.
Ultimately, when you call <code class="pcalibre1 pcalibre literal">foo</code> (the original function name), it’s
actually calling <code class="pcalibre1 pcalibre literal">wrapper</code>.</span>
</li>
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">Moving up, we have the aptly named <code class="pcalibre1 pcalibre literal">decorator</code>. Hint: we could say
<code class="pcalibre1 pcalibre literal">add2 = add(2)</code>, then apply <code class="pcalibre1 pcalibre literal">add2</code> as a decorator.</span>
</li>
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">At the top level is <code class="pcalibre1 pcalibre literal">add</code>. This is not a decorator. It’s a function
that returns a decorator.</span>
</li>
</ul>
</div>
<p class="pcalibre1 pcalibre calibre7">Notice the closure here. The <code class="pcalibre1 pcalibre literal">increment</code> variable is encapsulated
in the scope of the <code class="pcalibre1 pcalibre literal">add</code> function.  We can’t access its value outside
the decorator, in the calling context. But we don’t need to, because
<code class="pcalibre1 pcalibre literal">wrapper</code> itself has access to it.</p>
<p class="pcalibre1 pcalibre calibre7">Suppose the Python interpreter is parsing your program, and encounters the following code:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>@add(2)
<span class="pcalibre1 pcalibre calibre18">def</span> f(n):
    <span class="pcalibre1 pcalibre calibre13"># ....</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Python takes everything between the @-symbol and the end-of-line
character as a single Python expression - that would be â€œadd(2)â€ in
this case. That expression is evaluated. This all happens <em class="pcalibre1 calibre8 pcalibre">at compile
time</em>. Evaluating the decorator expression means
executing <code class="pcalibre1 pcalibre literal">add(2)</code>, which will return a function object. That function
object is the decorator. It’s named <code class="pcalibre1 pcalibre literal">decorator</code> inside the body of the
<code class="pcalibre1 pcalibre literal">add</code> function, but it doesn’t really have a name at the top
level; it’s just applied to <code class="pcalibre1 pcalibre literal">f</code>.</p>
<p class="pcalibre1 pcalibre calibre7">What can help you see more clearly is to think of functions as things
that are stored in variables. In other words, if I write <code class="pcalibre1 pcalibre literal">def
foo(x):</code>, in my code, I could say to myself "I’m creating a function
called foo". But there is another way to think about it. I can say
"I’m creating a function object, and storing it in a variable called
foo". Believe it or not, this is actually much closer to how Python
actually works. So things like this are possible:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre18">def</span> foo():
...     <span class="pcalibre1 pcalibre calibre18">print</span>(<span class="pcalibre1 pcalibre calibre13">"This is foo"</span>)
&gt;&gt;&gt; baz = foo
&gt;&gt;&gt; baz()
This <span class="pcalibre1 pcalibre calibre18">is</span> foo
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13"># foo and baz have the same id()... so they</span>
... <span class="pcalibre1 pcalibre calibre13"># refer to the same function object.</span>
&gt;&gt;&gt; id(foo)
4301663768
&gt;&gt;&gt; id(baz)
4301663768</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Now, back to <code class="pcalibre1 pcalibre literal">add</code>. As you realize <code class="pcalibre1 pcalibre literal">add(2)</code> returns a function object,
it’s easy to imagine storing that in a variable named <code class="pcalibre1 pcalibre literal">add2</code>. As a
matter of fact, the following are all exactly equivalent:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre13"># This...</span>
add2 = add(2)
@add2
<span class="pcalibre1 pcalibre calibre18">def</span> foo(x):
    <span class="pcalibre1 pcalibre calibre18">return</span> x ** 2

<span class="pcalibre1 pcalibre calibre13"># ... has the same effect as this:</span>
@add(2)
<span class="pcalibre1 pcalibre calibre18">def</span> foo(x):
    <span class="pcalibre1 pcalibre calibre18">return</span> x ** 2</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Remember that <code class="pcalibre1 pcalibre literal">@</code> is a shorthand:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre13"># This...</span>
@some_decorator
<span class="pcalibre1 pcalibre calibre18">def</span> some_function(arg):
    <span class="pcalibre1 pcalibre calibre13"># blah blah</span>

<span class="pcalibre1 pcalibre calibre13"># ... is translated by Python into this:</span>
<span class="pcalibre1 pcalibre calibre18">def</span> some_function(arg):
    <span class="pcalibre1 pcalibre calibre13"># blah blah</span>
some_function = some_decorator(some_function)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">So for <code class="pcalibre1 pcalibre literal">add</code>, the following are all equivalent:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>add2 = add(2) <span class="pcalibre1 pcalibre calibre13"># Store the decorator in the add2 variable</span>

<span class="pcalibre1 pcalibre calibre13"># This function definition...</span>
@add2
<span class="pcalibre1 pcalibre calibre18">def</span> foo(x):
    <span class="pcalibre1 pcalibre calibre18">return</span> x ** 2

<span class="pcalibre1 pcalibre calibre13"># ... is translated by Python into this:</span>
<span class="pcalibre1 pcalibre calibre18">def</span> foo(x):
    <span class="pcalibre1 pcalibre calibre18">return</span> x ** 2
foo = add2(foo)

<span class="pcalibre1 pcalibre calibre13"># But also, this...</span>
@add(2)
<span class="pcalibre1 pcalibre calibre18">def</span> foo(x):
    <span class="pcalibre1 pcalibre calibre18">return</span> x ** 2

<span class="pcalibre1 pcalibre calibre13"># ... is translated by Python into this:</span>
<span class="pcalibre1 pcalibre calibre18">def</span> foo(x):
    <span class="pcalibre1 pcalibre calibre18">return</span> x ** 2
foo = add(2)(foo)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Look over these four variations, and trace through what’s going on in
your mind, until you understand how they are all equivalent. The
expression <code class="pcalibre1 pcalibre literal">add(2)(foo)</code> in particular is interesting. Python parses
this left-to-right. So it first executes <code class="pcalibre1 pcalibre literal">add(2)</code>, which returns a
function object. In this expression, that function has no name; it’s
temporary and anonymous. Python takes that anonymous function
object, and immediately calls it, with the argument <code class="pcalibre1 pcalibre literal">foo</code>. (That
argument is, of course, the bare function - the function which we are
decorating, in other words.) The anonymous function then returns a
<em class="pcalibre1 calibre8 pcalibre">different</em> function object, which we finally store in the variable
called <code class="pcalibre1 pcalibre literal">foo</code>.</p>
<p class="pcalibre1 pcalibre calibre7">Notice that in the line <code class="pcalibre1 pcalibre literal">foo = add(2)(foo)</code>, the name <code class="pcalibre1 pcalibre literal">foo</code> means
something different each time it’s used. Just like when you write
something like <code class="pcalibre1 pcalibre literal">n = n + 3</code>; the name <code class="pcalibre1 pcalibre literal">n</code> refers to something different
on either side of the equals sign. In the exact same way, in the line
<code class="pcalibre1 pcalibre literal">foo = add(2)(foo)</code>, the variable <code class="pcalibre1 pcalibre literal">foo</code> holds two different function
objects on the left and right sides.</p>
</section>
<section class="calibre2 pcalibre1 pcalibre" title="Class-based Decorators">
<h2 id="calibre_link-87" class="pcalibre1 pcalibre calibre1">Class-based Decorators</h2>
<p class="pcalibre1 pcalibre calibre7">
I lied to you.</p>
<p class="pcalibre1 pcalibre calibre7">I repeatedly told you a decorator is just a function. Well, decorators
are usually <em class="pcalibre1 calibre8 pcalibre">implemented</em> as functions, that’s true. However, it’s
also possible to implement a decorator using classes. In fact, <em class="pcalibre1 calibre8 pcalibre">any</em>
decorator that you can implement as a function can be done with a
class instead.</p>
<p class="pcalibre1 pcalibre calibre7">Why would you do this? Basically, for certain kinds of more complex
decorators, classes are better suited, more readable, or otherwise
easier to work with. For example, if you have a collection of related
decorators, you can leverage inheritance or other object-oriented
features. Simpler decorators are better implemented as functions,
though it depends on your preferences for OO versus functional
abstractions. It’s best to learn both ways, then decide which you
prefer in your own code on a case-by-case basis.</p>
<p class="pcalibre1 pcalibre calibre7">The secret to decorating with classes is the magic method
<code class="pcalibre1 pcalibre literal">__call__</code>.  Any object can implement
<code class="pcalibre1 pcalibre literal">__call__</code> to make it callable - meaning, the object can be called
like a function. Here’s a simple example:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">class</span> <span class="pcalibre1 pcalibre calibre18">Prefixer</span>:
    <span class="pcalibre1 pcalibre calibre18">def</span> __init__(self, prefix):
        self.prefix = prefix
    <span class="pcalibre1 pcalibre calibre18">def</span> __call__(self, message):
        <span class="pcalibre1 pcalibre calibre18">return</span> self.prefix + message</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">You can then, in effect, "instantiate" functions:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; simonsays = Prefixer(<span class="pcalibre1 pcalibre calibre13">"Simon says: "</span>)
&gt;&gt;&gt; simonsays(<span class="pcalibre1 pcalibre calibre13">"Get up and dance!"</span>)
<span class="pcalibre1 pcalibre calibre13">'Simon says: Get up and dance!'</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Just looking at <code class="pcalibre1 pcalibre literal">simonsays("Get up and
dance!")</code> in isolation, you’d never guess it is anything other than a
normal function. In fact, it’s an instance of <code class="pcalibre1 pcalibre literal">Prefixer</code>.</p>
<p class="pcalibre1 pcalibre calibre7">You can use <code class="pcalibre1 pcalibre literal">__call__</code> to implement decorators, in a very different
way. Before proceeding, quiz yourself: thinking back to the
<code class="pcalibre1 pcalibre literal">@printlog</code> decorator, and using this information about <code class="pcalibre1 pcalibre literal">__call__</code>,
how might you implement <code class="pcalibre1 pcalibre literal">printlog</code> as a class instead of a function?</p>
<p class="pcalibre1 pcalibre calibre7">The basic approach is to pass <code class="pcalibre1 pcalibre literal">func</code> it to the <em class="pcalibre1 calibre8 pcalibre">constructor</em> of a
decorator <em class="pcalibre1 calibre8 pcalibre">class</em>, and adapt <code class="pcalibre1 pcalibre literal">wrapper</code> to be the <code class="pcalibre1 pcalibre literal">__call__</code> method:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">class</span> <span class="pcalibre1 pcalibre calibre18">PrintLog</span>:
    <span class="pcalibre1 pcalibre calibre18">def</span> __init__(self, func):
        self.func = func
    <span class="pcalibre1 pcalibre calibre18">def</span> __call__(self, *args, **kwargs):
        <span class="pcalibre1 pcalibre calibre18">print</span>(<span class="pcalibre1 pcalibre calibre13">'CALLING: {}'</span>.format(self.func.__name__))
        <span class="pcalibre1 pcalibre calibre18">return</span> self.func(*args, **kwargs)

<span class="pcalibre1 pcalibre calibre13"># Compare to the function version you saw earlier:</span>
<span class="pcalibre1 pcalibre calibre18">def</span> printlog(func):
    <span class="pcalibre1 pcalibre calibre18">def</span> wrapper(*args, **kwargs):
        <span class="pcalibre1 pcalibre calibre18">print</span>(<span class="pcalibre1 pcalibre calibre13">"CALLING: "</span> + func.__name__)
        <span class="pcalibre1 pcalibre calibre18">return</span> func(*args, **kwargs)
    <span class="pcalibre1 pcalibre calibre18">return</span> wrapper</code></pre>
</figure>
<figure class="pcalibre1 pcalibre footnotes">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; @PrintLog
... <span class="pcalibre1 pcalibre calibre18">def</span> foo(x):
...     <span class="pcalibre1 pcalibre calibre18">print</span>(x + 2)
...
&gt;&gt;&gt; @PrintLog
... <span class="pcalibre1 pcalibre calibre18">def</span> baz(x, y):
...     <span class="pcalibre1 pcalibre calibre18">return</span> x ** y
...
&gt;&gt;&gt; foo(7)
CALLING: foo
9
&gt;&gt;&gt; baz(3, 2)
CALLING: baz
9</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">From the point of view of the user, <code class="pcalibre1 pcalibre literal">@Printlog</code> and <code class="pcalibre1 pcalibre literal">@printlog</code> work
<em class="pcalibre1 calibre8 pcalibre">exactly</em> the same.</p>
<p class="pcalibre1 pcalibre calibre7">Class-based decorators have a few advantages over function-based. For
one thing, the decorator is a class, which means you can leverage
inheritance. So if you have a family of related decorators, you can
reuse code between them. Here’s an example:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">import</span> <span class="pcalibre1 pcalibre calibre18">sys</span>
<span class="pcalibre1 pcalibre calibre18">class</span> <span class="pcalibre1 pcalibre calibre18">ResultAnnouncer</span>:
    stream = sys.stdout
    prefix = <span class="pcalibre1 pcalibre calibre13">"RESULT"</span>
    <span class="pcalibre1 pcalibre calibre18">def</span> __init__(self, func):
        self.func = func
    <span class="pcalibre1 pcalibre calibre18">def</span> __call__(self, *args, **kwargs):
        value = self.func(*args, **kwargs)
        self.stream.write(<span class="pcalibre1 pcalibre calibre13">'{}: {}</span><span class="pcalibre1 pcalibre calibre20">\n</span><span class="pcalibre1 pcalibre calibre13">'</span>.format(self.prefix, value))
        <span class="pcalibre1 pcalibre calibre18">return</span> value

<span class="pcalibre1 pcalibre calibre18">class</span> <span class="pcalibre1 pcalibre calibre18">StdErrResultAnnouncer</span>(ResultAnnouncer):
    stream = sys.stderr
    prefix = <span class="pcalibre1 pcalibre calibre13">"ERROR"</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Another benefit is when you prefer to accumulate state in object
attributes, instead of a closure. For example, the <code class="pcalibre1 pcalibre literal">countcalls</code>
function decorator above could be implemented as a class:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">class</span> <span class="pcalibre1 pcalibre calibre18">CountCalls</span>:
    <span class="pcalibre1 pcalibre calibre18">def</span> __init__(self, func):
        self.func = func
        self.count = 1
    <span class="pcalibre1 pcalibre calibre18">def</span> __call__(self, *args, **kwargs):
        <span class="pcalibre1 pcalibre calibre18">print</span>(<span class="pcalibre1 pcalibre calibre13">'# of calls: {}'</span>.format(self.count))
        self.count += 1
        <span class="pcalibre1 pcalibre calibre18">return</span> self.func(*args, **kwargs)

@CountCalls
<span class="pcalibre1 pcalibre calibre18">def</span> foo(x):
    <span class="pcalibre1 pcalibre calibre18">return</span> x + 2</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Notice this also lets us access <code class="pcalibre1 pcalibre literal">foo.count</code>, if we want to check the
count outside of the decorated function. The function version didn’t
let us do this.</p>
<p class="pcalibre1 pcalibre calibre7">When creating decorators which take arguments, the structure is a
little different. In this case, the constructor accepts not the <code class="pcalibre1 pcalibre literal">func</code>
object to be decorated, but the parameters on the decorator line. The
<code class="pcalibre1 pcalibre literal">__call__</code> method must take the <code class="pcalibre1 pcalibre literal">func</code> object, define a wrapper
function, and return it - similar to simple function-based decorators:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre13"># Class-based version of the "add" decorator above.</span>
<span class="pcalibre1 pcalibre calibre18">class</span> <span class="pcalibre1 pcalibre calibre18">Add</span>:
    <span class="pcalibre1 pcalibre calibre18">def</span> __init__(self, increment):
        self.increment = increment
    <span class="pcalibre1 pcalibre calibre18">def</span> __call__(self, func):
        <span class="pcalibre1 pcalibre calibre18">def</span> wrapper(n):
            <span class="pcalibre1 pcalibre calibre18">return</span> func(n) + self.increment
        <span class="pcalibre1 pcalibre calibre18">return</span> wrapper</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">You then use it in a similar manner to any other argument-taking
decorator:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; @Add(2)
... <span class="pcalibre1 pcalibre calibre18">def</span> foo(x):
...     <span class="pcalibre1 pcalibre calibre18">return</span> x ** 2
...
&gt;&gt;&gt; @Add(4)
... <span class="pcalibre1 pcalibre calibre18">def</span> bar(n):
...     <span class="pcalibre1 pcalibre calibre18">return</span> n * 2
...
&gt;&gt;&gt; foo(3)
11
&gt;&gt;&gt; bar(77)
158</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Any function-based decorator can be implemented as a class-based
decorator; you simply adapt the decorator function itself to <code class="pcalibre1 pcalibre literal">__init__</code>,
and <code class="pcalibre1 pcalibre literal">wrapper</code> to <code class="pcalibre1 pcalibre literal">__call__</code>. It’s possible to design class-based
decorators which cannot be translated into a function-based form, though.</p>
<p class="pcalibre1 pcalibre calibre7">For complex decorators, some people feel that class-based are easier
to read than function-based. In particular, many people seem to find
multiply nested <code class="pcalibre1 pcalibre literal">def</code>​'s hard to reason about. Others (including your
author) feel the opposite. This is a matter of preference, and I
recommend you practice with both styles before coming to your own
conclusions.</p>
</section>
<section class="calibre2 pcalibre1 pcalibre" title="Decorators For Classes">
<h2 id="calibre_link-88" class="pcalibre1 pcalibre calibre1">Decorators For Classes</h2>
<p class="pcalibre1 pcalibre calibre7"> I lied to you again. I
said decorators are applied to functions and methods. Well, they can
also be applied to classes.</p>
<p class="pcalibre1 pcalibre calibre7">(Understand this has <em class="pcalibre1 calibre8 pcalibre">nothing</em> to do with the last section’s topic,
on implementing decorators as classes. A decorator can be implemented as
a function, or as a class; and that decorator can be applied to a
function, or to a class. They are independent ideas; here, we are
talking about how to decorate classes instead of functions.)</p>
<p class="pcalibre1 pcalibre calibre7">To introduce an example, let me explain Python’s built-in <code class="pcalibre1 pcalibre literal">repr()</code>

function. When called with one argument, this returns a string, meant
to represent the passed object. It’s similar to <code class="pcalibre1 pcalibre literal">str()</code>; the
difference is that while <code class="pcalibre1 pcalibre literal">str()</code> returns a human-readable string,
<code class="pcalibre1 pcalibre literal">repr()</code> is meant to return a string version of the Python code needed
to recreate it. So imagine a simple <code class="pcalibre1 pcalibre literal">Penny</code> class:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">class</span> <span class="pcalibre1 pcalibre calibre18">Penny</span>:
    value = 1

penny = Penny()</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Ideally, <code class="pcalibre1 pcalibre literal">repr(penny)</code> returns the string <code class="pcalibre1 pcalibre literal">"Penny()"</code>. But that’s not
what happens by default:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11">&gt;&gt;&gt; class Penny:
...     value = 1
&gt;&gt;&gt; penny = Penny()
&gt;&gt;&gt; repr(penny)
'&lt;__main__.Penny object at 0x10229ff60&gt;'</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">You fix this by implementing a <code class="pcalibre1 pcalibre literal">__repr__</code> method on your classes,
which <code class="pcalibre1 pcalibre literal">repr()</code> will use:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11">&gt;&gt;&gt; class Penny:
...     value = 1
...     def __repr__(self):
...         return "Penny()"
&gt;&gt;&gt; penny = Penny()
&gt;&gt;&gt; repr(penny)
'Penny()'</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">You can create a decorator that will automatically add a <code class="pcalibre1 pcalibre literal">__repr__</code>
method to any class. You might be able to guess how it works.
Instead of a wrapper function, the decorator returns a class:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre18">def</span> autorepr(klass):
...     <span class="pcalibre1 pcalibre calibre18">def</span> klass_repr(self):
...         <span class="pcalibre1 pcalibre calibre18">return</span> <span class="pcalibre1 pcalibre calibre13">'{}()'</span>.format(klass.__name__)
...     klass.__repr__ = klass_repr
...     <span class="pcalibre1 pcalibre calibre18">return</span> klass
...
&gt;&gt;&gt; @autorepr
... <span class="pcalibre1 pcalibre calibre18">class</span> <span class="pcalibre1 pcalibre calibre18">Penny</span>:
...     value = 1
...
&gt;&gt;&gt; penny = Penny()
&gt;&gt;&gt; repr(penny)
<span class="pcalibre1 pcalibre calibre13">'Penny()'</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">It’s suitable for classes with no-argument constructors, like <code class="pcalibre1 pcalibre literal">Penny</code>.
Note how the decorator modifies <code class="pcalibre1 pcalibre literal">klass</code> directly. The original class
is returned; that original class just now has a <code class="pcalibre1 pcalibre literal">__repr__</code>
method. Can you see how this is different from what we did with
decorators of functions? With those, the decorator returned a new,
different function object.</p>
<p class="pcalibre1 pcalibre calibre7">Another strategy for decorating classes is closer in spirit: creating a
new subclass within the decorator, returning that in its place:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">def</span> autorepr_subclass(klass):
    <span class="pcalibre1 pcalibre calibre18">class</span> <span class="pcalibre1 pcalibre calibre18">NewClass</span>(klass):
        <span class="pcalibre1 pcalibre calibre18">def</span> __repr__(self):
            <span class="pcalibre1 pcalibre calibre18">return</span> <span class="pcalibre1 pcalibre calibre13">'{}()'</span>.format(klass.__name__)
    <span class="pcalibre1 pcalibre calibre18">return</span> NewClass</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">This has the disadvantage of creating a new type:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">&gt;&gt;&gt; </span>@autorepr_subclass
<span class="pcalibre1 pcalibre calibre18">... class</span> <span class="pcalibre1 pcalibre calibre18">Nickel</span>:
<span class="pcalibre1 pcalibre calibre18">... </span>    value = 5
<span class="pcalibre1 pcalibre calibre18">...</span>
<span class="pcalibre1 pcalibre calibre18">&gt;&gt;&gt; </span>nickel = Nickel()
<span class="pcalibre1 pcalibre calibre18">&gt;&gt;&gt; </span>type(nickel)
&lt;class '__main__.autorepr_subclass.&lt;locals&gt;.NewClass'&gt;</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">The resulting object’s type isn’t obviously related to the decorated
class. That makes debugging harder, creates unclear log messages, and
has other unexpected effects.  For this reason, I recommend you prefer
the first approach.</p>
<p class="pcalibre1 pcalibre calibre7">Class decorators tend to be less useful in practice than those for
functions and methods.  When they are used, it’s often to
automatically generate and add methods. But they are more flexible
than that. You can even express the singleton pattern using
class decorators:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">def</span> singleton(klass):
     instances = {}
     <span class="pcalibre1 pcalibre calibre18">def</span> get_instance():
         <span class="pcalibre1 pcalibre calibre18">if</span> klass <span class="pcalibre1 pcalibre calibre18">not</span> <span class="pcalibre1 pcalibre calibre18">in</span> instances:
             instances[klass] = klass()
         <span class="pcalibre1 pcalibre calibre18">return</span> instances[klass]
     <span class="pcalibre1 pcalibre calibre18">return</span> get_instance

<span class="pcalibre1 pcalibre calibre13"># There is only one Elvis.</span>
@singleton
<span class="pcalibre1 pcalibre calibre18">class</span> <span class="pcalibre1 pcalibre calibre18">Elvis</span>:
    <span class="pcalibre1 pcalibre calibre18">pass</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Note the IDs are the same:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; elvis1 = Elvis()
&gt;&gt;&gt; elvis2 = Elvis()
&gt;&gt;&gt;
&gt;&gt;&gt; id(elvis1)
4333747560
&gt;&gt;&gt; id(elvis2)
4333747560</code></pre>
</figure>
</section>
<section class="calibre2 pcalibre1 pcalibre" title="Preserving the Wrapped Function">
<h2 id="calibre_link-89" class="pcalibre1 pcalibre calibre1">Preserving the Wrapped Function</h2>
<p class="pcalibre1 pcalibre calibre7">
The techniques in this chapter for creating decorators are
time-tested, and valuable in many situations. But the resulting
decorators have a few problems:</p>
<div class="pcalibre1 pcalibre itemized-list">
<ul class="pcalibre1 calibre14 pcalibre">
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">Function objects automatically have certain attributes, like
<code class="pcalibre1 pcalibre literal">__name__</code>, <code class="pcalibre1 pcalibre literal">__doc__</code>, <code class="pcalibre1 pcalibre literal">__module__</code>, etc. The wrapper clobbers
all these, breaking any code relying on them.</span>
</li>
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">Decorators interfere with introspection - masking the wrapped
function’s signature, and blocking <code class="pcalibre1 pcalibre literal">inspect.getsource()</code>.</span>
</li>
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">Decorators cannot be applied in certain more exotic situations -
like class methods, or descriptors - without going through
some heroic contortions.</span>
</li>
</ul>
</div>
<p class="pcalibre1 pcalibre calibre7">The first problem is easily solved using the standard library’s
<code class="pcalibre1 pcalibre literal">functools</code> module.  It includes a
function called 
 <code class="pcalibre1 pcalibre literal">wraps</code>, which you use like this:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">import</span> <span class="pcalibre1 pcalibre calibre18">functools</span>
<span class="pcalibre1 pcalibre calibre18">def</span> printlog(func):
    @functools.wraps(func)
    <span class="pcalibre1 pcalibre calibre18">def</span> wrapper(*args, **kwargs):
        <span class="pcalibre1 pcalibre calibre18">print</span>(<span class="pcalibre1 pcalibre calibre13">'CALLING: {}'</span>.format(func.__name__))
        <span class="pcalibre1 pcalibre calibre18">return</span> func(*args, **kwargs)
    <span class="pcalibre1 pcalibre calibre18">return</span> wrapper</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">That’s right - <code class="pcalibre1 pcalibre literal">functools.wraps</code> is a decorator, that you use <em class="pcalibre1 calibre8 pcalibre">inside</em>
your own decorator. When applied to the <code class="pcalibre1 pcalibre literal">wrapper</code> function, it
essentially copies certain attributes from the wrapped function to the
wrapper. It is equivalent to this:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">def</span> printlog(func):
    <span class="pcalibre1 pcalibre calibre18">def</span> wrapper(*args, **kwargs):
        <span class="pcalibre1 pcalibre calibre18">print</span>(<span class="pcalibre1 pcalibre calibre13">'CALLING: {}'</span>.format(func.__name__))
        <span class="pcalibre1 pcalibre calibre18">return</span> func(*args, **kwargs)
    wrapper.__name__ = func.__name__
    wrapper.__doc__ = func.__doc__
    wrapper.__module__ = func.__module__
    wrapper.__annotations__ = func.__annotations__
    <span class="pcalibre1 pcalibre calibre18">return</span> wrapper</code></pre>
</figure>
<figure class="pcalibre1 pcalibre footnotes">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; @printlog
... <span class="pcalibre1 pcalibre calibre18">def</span> foo(x):
...     <span class="pcalibre1 pcalibre calibre13">"Double-increment and print number."</span>
...     <span class="pcalibre1 pcalibre calibre18">print</span>(x + 2)
...
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13"># functools.wraps transfers the wrapped function's attributes</span>
... foo.__name__
<span class="pcalibre1 pcalibre calibre13">'foo'</span>
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre18">print</span>(foo.__doc__)
Double-increment <span class="pcalibre1 pcalibre calibre18">and</span> <span class="pcalibre1 pcalibre calibre18">print</span> number.</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Contrast this with the default behavior:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre13"># What you get without functools.wraps.</span>
&gt;&gt;&gt; foo.__name__
<span class="pcalibre1 pcalibre calibre13">'wrapper'</span>
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre18">print</span>(foo.__doc__)
None</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">In addition to saving you lots of tedious typing, <code class="pcalibre1 pcalibre literal">functools.wraps</code>
encapsulates the details of <em class="pcalibre1 calibre8 pcalibre">what</em> to copy over, so you don’t need to
worry if new attributes are introduced in future versions of
Python. For example, the <code class="pcalibre1 pcalibre literal">__annotations__</code> attribute was added in
Python 3; those who used <code class="pcalibre1 pcalibre literal">functools.wraps</code> in their Python 2 code had
one less thing to worry about when porting to Python 3.</p>
<p class="pcalibre1 pcalibre calibre7"><code class="pcalibre1 pcalibre literal">functools.wraps</code> is a actually a convenient shortcut of the more
general


<code class="pcalibre1 pcalibre literal">update_wrapper</code>. Since <code class="pcalibre1 pcalibre literal">wraps</code> only works with function-based
decorators, your class-based decorators must use <code class="pcalibre1 pcalibre literal">update_wrapper</code>
instead:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">import</span> <span class="pcalibre1 pcalibre calibre18">functools</span>
<span class="pcalibre1 pcalibre calibre18">class</span> <span class="pcalibre1 pcalibre calibre18">PrintLog</span>:
    <span class="pcalibre1 pcalibre calibre18">def</span> __init__(self, func):
        self.func = func
        functools.update_wrapper(self, func)
    <span class="pcalibre1 pcalibre calibre18">def</span> __call__(self, *args, **kwargs):
        <span class="pcalibre1 pcalibre calibre18">print</span>(<span class="pcalibre1 pcalibre calibre13">'CALLING: {}'</span>.format(self.func.__name__))
        <span class="pcalibre1 pcalibre calibre18">return</span> self.func(*args, **kwargs)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">While useful for copying over <code class="pcalibre1 pcalibre literal">__name__</code>, <code class="pcalibre1 pcalibre literal">__doc__</code>, and the other
attributes, <code class="pcalibre1 pcalibre literal">wraps</code> and <code class="pcalibre1 pcalibre literal">update_wrapper</code> do not help with the other
problems mentioned above. The closest to a full solution is Graham
Dumpleton’s  
<code class="pcalibre1 pcalibre literal">wrapt</code> library.<sup class="pcalibre1 pcalibre noteref">[<a href="#calibre_link-12" id="calibre_link-20" type="noteref" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">6</a>]</sup> Decorators created using the <code class="pcalibre1 pcalibre literal">wrapt</code>
module work in situations that cause normal decorators to break, and
behave correctly when used with more exotic Python language features.</p>
<p class="pcalibre1 pcalibre calibre7">So what should you do in practice?</p>
<p class="pcalibre1 pcalibre calibre7">Common advice says to proactively use <code class="pcalibre1 pcalibre literal">functools.wraps</code> in all your
decorators. I have a different, probably controversial opinion, born
from observing that most Pythonistas in the wild do <em class="pcalibre1 calibre8 pcalibre">not</em> regularly
use it, including myself, even though we know the implications.</p>
<p class="pcalibre1 pcalibre calibre7">While it’s true that using <code class="pcalibre1 pcalibre literal">functools.wraps</code> on all your decorators
will prevent certain problems, doing so is not completely free. There
is a cognitive cost, in that you have to remember to use it - at
least, unless you make it an ingrained, fully automatic habit. It’s
boilerplate which takes extra time to write, and which references the
<code class="pcalibre1 pcalibre literal">func</code> parameter - so there’s something else to modify if you change
its name. And with <code class="pcalibre1 pcalibre literal">wrapt</code>, you have another library dependency to
manage.</p>
<p class="pcalibre1 pcalibre calibre7">All these amount to a small distraction each time you write a
decorator.  And when you <em class="pcalibre1 calibre8 pcalibre">do</em> have a problem that <code class="pcalibre1 pcalibre literal">functools.wraps</code> or
the <code class="pcalibre1 pcalibre literal">wrapt</code> module would solve, you are likely to encounter it during
development, rather than have it show up unexpectedly in
production. (Look at the list above again, and this will be evident.)
When that happens, you can just add it and move on.</p>
<p class="pcalibre1 pcalibre calibre7">The biggest exception is probably when you are using some kind of
automated API documentation tool,<sup class="pcalibre1 pcalibre noteref">[<a href="#calibre_link-13" id="calibre_link-21" type="noteref" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">7</a>]</sup>
which will use each function’s <code class="pcalibre1 pcalibre literal">__doc__</code> attribute to generate
reference docs. Since decorators systematically clobber that
attribute, it makes sense to document a policy of using
<code class="pcalibre1 pcalibre literal">functools.wraps</code> for all decorators in your coding style guidelines,
and enforce it in code reviews.</p>
<p class="pcalibre1 calibre7 pcalibre7">Aside from situations like this, though, the problems with decorators
will be largely theoretical for most (but not all) developers. If you
are in that category, I recommend optimistically writing decorators
<em class="pcalibre1 calibre8 pcalibre">without</em> bothering to use <code class="pcalibre1 pcalibre literal">wraps</code>, <code class="pcalibre1 pcalibre literal">update_wrapper</code>, or the <code class="pcalibre1 pcalibre literal">wrapt</code>
module. If and when you realize you are having a problem that these
would solve for a specific decorator, introduce them then.<sup class="pcalibre1 pcalibre noteref">[<a href="#calibre_link-14" id="calibre_link-22" type="noteref" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">8</a>]</sup></p>
</section>
<footer class="pcalibre1 pcalibre calibre15">
<div class="calibre16 pcalibre1 pcalibre"></div><div class="pcalibre1 pcalibre chapter-footer">
<div class="pcalibre1 pcalibre footnotes">
<aside id="calibre_link-7" type="footnote" class="calibre2 pcalibre1 pcalibre">
<p class="pcalibre1 calibre17 pcalibre"><sup class="noteref1 pcalibre1 pcalibre"><a href="#calibre_link-15" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">1</a></sup> Writing decorators builds on the "Advanced Functions" chapter. If you are not already familiar with that material, read it first.</p>
</aside>
<aside id="calibre_link-8" type="footnote" class="calibre2 pcalibre1 pcalibre">
<p class="pcalibre1 calibre17 pcalibre"><sup class="noteref1 pcalibre1 pcalibre"><a href="#calibre_link-16" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">2</a></sup> For Java people: this looks just like Java annotations. However, it’s <em class="pcalibre1 calibre8 pcalibre">completely different</em>. Python decorators are not in any way similar.</p>
</aside>
<aside id="calibre_link-9" type="footnote" class="calibre2 pcalibre1 pcalibre">
<p class="pcalibre1 calibre17 pcalibre"><sup class="noteref1 pcalibre1 pcalibre"><a href="#calibre_link-17" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">3</a></sup> Some authors use the phrase "decorated function" to mean "the function that is decorated" - what I’m calling the "bare function". If you read a lot of blog posts, you’ll find the phrase used both ways (sometimes in the same article), but we’ll consistently use the definitions above.</p>
</aside>
<aside id="calibre_link-10" type="footnote" class="calibre2 pcalibre1 pcalibre">
<p class="pcalibre1 calibre17 pcalibre"><sup class="noteref1 pcalibre1 pcalibre"><a href="#calibre_link-18" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">4</a></sup> In a real application, you’d write the average to some kind of log sink, but we’ll use <code class="pcalibre1 pcalibre literal">print()</code> here because it’s convenient for learning.</p>
</aside>
<aside id="calibre_link-11" type="footnote" class="calibre2 pcalibre1 pcalibre">
<p class="pcalibre1 calibre17 pcalibre"><sup class="noteref1 pcalibre1 pcalibre"><a href="#calibre_link-19" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">5</a></sup> <code class="pcalibre1 pcalibre literal">nonlocal</code> is not available in Python 2; if you are using that version, see the next section.</p>
</aside>
<aside id="calibre_link-12" type="footnote" class="calibre2 pcalibre1 pcalibre">
<p class="pcalibre1 calibre17 pcalibre"><sup class="noteref1 pcalibre1 pcalibre"><a href="#calibre_link-20" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">6</a></sup> <code class="pcalibre1 pcalibre literal">pip install wrapt</code>. See also <a class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4" href="https://github.com/GrahamDumpleton/wrapt">https://github.com/GrahamDumpleton/wrapt</a> and <a class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4" href="http://wrapt.readthedocs.org/">http://wrapt.readthedocs.org/</a> .</p>
</aside>
<aside id="calibre_link-13" type="footnote" class="calibre2 pcalibre1 pcalibre">
<p class="pcalibre1 calibre17 pcalibre"><sup class="noteref1 pcalibre1 pcalibre"><a href="#calibre_link-21" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">7</a></sup> See <a class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4" href="https://wiki.python.org/moin/DocumentationTools">https://wiki.python.org/moin/DocumentationTools</a> for a thorough list.</p>
</aside>
<aside id="calibre_link-14" type="footnote" class="calibre2 pcalibre1 pcalibre">
<p class="pcalibre1 calibre17 pcalibre"><sup class="noteref1 pcalibre1 pcalibre"><a href="#calibre_link-22" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">8</a></sup> A perfect example of this happens towards the end of the "Building a RESTful API Server in Python" video (<a class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4" href="https://powerfulpython.com/store/restful-api-server/">https://powerfulpython.com/store/restful-api-server/</a>), when I create the <code class="pcalibre1 pcalibre literal">validate_summary</code> decorator. Applying the decorator to a couple of Flask views immediately triggers a routing error, which I then fix using <code class="pcalibre1 pcalibre literal">wraps</code>.</p>
</aside>
</div>
</div>
</footer>
</section>
</div>


<div id="calibre_link-28" class="pcalibre1 pcalibre calibre">
<section class="calibre2 pcalibre1 pcalibre" id="calibre_link-179" title="Exceptions and Errors" type="chapter">
<header id="calibre_link-90" class="calibre2 pcalibre1 pcalibre">
<div class="pcalibre1 pcalibre chapter-header">
<h1 class="pcalibre1 chapter-title pcalibre"> <small class="subtitle pcalibre1 pcalibre"><b class="pcalibre1 pcalibre calibre6">EXCEPTIONS</b> <b class="pcalibre1 pcalibre calibre6">AND</b> <b class="pcalibre1 pcalibre calibre6">ERRORS</b></small></h1>
</div>
</header>
<p class="pcalibre1 pcalibre calibre7">Errors happen. That’s why every practical programming language
provides a rich framework for dealing with them.</p>
<p class="pcalibre1 pcalibre calibre7">Python’s error model is based on <em class="pcalibre1 calibre8 pcalibre">exceptions</em>. Some of you reading
this are familiar with exceptions, and some are not; some of you have
used exceptions in other languages, and not yet with Python. This
chapter is for all of you.</p>
<p class="pcalibre1 pcalibre calibre7">If you are familiar with how exceptions work in Java, C++ or C#,
you’ll find Python uses similar concepts, even if the syntax is
completely different. And beyond those similarities lie uniquely
Pythonic patterns.</p>
<p class="pcalibre1 pcalibre calibre7">We’ll start with the basics some of you know. Even if you’ve used
Python exceptions before, I recommend reading all of this
chapter. Odds are you will learn useful things, even in sections
which appear to discuss what you’ve seen before.</p>
<section class="calibre2 pcalibre1 pcalibre" title="The Basic Idea">
<h2 id="calibre_link-91" class="pcalibre1 pcalibre calibre1">The Basic Idea</h2>
<p class="pcalibre1 pcalibre calibre7">
An <em class="pcalibre1 calibre8 pcalibre">exception</em> is a way to interrupt the normal flow of
code. When an exception occurs, the block of Python code will stop
executing - literally in the middle of the line - and immediately jump
to <em class="pcalibre1 calibre8 pcalibre">another</em> block of code, designed to handle the situation.</p>
<p class="pcalibre1 pcalibre calibre7">Often an exception means an error of some sort, but it doesn’t have to
be.  It can be used to signal anticipated events, which are best
handled in an interrupt-driven way. Let’s illustrate the common,
simple cases first, before exploring more sophisticated patterns.</p>
<p class="pcalibre1 pcalibre calibre7">You’ve already encountered exceptions, even if you didn’t realize
it. Here’s a little program using a <code class="pcalibre1 pcalibre literal">dict</code>:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre13"># favdessert.py</span>
<span class="pcalibre1 pcalibre calibre18">def</span> describe_favorite(category):
    <span class="pcalibre1 pcalibre calibre13">"Describe my favorite food in a category."</span>
    favorites = {
        <span class="pcalibre1 pcalibre calibre13">"appetizer"</span>: <span class="pcalibre1 pcalibre calibre13">"calamari"</span>,
        <span class="pcalibre1 pcalibre calibre13">"vegetable"</span>: <span class="pcalibre1 pcalibre calibre13">"broccoli"</span>,
        <span class="pcalibre1 pcalibre calibre13">"beverage"</span>: <span class="pcalibre1 pcalibre calibre13">"coffee"</span>,
    }
    <span class="pcalibre1 pcalibre calibre18">return</span> <span class="pcalibre1 pcalibre calibre13">"My favorite {} is {}."</span>.format(
        category, favorites[category])

message = describe_favorite(<span class="pcalibre1 pcalibre calibre13">"dessert"</span>)
<span class="pcalibre1 pcalibre calibre18">print</span>(message)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">When run, this program exits with an error:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>Traceback (most recent call last):
  File <span class="pcalibre1 pcalibre calibre13">"favdessert.py"</span>, line 12, <span class="pcalibre1 pcalibre calibre18">in</span> &lt;module&gt;
    message = describe_favorite(<span class="pcalibre1 pcalibre calibre13">"dessert"</span>)
  File <span class="pcalibre1 pcalibre calibre13">"favdessert.py"</span>, line 10, <span class="pcalibre1 pcalibre calibre18">in</span> describe_favorite
    category, favorites[category])
<span class="pcalibre1 pcalibre calibre18">KeyError</span>: <span class="pcalibre1 pcalibre calibre13">'dessert'</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">  When you
look up a missing dictionary key like this, we say Python <em class="pcalibre1 calibre8 pcalibre">raises</em> a
<em class="pcalibre1 calibre8 pcalibre">KeyError</em>. (In other languages, the terminology is "throw an
exception". Same idea; Python uses the word "raise" instead of
"throw".) That <code class="pcalibre1 pcalibre literal">KeyError</code> is an <em class="pcalibre1 calibre8 pcalibre">exception</em>. In fact, most errors you
see in Python are exceptions. This includes <code class="pcalibre1 pcalibre literal">IndexError</code> for lists,
<code class="pcalibre1 pcalibre literal">TypeError</code> for incompatible types, <code class="pcalibre1 pcalibre literal">ValueError</code> for bad values, and
so on.   
 When an error occurs, Python responds by
raising an exception.</p>
<p class="pcalibre1 pcalibre calibre7">An exception needs to be handled. If not, your program will crash.
You handle it with <em class="pcalibre1 calibre8 pcalibre">try-except</em> blocks. They look like this:

</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre13"># Replace the last few lines with the following:</span>
<span class="pcalibre1 pcalibre calibre18">try</span>:
    message = describe_favorite(<span class="pcalibre1 pcalibre calibre13">"dessert"</span>)
    <span class="pcalibre1 pcalibre calibre18">print</span>(message)
<span class="pcalibre1 pcalibre calibre18">except</span> <span class="pcalibre1 pcalibre calibre18">KeyError</span>:
    <span class="pcalibre1 pcalibre calibre18">print</span>(<span class="pcalibre1 pcalibre calibre13">"I have no favorite dessert. I love them all!"</span>)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Notice the structure. You have the keyword <code class="pcalibre1 pcalibre literal">try</code>, followed by an
indented block of code, immediately followed by <code class="pcalibre1 pcalibre literal">except KeyError</code>,
which has its own block of code. We say the <code class="pcalibre1 pcalibre literal">except</code> block
<em class="pcalibre1 calibre8 pcalibre">catches</em> the <code class="pcalibre1 pcalibre literal">KeyError</code> exception.</p>
<p class="pcalibre1 pcalibre calibre7">Run the program with these new lines, and you get the following
output:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11">I have no favorite dessert. I love them all!</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Importantly, the new program exits successfully; its exit
code to the operating system indicates "success" rather than
"failure".</p>
<p class="pcalibre1 pcalibre calibre7">Here’s how <code class="pcalibre1 pcalibre literal">try</code> and <code class="pcalibre1 pcalibre literal">except</code> work:</p>
<div class="pcalibre1 pcalibre itemized-list">
<ul class="pcalibre1 calibre14 pcalibre">
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">Python starts executing lines of code in the <code class="pcalibre1 pcalibre literal">try:</code> block.</span>
</li>
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">If Python gets to the end of the <code class="pcalibre1 pcalibre literal">try</code> block and no exceptions are
raised, Python skips over the <code class="pcalibre1 pcalibre literal">except</code> block completely. None of
its lines are executed, and Python proceeds to the next line
after (if there is one).</span>
</li>
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">If an exception is raised anywhere in the <code class="pcalibre1 pcalibre literal">try</code> block, the program
immediately stops - literally in the middle of the line; no further
lines in the <code class="pcalibre1 pcalibre literal">try</code> block will be executed. Python then checks
whether the exception type (<code class="pcalibre1 pcalibre literal">KeyError</code>, in this case) matches an
<code class="pcalibre1 pcalibre literal">except</code> clause. If so, it jumps to the matching block’s first line.</span>
</li>
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">If the exception does <em class="pcalibre1 calibre8 pcalibre">not</em> match the <code class="pcalibre1 pcalibre literal">except</code> block, the exception
ignores it, acting like the block isn’t even there. If no
higher-level code has an <code class="pcalibre1 pcalibre literal">except</code> block to catch it, the
program will crash.</span>
</li>
</ul>
</div>
<p class="pcalibre1 pcalibre calibre7">Let’s wrap these lines of code in a function:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">def</span> print_description(category):
    <span class="pcalibre1 pcalibre calibre18">try</span>:
        message = describe_favorite(category)
        <span class="pcalibre1 pcalibre calibre18">print</span>(message)
    <span class="pcalibre1 pcalibre calibre18">except</span> <span class="pcalibre1 pcalibre calibre18">KeyError</span>:
        <span class="pcalibre1 pcalibre calibre18">print</span>(<span class="pcalibre1 pcalibre calibre13">"I have no favorite {}. I love them all!"</span>.format(category))</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Notice how <code class="pcalibre1 pcalibre literal">print_description</code> behaves differently, depending on what
you feed it:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">&gt;&gt;&gt; </span>print_description(<span class="pcalibre1 pcalibre calibre13">"dessert"</span>)
I have no favorite dessert. I love them all!
<span class="pcalibre1 pcalibre calibre18">&gt;&gt;&gt; </span>print_description(<span class="pcalibre1 pcalibre calibre13">"appetizer"</span>)
My favorite appetizer is calamari.
<span class="pcalibre1 pcalibre calibre18">&gt;&gt;&gt; </span>print_description(<span class="pcalibre1 pcalibre calibre13">"beverage"</span>)
My favorite beverage is coffee.
<span class="pcalibre1 pcalibre calibre18">&gt;&gt;&gt; </span>print_description(<span class="pcalibre1 pcalibre calibre13">"soup"</span>)
I have no favorite soup. I love them all!</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">
Exceptions aren’t just for damage control. You will sometimes use them
as a flow-control tool, to deal with ordinary variations you know can
occur at runtime. Suppose, for example, your program loads data from a
file, in JSON format. You import the <code class="pcalibre1 pcalibre literal">json.load</code> function in your
code:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">from</span> <span class="pcalibre1 pcalibre calibre18">json</span> <span class="pcalibre1 pcalibre calibre18">import</span> load</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7"><code class="pcalibre1 pcalibre literal">json</code> is part of Python’s standard library, so it’s always
available. Now, imagine there’s an open-source library called
<code class="pcalibre1 pcalibre literal">speedyjson</code>,<sup class="pcalibre1 pcalibre noteref">[<a href="#calibre_link-29" id="calibre_link-33" type="noteref" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">1</a>]</sup> with a <code class="pcalibre1 pcalibre literal">load</code> function just
like what’s in the standard library - except twice as fast. And your
program works with BIG json files, so you want to preferentially use
the <code class="pcalibre1 pcalibre literal">speedyjson</code> version when available. In Python, importing
something that doesn’t exist raises an <code class="pcalibre1 pcalibre literal">ImportError</code>:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre13"># If speedyjson isn't installed...</span>
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre18">from</span> <span class="pcalibre1 pcalibre calibre18">speedyjson</span> <span class="pcalibre1 pcalibre calibre18">import</span> load
Traceback (most recent call last):
  File <span class="pcalibre1 pcalibre calibre13">"&lt;stdin&gt;"</span>, line 2, <span class="pcalibre1 pcalibre calibre18">in</span> &lt;module&gt;
<span class="pcalibre1 pcalibre calibre18">ImportError</span>: No module named <span class="pcalibre1 pcalibre calibre13">'speedyjson'</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">How can you use <code class="pcalibre1 pcalibre literal">speedyjson</code> if it’s there, yet gracefully fall back
on <code class="pcalibre1 pcalibre literal">json</code> when it’s not? Use a try-except block:</p>
<p class="pcalibre1 pcalibre calibre7"></p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">try</span>:
    <span class="pcalibre1 pcalibre calibre18">from</span> <span class="pcalibre1 pcalibre calibre18">speedyjson</span> <span class="pcalibre1 pcalibre calibre18">import</span> load
<span class="pcalibre1 pcalibre calibre18">except</span> <span class="pcalibre1 pcalibre calibre18">ImportError</span>:
    <span class="pcalibre1 pcalibre calibre18">from</span> <span class="pcalibre1 pcalibre calibre18">json</span> <span class="pcalibre1 pcalibre calibre18">import</span> load</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">If <code class="pcalibre1 pcalibre literal">speedyjson</code> is installed and importable, <code class="pcalibre1 pcalibre literal">load</code> will refer to its
version of the function in your code. Otherwise you get
<code class="pcalibre1 pcalibre literal">json.load</code>.</p>
<p class="pcalibre1 pcalibre calibre7">A single <code class="pcalibre1 pcalibre literal">try</code> can have multiple <code class="pcalibre1 pcalibre literal">except</code> blocks. For example, <code class="pcalibre1 pcalibre literal">int()</code>
will raise a <code class="pcalibre1 pcalibre literal">TypeError</code> if passed a nonsensical type; it raises
<code class="pcalibre1 pcalibre literal">ValueError</code> if the type is acceptable, but its value can’t be
converted to an integer.</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">try</span>:
    value = int(user_input)
<span class="pcalibre1 pcalibre calibre18">except</span> <span class="pcalibre1 pcalibre calibre18">ValueError</span>:
    <span class="pcalibre1 pcalibre calibre18">print</span>(<span class="pcalibre1 pcalibre calibre13">"Bad value from user"</span>)
<span class="pcalibre1 pcalibre calibre18">except</span> <span class="pcalibre1 pcalibre calibre18">TypeError</span>:
    <span class="pcalibre1 pcalibre calibre18">print</span>(<span class="pcalibre1 pcalibre calibre13">"Invalid type (probably a bug)"</span>)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">
More realistically, you might log different error
events​<sup class="pcalibre1 pcalibre noteref">[<a href="#calibre_link-30" id="calibre_link-34" type="noteref" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">2</a>]</sup> with different levels of severity:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">try</span>:
    value = int(user_input)
<span class="pcalibre1 pcalibre calibre18">except</span> <span class="pcalibre1 pcalibre calibre18">ValueError</span>:
    logging.error(<span class="pcalibre1 pcalibre calibre13">"Bad value from user: </span><span class="pcalibre1 pcalibre calibre20">%r</span><span class="pcalibre1 pcalibre calibre13">"</span>, user_input)
<span class="pcalibre1 pcalibre calibre18">except</span> <span class="pcalibre1 pcalibre calibre18">TypeError</span>:
    logging.critical(
        <span class="pcalibre1 pcalibre calibre13">"Invalid type (probably a bug): </span><span class="pcalibre1 pcalibre calibre20">%r</span><span class="pcalibre1 pcalibre calibre13">"</span>, user_input)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">If an exception is raised, Python will check whether its type matches
the first <code class="pcalibre1 pcalibre literal">except</code> block. If not, it checks the next. The first
matching <code class="pcalibre1 pcalibre literal">except</code> block is executed, and all others are skipped over
entirely - so you will never have more than one of the <code class="pcalibre1 pcalibre literal">except</code> blocks
executed for a given <code class="pcalibre1 pcalibre literal">try</code>. Of course, if none of them match, the
exception continues rising until something catches it. (Or the process
dies.)</p>
<p class="pcalibre1 pcalibre calibre7">There’s a good rule of thumb, which I suggest you start building as a
habit now: <em class="pcalibre1 calibre8 pcalibre">put as little code as possible in the <code class="pcalibre1 pcalibre literal">try</code> block</em>. You do
this so your <code class="pcalibre1 pcalibre literal">except</code> block(s) will not catch or mask errors they
should not.</p>
<p class="pcalibre1 pcalibre calibre7">
Sometimes you will want to have clean-up code that runs <em class="pcalibre1 calibre8 pcalibre">no matter
what</em>, even if an exception is raised. You can do this by adding a
<code class="pcalibre1 pcalibre literal">finally</code> block:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">try</span>:
    line1
    line2
    <span class="pcalibre1 pcalibre calibre13"># etc.</span>
<span class="pcalibre1 pcalibre calibre18">finally</span>:
    line1
    line2
    <span class="pcalibre1 pcalibre calibre13"># etc.</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">The code in the <code class="pcalibre1 pcalibre literal">finally</code> block is <em class="pcalibre1 calibre8 pcalibre">always</em> executed. If an exception
is raised in the <code class="pcalibre1 pcalibre literal">try</code> block, Python will immediately jump to the
<code class="pcalibre1 pcalibre literal">finally</code> block, run its lines, then raise the exception. If an
exception is not raised, Python will run all the lines in the <code class="pcalibre1 pcalibre literal">try</code>
block, then run the lines in the <code class="pcalibre1 pcalibre literal">finally</code> block. It’s a way to say,
"run these lines no matter what".</p>
<p class="pcalibre1 pcalibre calibre7">
You can also have one (or more) except clauses:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">try</span>:
    line1
    line2
    <span class="pcalibre1 pcalibre calibre13"># etc.</span>
<span class="pcalibre1 pcalibre calibre18">except</span> FirstException:
    line1
    line2
    <span class="pcalibre1 pcalibre calibre13"># etc.</span>
<span class="pcalibre1 pcalibre calibre18">except</span> SecondException:
    line1
    line2
    <span class="pcalibre1 pcalibre calibre13"># etc.</span>
<span class="pcalibre1 pcalibre calibre18">finally</span>:
    line1
    line2
    <span class="pcalibre1 pcalibre calibre13"># etc.</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">What’s executed and when depends on whether an exception is raised. If
not, the lines in the <code class="pcalibre1 pcalibre literal">try</code> block run, followed by the lines in the
<code class="pcalibre1 pcalibre literal">finally</code> block; none of the <code class="pcalibre1 pcalibre literal">except</code> blocks run. If an exception <em class="pcalibre1 calibre8 pcalibre">is</em>
raised, and it matches one of the <code class="pcalibre1 pcalibre literal">except</code> blocks, then the <code class="pcalibre1 pcalibre literal">finally</code>
block runs <em class="pcalibre1 calibre8 pcalibre">last</em>. The order is: the <code class="pcalibre1 pcalibre literal">try</code> block (up until the
exception is raised), then the matching <code class="pcalibre1 pcalibre literal">except</code> block, and then the
finally block.</p>
<p class="pcalibre1 pcalibre calibre7">What if an exception is raised, but there is no matching except block?
The <code class="pcalibre1 pcalibre literal">except</code> blocks are ignored, because none of them match. The lines
of code in <code class="pcalibre1 pcalibre literal">try</code> are executed, up until the exception is
raised. Python immediately jumps to the <code class="pcalibre1 pcalibre literal">finally</code> block; when its
lines finish, only then is the exception raised.</p>
<p class="pcalibre1 pcalibre calibre7">It’s important to understand this ordering. When you include a
<code class="pcalibre1 pcalibre literal">finally</code> block, and an exception is raised, the code in the <code class="pcalibre1 pcalibre literal">finally</code>
block interjects itself between the code that could run in the <code class="pcalibre1 pcalibre literal">try</code>
block, and the raising of the exception. A <code class="pcalibre1 pcalibre literal">finally</code> block is like
insurance, for code which <em class="pcalibre1 calibre8 pcalibre">must</em> run, no matter what.</p>
<p class="pcalibre1 pcalibre calibre7">Here’s a good example. Imagine writing control code that does batch
calculations on a fleet of cloud virtual machines. You issue an API
call to rent them, and pay by the hour until you release them. Your
code might look something like:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre13"># fleet_config is an object with the details of what</span>
<span class="pcalibre1 pcalibre calibre13"># virtual machines to start, and how to connect them.</span>
fleet = CloudVMFleet(fleet_config)
<span class="pcalibre1 pcalibre calibre13"># job_config details what kind of batch calculation to run.</span>
job = BatchJob(job_config)
<span class="pcalibre1 pcalibre calibre13"># .start() makes the API calls to rent the instances,</span>
<span class="pcalibre1 pcalibre calibre13"># blocking until they are ready to accept jobs.</span>
fleet.start()
<span class="pcalibre1 pcalibre calibre13"># Now submit the job. It returns a RunningJob handle.</span>
running_job = fleet.submit_job(job)
<span class="pcalibre1 pcalibre calibre13"># Wait for it to finish.</span>
running_job.wait()
<span class="pcalibre1 pcalibre calibre13"># And now release the fleet of VM instances, so we</span>
<span class="pcalibre1 pcalibre calibre13"># don't have to keep paying for them.</span>
fleet.terminate()</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Now imagine <code class="pcalibre1 pcalibre literal">running_job.wait()</code> raises a <code class="pcalibre1 pcalibre literal">socket.timeout</code> exception
(which means the network connection has timed out). This causes a
stack trace, and the program crashes, or maybe some higher-level
code actually catches the exception.</p>
<p class="pcalibre1 pcalibre calibre7">Regardless, now <code class="pcalibre1 pcalibre literal">fleet.terminate()</code> is never called. Whoops. That
could be <em class="pcalibre1 calibre8 pcalibre">really</em> expensive.</p>
<p class="pcalibre1 pcalibre calibre7">To save your bank balance (or keep your job), rewrite the code using a
<code class="pcalibre1 pcalibre literal">finally</code> block:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>fleet = CloudVMFleet(fleet_config)
job = BatchJob(job_config)
<span class="pcalibre1 pcalibre calibre18">try</span>:
    fleet.start()
    running_job = fleet.submit_job(job)
    running_job.wait()
<span class="pcalibre1 pcalibre calibre18">finally</span>:
    fleet.terminate()</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">This code expresses the idea: "no matter what, terminate the fleet of
rented virtual machines." Even if an error in <code class="pcalibre1 pcalibre literal">fleet.submit_job(job)</code>
or <code class="pcalibre1 pcalibre literal">running_job.wait()</code> makes the program crash, it calls
<code class="pcalibre1 pcalibre literal">fleet.terminate()</code> with its dying breath.</p>
<p class="pcalibre1 pcalibre calibre7">Let’s look at dictionaries again.  When working directly with a
dictionary, you can use the "if key in dictionary" pattern to avoid a
<code class="pcalibre1 pcalibre literal">KeyError</code>, instead of try/except blocks:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre13"># Another approach we could have taken with favdessert.py</span>
<span class="pcalibre1 pcalibre calibre18">def</span> describe_favorite_or_default(category):
    <span class="pcalibre1 pcalibre calibre13">'Describe my favorite food in a category.'</span>
    favorites = {
        <span class="pcalibre1 pcalibre calibre13">"appetizer"</span>: <span class="pcalibre1 pcalibre calibre13">"calamari"</span>,
        <span class="pcalibre1 pcalibre calibre13">"vegetable"</span>: <span class="pcalibre1 pcalibre calibre13">"broccoli"</span>,
        <span class="pcalibre1 pcalibre calibre13">"beverage"</span>: <span class="pcalibre1 pcalibre calibre13">"coffee"</span>,
    }
    <span class="pcalibre1 pcalibre calibre18">if</span> category <span class="pcalibre1 pcalibre calibre18">in</span> favorites:
        message = <span class="pcalibre1 pcalibre calibre13">"My favorite {} is {}."</span>.format(
        category, favorites[category])
    <span class="pcalibre1 pcalibre calibre18">else</span>:
        message = <span class="pcalibre1 pcalibre calibre13">"I have no favorite {}. I love them all!"</span>.format(category)
    <span class="pcalibre1 pcalibre calibre18">return</span> message

message = describe_favorite_or_default(<span class="pcalibre1 pcalibre calibre13">"dessert"</span>)
<span class="pcalibre1 pcalibre calibre18">print</span>(message)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">The general pattern is:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre13"># Using "if key in dictionary" idiom.</span>
<span class="pcalibre1 pcalibre calibre18">if</span> key <span class="pcalibre1 pcalibre calibre18">in</span> mydict:
    value = mydict[key]
<span class="pcalibre1 pcalibre calibre18">else</span>:
    value = default_value

<span class="pcalibre1 pcalibre calibre13"># Contrast with "try/except KeyError".</span>
<span class="pcalibre1 pcalibre calibre18">try</span>:
    value = mydict[key]
<span class="pcalibre1 pcalibre calibre18">except</span> <span class="pcalibre1 pcalibre calibre18">KeyError</span>:
    value = default_value</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Many developers prefer using the "if key in dictionary" idiom, or
using <code class="pcalibre1 pcalibre literal">dict.get()</code>. But these aren’t always the best choice. They are
only options if your code has direct access to the dictionary, for one
thing. Maybe <code class="pcalibre1 pcalibre literal">describe_favorite()</code> is part of a library, and you can’t
change it. Even if it’s open-source, you have better things to do than
fork a library every time a function interface isn’t convenient. Or
maybe <code class="pcalibre1 pcalibre literal">describe_favorite()</code> is code you control, but you just don’t
<em class="pcalibre1 calibre8 pcalibre">want</em> to change it, for any number of good reasons.  A try-except
block catching <code class="pcalibre1 pcalibre literal">KeyError</code> solves all these problems, because it lets
you handle the situation without modifying any code inside
<code class="pcalibre1 pcalibre literal">describe_favorite()</code> itself.</p>
</section>
<section class="calibre2 pcalibre1 pcalibre" title="Exceptions Are Objects">
<h2 id="calibre_link-92" class="pcalibre1 pcalibre calibre1">Exceptions Are Objects</h2>
<p class="pcalibre1 pcalibre calibre7">An exception is an object: an instance of an exception
class. <code class="pcalibre1 pcalibre literal">KeyError</code>, <code class="pcalibre1 pcalibre literal">IndexError</code>, <code class="pcalibre1 pcalibre literal">TypeError</code> and <code class="pcalibre1 pcalibre literal">ValueError</code> are all
built-in classes, which inherit from a base class called <code class="pcalibre1 pcalibre literal">Exception</code>.
Writing code like <code class="pcalibre1 pcalibre literal">except KeyError:</code> means "if the exception just
raised is of type <code class="pcalibre1 pcalibre literal">KeyError</code>, run this block of code."</p>
<p class="pcalibre1 pcalibre calibre7">So far, we haven’t dealt with those exception objects directly. And
often, you don’t need to. But sometimes you want more information
about what happened, and capturing the exception object can
help. Here’s the structure:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11">try:
    do_something()
except <em class="pcalibre1 pcalibre calibre13">ExceptionClass</em> as exception_object:
    handle_exception(exception_object)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">where <em class="pcalibre1 calibre8 pcalibre">ExceptionClass</em> is some exception class, like <code class="pcalibre1 pcalibre literal">KeyError</code>, etc.
In the except block, <code class="pcalibre1 pcalibre literal">exception_object</code> will be an instance of that
class. You can choose any name for that variable; no one actually
calls it <code class="pcalibre1 pcalibre literal">exception_object</code>, preferring shorter names like <code class="pcalibre1 pcalibre literal">ex</code>,
<code class="pcalibre1 pcalibre literal">exc</code>, or <code class="pcalibre1 pcalibre literal">err</code>.  The methods and contents of that object will depend
on the kind of exception, but almost all will have an attribute called
<code class="pcalibre1 pcalibre literal">args</code>. That will be a tuple of what was passed to the exception’s
constructor. The <code class="pcalibre1 pcalibre literal">args</code> of a <code class="pcalibre1 pcalibre literal">KeyError</code>, for example, will have one
element - the missing key:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre13"># Atomic numbers of noble gasses.</span>
nobles = {<span class="pcalibre1 pcalibre calibre13">'He'</span>: 2, <span class="pcalibre1 pcalibre calibre13">'Ne'</span>: 10,
  <span class="pcalibre1 pcalibre calibre13">'Ar'</span>: 18, <span class="pcalibre1 pcalibre calibre13">'Kr'</span>: 36, <span class="pcalibre1 pcalibre calibre13">'Xe'</span>: 54}
<span class="pcalibre1 pcalibre calibre18">def</span> show_element_info(elements):
   <span class="pcalibre1 pcalibre calibre18">for</span> element <span class="pcalibre1 pcalibre calibre18">in</span> elements:
       <span class="pcalibre1 pcalibre calibre18">print</span>(<span class="pcalibre1 pcalibre calibre13">'Atomic number of {} is {}'</span>.format(
             element, nobles[element]))
<span class="pcalibre1 pcalibre calibre18">try</span>:
    show_element_info([<span class="pcalibre1 pcalibre calibre13">'Ne'</span>, <span class="pcalibre1 pcalibre calibre13">'Ar'</span>, <span class="pcalibre1 pcalibre calibre13">'Br'</span>])
<span class="pcalibre1 pcalibre calibre18">except</span> <span class="pcalibre1 pcalibre calibre18">KeyError</span> <span class="pcalibre1 pcalibre calibre18">as</span> err:
    missing_element = err.args[0]
    <span class="pcalibre1 pcalibre calibre18">print</span>(<span class="pcalibre1 pcalibre calibre13">'Missing data for element: '</span> + missing_element)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Running this code gives you the following output:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11">Atomic number of Ne is 10
Atomic number of Ar is 18
Missing data for element: Br</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">The interesting bit is in the <code class="pcalibre1 pcalibre literal">except</code> block. Writing <code class="pcalibre1 pcalibre literal">except KeyError
as err</code> stores the exception object in the <code class="pcalibre1 pcalibre literal">err</code> variable. That lets
us look up the offending key, by peeking in <code class="pcalibre1 pcalibre literal">err.args</code>. Notice we
could not get the offending key any other way, unless we want to
modify <code class="pcalibre1 pcalibre literal">show_element_info</code> (which we may not want to do, or perhaps <em class="pcalibre1 calibre8 pcalibre">can’t</em>
do, as described before).</p>
<p class="pcalibre1 pcalibre calibre7">Let’s walk through a more sophisticated example. In the <code class="pcalibre1 pcalibre literal">os</code> module, the
<code class="pcalibre1 pcalibre literal">makedirs</code> function will create a directory:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre13"># Creates the directory "riddles", relative</span>
<span class="pcalibre1 pcalibre calibre13"># to the current directory.</span>
<span class="pcalibre1 pcalibre calibre18">import</span> <span class="pcalibre1 pcalibre calibre18">os</span>
os.makedirs(<span class="pcalibre1 pcalibre calibre13">"riddles"</span>)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">
By default, if the directory already exists, <code class="pcalibre1 pcalibre literal">makedirs</code> will raise
<code class="pcalibre1 pcalibre literal">FileExistsError</code>:<sup class="pcalibre1 pcalibre noteref">[<a href="#calibre_link-31" id="calibre_link-35" type="noteref" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">3</a>]</sup> Imagine you are writing a web application, and need to
create an upload directory for each new user. That directory should
not exist; if it does, that’s an error and needs to be logged. Our
upload-directory-creating function might look like this:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre13"># First version....</span>
<span class="pcalibre1 pcalibre calibre18">import</span> <span class="pcalibre1 pcalibre calibre18">os</span>
<span class="pcalibre1 pcalibre calibre18">import</span> <span class="pcalibre1 pcalibre calibre18">logging</span>
UPLOAD_ROOT = <span class="pcalibre1 pcalibre calibre13">"/var/www/uploads/"</span>
<span class="pcalibre1 pcalibre calibre18">def</span> create_upload_dir(username):
    userdir = os.path.join(UPLOAD_ROOT, username)
    <span class="pcalibre1 pcalibre calibre18">try</span>:
        os.makedirs(userdir)
    <span class="pcalibre1 pcalibre calibre18">except</span> FileExistsError:
        logging.error(
            <span class="pcalibre1 pcalibre calibre13">"Upload dir for new user already exists"</span>)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">It’s great we are detecting and logging the error, but the error
message isn’t informative enough to be helpful. We at least need to
know the offending username, but it’s even better to know the
directory’s full path (so you don’t have to dig in the code to remind
yourself what <code class="pcalibre1 pcalibre literal">UPLOAD_ROOT</code> was set to).</p>
<p class="pcalibre1 pcalibre calibre7">Fortunately, <code class="pcalibre1 pcalibre literal">FileExistsError</code> objects have an attribute called
<code class="pcalibre1 pcalibre literal">filename</code>. This is a string, and the path to the already-existing
directory.  We can use that to improve the log message:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre13"># Better version!</span>
<span class="pcalibre1 pcalibre calibre18">import</span> <span class="pcalibre1 pcalibre calibre18">os</span>
<span class="pcalibre1 pcalibre calibre18">import</span> <span class="pcalibre1 pcalibre calibre18">logging</span>
UPLOAD_ROOT = <span class="pcalibre1 pcalibre calibre13">"/var/www/uploads/"</span>
<span class="pcalibre1 pcalibre calibre18">def</span> create_upload_dir(username):
    userdir = os.path.join(UPLOAD_ROOT, username)
    <span class="pcalibre1 pcalibre calibre18">try</span>:
        os.makedirs(userdir)
    <span class="pcalibre1 pcalibre calibre18">except</span> FileExistsError <span class="pcalibre1 pcalibre calibre18">as</span> err:
        logging.error(<span class="pcalibre1 pcalibre calibre13">"Upload dir already exists: </span><span class="pcalibre1 pcalibre calibre20">%s</span><span class="pcalibre1 pcalibre calibre13">"</span>,
            err.filename)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Only the <code class="pcalibre1 pcalibre literal">except</code> block is different. That <code class="pcalibre1 pcalibre literal">filename</code> attribute is
perfect for a useful log message.</p>
</section>
<section class="calibre2 pcalibre1 pcalibre" title="Raising Exceptions">
<h2 id="calibre_link-93" class="pcalibre1 pcalibre calibre1">Raising Exceptions</h2>
<p class="pcalibre1 pcalibre calibre7">

<code class="pcalibre1 pcalibre literal">ValueError</code> is a built-in exception that signals some data is of the
correct type, but its format isn’t valid. It shows up everywhere:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; int(<span class="pcalibre1 pcalibre calibre13">"not a number"</span>)
Traceback (most recent call last):
  File <span class="pcalibre1 pcalibre calibre13">"&lt;stdin&gt;"</span>, line 1, <span class="pcalibre1 pcalibre calibre18">in</span> &lt;module&gt;
<span class="pcalibre1 pcalibre calibre18">ValueError</span>: invalid literal <span class="pcalibre1 pcalibre calibre18">for</span> int() <span class="pcalibre1 pcalibre calibre18">with</span> base 10: <span class="pcalibre1 pcalibre calibre13">'not a number'</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Your own code can raise exceptions, just like <code class="pcalibre1 pcalibre literal">int()</code> does. You
should, in fact, so you have better error messages. (And sometimes for
other reasons - more on that later.) You do so with the <em class="pcalibre1 calibre8 pcalibre">raise</em>
statement. The most common form is this:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11">raise <em class="pcalibre1 pcalibre calibre13">ExceptionClass</em>(arguments)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">
For <code class="pcalibre1 pcalibre literal">ValueError</code> specifically, it might look like:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">def</span> positive_int(value):
    number = int(value)
    <span class="pcalibre1 pcalibre calibre18">if</span> number &lt;= 0:
        <span class="pcalibre1 pcalibre calibre18">raise</span> <span class="pcalibre1 pcalibre calibre18">ValueError</span>(<span class="pcalibre1 pcalibre calibre13">"Bad value: "</span> + str(value))
    <span class="pcalibre1 pcalibre calibre18">return</span> number</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Focus on the <code class="pcalibre1 pcalibre literal">raise</code> line in <code class="pcalibre1 pcalibre literal">positive_int</code>.  You simply create
an instance of <code class="pcalibre1 pcalibre literal">ValueError</code>, and pass it directly to <code class="pcalibre1 pcalibre literal">raise</code>.
Really, the syntax is <code class="pcalibre1 pcalibre literal">raise exception_object</code> - though usually you
just create the object inline. <code class="pcalibre1 pcalibre literal">ValueError</code>​'s constructor takes one
argument, a descriptive string. This shows up in stack traces and log
messages, so be sure to make it informative and useful:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; positive_int(<span class="pcalibre1 pcalibre calibre13">"-3"</span>)
Traceback (most recent call last):
  File <span class="pcalibre1 pcalibre calibre13">"&lt;stdin&gt;"</span>, line 1, <span class="pcalibre1 pcalibre calibre18">in</span> &lt;module&gt;
  File <span class="pcalibre1 pcalibre calibre13">"&lt;stdin&gt;"</span>, line 4, <span class="pcalibre1 pcalibre calibre18">in</span> positive_int
<span class="pcalibre1 pcalibre calibre18">ValueError</span>: Bad value: -3
&gt;&gt;&gt; positive_int(-7.0)
Traceback (most recent call last):
  File <span class="pcalibre1 pcalibre calibre13">"&lt;stdin&gt;"</span>, line 1, <span class="pcalibre1 pcalibre calibre18">in</span> &lt;module&gt;
  File <span class="pcalibre1 pcalibre calibre13">"&lt;stdin&gt;"</span>, line 4, <span class="pcalibre1 pcalibre calibre18">in</span> positive_int
<span class="pcalibre1 pcalibre calibre18">ValueError</span>: Bad value: -7.0</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Let’s show a more complex example. Imagine you have a <code class="pcalibre1 pcalibre literal">Money</code> class:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">class</span> <span class="pcalibre1 pcalibre calibre18">Money</span>:
    <span class="pcalibre1 pcalibre calibre18">def</span> __init__(self, dollars, cents):
        self.dollars = dollars
        self.cents = cents
    <span class="pcalibre1 pcalibre calibre18">def</span> __repr__(self):
        <span class="pcalibre1 pcalibre calibre13">'Renders the object nicely on the prompt.'</span>
        <span class="pcalibre1 pcalibre calibre18">return</span> <span class="pcalibre1 pcalibre calibre13">"Money({},{})"</span>.format(
            self.dollars, self.cents)
    <span class="pcalibre1 pcalibre calibre13"># Plus other methods, which aren't important to us now.</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Your code needs to create <code class="pcalibre1 pcalibre literal">Money</code> objects from string values, like
"$140.75". The constructor takes dollars and cents, so you create a
function to parse that string and instantiate <code class="pcalibre1 pcalibre literal">Money</code> for you:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">import</span> <span class="pcalibre1 pcalibre calibre18">re</span>
<span class="pcalibre1 pcalibre calibre18">def</span> money_from_string(amount):
    <span class="pcalibre1 pcalibre calibre13"># amount is a string like "$140.75"</span>
    match = re.search(
        <span class="pcalibre1 pcalibre calibre13">r'^\$(?P&lt;dollars&gt;\d+)\.(?P&lt;cents&gt;\d\d)$'</span>, amount)
    dollars = int(match.group(<span class="pcalibre1 pcalibre calibre13">'dollars'</span>))
    cents = int(match.group(<span class="pcalibre1 pcalibre calibre13">'cents'</span>))
    <span class="pcalibre1 pcalibre calibre18">return</span> Money(dollars, cents)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">This function​<sup class="pcalibre1 pcalibre noteref">[<a href="#calibre_link-32" id="calibre_link-36" type="noteref" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">4</a>]</sup> works like this:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; money_from_string(<span class="pcalibre1 pcalibre calibre13">"$140.75"</span>)
Money(140,75)
&gt;&gt;&gt; money_from_string(<span class="pcalibre1 pcalibre calibre13">"$12.30"</span>)
Money(12,30)
&gt;&gt;&gt; money_from_string(<span class="pcalibre1 pcalibre calibre13">"Big money"</span>)
Traceback (most recent call last):
  File <span class="pcalibre1 pcalibre calibre13">"&lt;stdin&gt;"</span>, line 1, <span class="pcalibre1 pcalibre calibre18">in</span> &lt;module&gt;
  File <span class="pcalibre1 pcalibre calibre13">"&lt;stdin&gt;"</span>, line 4, <span class="pcalibre1 pcalibre calibre18">in</span> money_from_string
<span class="pcalibre1 pcalibre calibre18">AttributeError</span>: <span class="pcalibre1 pcalibre calibre13">'NoneType'</span> object has no attribute <span class="pcalibre1 pcalibre calibre13">'group'</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">This error isn’t clear; you must read the source and think about it
to understand what went wrong. We have better things to do than
decrypt stack traces. You can improve this function’s usability by
having it raise a <code class="pcalibre1 pcalibre literal">ValueError</code>.</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">import</span> <span class="pcalibre1 pcalibre calibre18">re</span>
<span class="pcalibre1 pcalibre calibre18">def</span> money_from_string(amount):
    match = re.search(
        <span class="pcalibre1 pcalibre calibre13">r'^\$(?P&lt;dollars&gt;\d+)\.(?P&lt;cents&gt;\d\d)$'</span>, amount)
    <span class="pcalibre1 pcalibre calibre13"># Adding the next two lines here</span>
    <span class="pcalibre1 pcalibre calibre18">if</span> match <span class="pcalibre1 pcalibre calibre18">is</span> None:
        <span class="pcalibre1 pcalibre calibre18">raise</span> <span class="pcalibre1 pcalibre calibre18">ValueError</span>(<span class="pcalibre1 pcalibre calibre13">"Invalid amount: "</span> + repr(amount))
    dollars = int(match.group(<span class="pcalibre1 pcalibre calibre13">'dollars'</span>))
    cents = int(match.group(<span class="pcalibre1 pcalibre calibre13">'cents'</span>))
    <span class="pcalibre1 pcalibre calibre18">return</span> Money(dollars, cents)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">The error message is now much more informative:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; money_from_string(<span class="pcalibre1 pcalibre calibre13">"Big money"</span>)
Traceback (most recent call last):
  File <span class="pcalibre1 pcalibre calibre13">"&lt;stdin&gt;"</span>, line 1, <span class="pcalibre1 pcalibre calibre18">in</span> &lt;module&gt;
  File <span class="pcalibre1 pcalibre calibre13">"&lt;stdin&gt;"</span>, line 6, <span class="pcalibre1 pcalibre calibre18">in</span> money_from_string
<span class="pcalibre1 pcalibre calibre18">ValueError</span>: Invalid amount: <span class="pcalibre1 pcalibre calibre13">'Big money'</span></code></pre>
</figure>
</section>
<section class="calibre2 pcalibre1 pcalibre" title="Catching And Re-raising">
<h2 id="calibre_link-94" class="pcalibre1 pcalibre calibre1">Catching And Re-raising</h2>
<p class="pcalibre1 pcalibre calibre7">

In an <code class="pcalibre1 pcalibre literal">except</code> block, you can re-raise the current exception. It’s
very simple; just write <code class="pcalibre1 pcalibre literal">raise</code> by itself, with no arguments:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">try</span>:
    do_something()
<span class="pcalibre1 pcalibre calibre18">except</span> ExceptionClass:
    handle_exception()
    <span class="pcalibre1 pcalibre calibre18">raise</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Notice you don’t need to store the exception object in a
variable. It’s a shorthand, exactly equivalent to this:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">try</span>:
    do_something()
<span class="pcalibre1 pcalibre calibre18">except</span> ExceptionClass <span class="pcalibre1 pcalibre calibre18">as</span> err:
    handle_exception()
    <span class="pcalibre1 pcalibre calibre18">raise</span> err</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">This "catch and release" only works in an <code class="pcalibre1 pcalibre literal">except</code> block.  It requires
that some higher-level code will catch the exception and deal with
it. Yet it enables several useful code patterns. One is when you want
to delegate handling the exception to higher-level code, but also want
to inject some extra behavior closer to the exception source. For
example:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">try</span>:
    process_user_input(value)
<span class="pcalibre1 pcalibre calibre18">except</span> <span class="pcalibre1 pcalibre calibre18">ValueError</span>:
    logging.info(<span class="pcalibre1 pcalibre calibre13">"Invalid user input: </span><span class="pcalibre1 pcalibre calibre20">%s</span><span class="pcalibre1 pcalibre calibre13">"</span>, value)
    <span class="pcalibre1 pcalibre calibre18">raise</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">If <code class="pcalibre1 pcalibre literal">process_user_input</code> raises a <code class="pcalibre1 pcalibre literal">ValueError</code>, the <code class="pcalibre1 pcalibre literal">except</code> block will
execute the logging line. Other than that, the exception propagates as
normal.</p>
<p class="pcalibre1 pcalibre calibre7">It’s also useful when you need to execute code before deciding whether
to re-raise the exception at all. Earlier, we used a try/except
block pair to create an upload directory, logging an error if it
already exists:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre13"># Remember this? Python 3 code, from earlier.</span>
<span class="pcalibre1 pcalibre calibre18">import</span> <span class="pcalibre1 pcalibre calibre18">os</span>
<span class="pcalibre1 pcalibre calibre18">import</span> <span class="pcalibre1 pcalibre calibre18">logging</span>
UPLOAD_ROOT = <span class="pcalibre1 pcalibre calibre13">"/var/www/uploads/"</span>
<span class="pcalibre1 pcalibre calibre18">def</span> create_upload_dir(username):
    userdir = os.path.join(UPLOAD_ROOT, username)
    <span class="pcalibre1 pcalibre calibre18">try</span>:
        os.makedirs(userdir)
    <span class="pcalibre1 pcalibre calibre18">except</span> FileExistsError <span class="pcalibre1 pcalibre calibre18">as</span> err:
        logging.error(<span class="pcalibre1 pcalibre calibre13">"Upload dir already exists: </span><span class="pcalibre1 pcalibre calibre20">%s</span><span class="pcalibre1 pcalibre calibre13">"</span>,
            err.filename)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">This relies on <code class="pcalibre1 pcalibre literal">FileExistsError</code>, which was introduced in Python
3. How could you do this in Python 2? Even if you no longer write code
in Python 2, it’s worth studying the different approach required, as
it demonstrates a widely useful exception-handling pattern. Let’s take
a look.</p>
<p class="pcalibre1 pcalibre calibre7">

<code class="pcalibre1 pcalibre literal">FileExistsError</code> subclasses the more general <code class="pcalibre1 pcalibre literal">OSError</code>. This
exception type has been around since the early days of Python, and in
Python 2, <code class="pcalibre1 pcalibre literal">makedirs</code> simply raises <code class="pcalibre1 pcalibre literal">OSError</code>. But <code class="pcalibre1 pcalibre literal">OSError</code> can
indicate many problems other than the directory already existing: a
lack of filesystem permissions, a system call getting interrupted,
even a timeout over a network-mounted filesystem.  We need a way to
discriminate between these possibilities.</p>
<p class="pcalibre1 pcalibre calibre7">

<code class="pcalibre1 pcalibre literal">OSError</code> objects have an <code class="pcalibre1 pcalibre literal">errno</code> attribute, indicating the precise
error. These correspond to the variable <code class="pcalibre1 pcalibre literal">errno</code> in a C program, with
different integer values meaning different error conditions. Most
higher-level languages - including Python - reuse the constant names
defined in the C API; in particular, the standard constant for "file
already exists" is <code class="pcalibre1 pcalibre literal">EEXIST</code> (which happens to be set to the number 17
in most implementations). These constants are defined in the <code class="pcalibre1 pcalibre literal">errno</code>
module in Python, so we just type <code class="pcalibre1 pcalibre literal">from errno import EEXIST</code> in our
program.</p>
<p class="pcalibre1 pcalibre calibre7">In versions of Python with <code class="pcalibre1 pcalibre literal">FileExistsError</code>, the general pattern is:</p>
<div class="pcalibre1 pcalibre itemized-list">
<ul class="pcalibre1 calibre14 pcalibre">
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">Optimistically create the directory, and</span>
</li>
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">if <code class="pcalibre1 pcalibre literal">FileExistsError</code> is raised, catch it and log the event.</span>
</li>
</ul>
</div>
<p class="pcalibre1 pcalibre calibre7">In Python 2, we must do this instead:</p>
<div class="pcalibre1 pcalibre itemized-list">
<ul class="pcalibre1 calibre14 pcalibre">
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">Optimistically create the directory.</span>
</li>
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">if <code class="pcalibre1 pcalibre literal">OSError</code> is raised, catch it.</span>
</li>
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">Inspect the exception’s <code class="pcalibre1 pcalibre literal">errno</code> attribute. If it’s equal to
<code class="pcalibre1 pcalibre literal">EEXIST</code>, this means the directory already existed; log that event.</span>
</li>
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">If <code class="pcalibre1 pcalibre literal">errno</code> is something else, it means we don’t want to catch this
exception here; re-raise the error.</span>
</li>
</ul>
</div>
<p class="pcalibre1 pcalibre calibre7">The code:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre13"># How to accomplish the same in Python 2.</span>
<span class="pcalibre1 pcalibre calibre18">import</span> <span class="pcalibre1 pcalibre calibre18">os</span>
<span class="pcalibre1 pcalibre calibre18">import</span> <span class="pcalibre1 pcalibre calibre18">logging</span>
<span class="pcalibre1 pcalibre calibre18">from</span> <span class="pcalibre1 pcalibre calibre18">errno</span> <span class="pcalibre1 pcalibre calibre18">import</span> EEXIST
UPLOAD_ROOT = <span class="pcalibre1 pcalibre calibre13">"/var/www/uploads/"</span>
<span class="pcalibre1 pcalibre calibre18">def</span> create_upload_dir(username):
    userdir = os.path.join(UPLOAD_ROOT, username)
    <span class="pcalibre1 pcalibre calibre18">try</span>:
        os.makedirs(userdir)
    <span class="pcalibre1 pcalibre calibre18">except</span> <span class="pcalibre1 pcalibre calibre18">OSError</span> <span class="pcalibre1 pcalibre calibre18">as</span> err:
        <span class="pcalibre1 pcalibre calibre18">if</span> err.errno != EEXIST:
            <span class="pcalibre1 pcalibre calibre18">raise</span>
        logging.error(<span class="pcalibre1 pcalibre calibre13">"Upload dir already exists: </span><span class="pcalibre1 pcalibre calibre20">%s</span><span class="pcalibre1 pcalibre calibre13">"</span>,
            err.filename)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">The only difference between the Python 2 and 3 versions is the
"except" clause. But there’s a lot going on there. First, we’re
catching <code class="pcalibre1 pcalibre literal">OSError</code> rather than <code class="pcalibre1 pcalibre literal">FileExistsError</code>. But we may or may
not re-raise the exception, depending on the value of its <code class="pcalibre1 pcalibre literal">errno</code>
attribute. Basically, a value of <code class="pcalibre1 pcalibre literal">EEXIST</code> means the directory already
exists. So we log it and move on. Any other value indicates an error
we aren’t prepared to handle right here, so re-raise in order to pass
it to higher level code.</p>
</section>
<section class="calibre2 pcalibre1 pcalibre" title="The Most Diabolical Python Anti-Pattern">
<h2 id="calibre_link-95" class="pcalibre1 pcalibre calibre1">The Most Diabolical Python Anti-Pattern</h2>
<p class="pcalibre1 pcalibre calibre7">You know about "design patterns": time-tested solutions to common code
problems. And you’ve probably heard of "anti-patterns": solutions
people often choose to a code problem, because it <em class="pcalibre1 calibre8 pcalibre">seems</em> to be a good
approach, but actually turn out to be harmful.</p>
<p class="pcalibre1 pcalibre calibre7">In Python, one antipattern is most harmful of all.</p>
<p class="pcalibre1 pcalibre calibre7">I wish I could not even tell you about it. If you don’t know it
exists, you can’t use it in your code. Unfortunately, you might
stumble on it somewhere and adopt it, not realizing the danger. So,
it’s my duty to warn you.</p>
<p class="pcalibre1 pcalibre calibre7">Hereâ€™s the punchline. The following is the most self-destructive
code a Python developer can write:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">try</span>:
    do_something()
<span class="pcalibre1 pcalibre calibre18">except</span>:
    <span class="pcalibre1 pcalibre calibre18">pass</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Python lets you completely omit the argument to <code class="pcalibre1 pcalibre literal">except</code>. If you do
that, it will catch <em class="pcalibre1 calibre8 pcalibre">every exception</em>. That’s pretty harmful right
there; remember, the more pin-pointed your <code class="pcalibre1 pcalibre literal">except</code> clauses are, the
more precise your error handling can be, without sweeping unrelated
errors under the rug. And typing <code class="pcalibre1 pcalibre literal">except:</code> will sweep <em class="pcalibre1 calibre8 pcalibre">every</em>
unrelated error under the rug.</p>
<p class="pcalibre1 pcalibre calibre7">But it’s much worse than that, because of the <code class="pcalibre1 pcalibre literal">pass</code> in the <code class="pcalibre1 pcalibre literal">except</code>
clause. What <code class="pcalibre1 pcalibre literal">except: pass</code> does is silently and invisibly hide error
conditions that you’d otherwise quickly detect and fix.</p>
<p class="pcalibre1 pcalibre calibre7">(Instead of <code class="pcalibre1 pcalibre literal">"except:"</code>, you’ll sometimes see variants like <code class="pcalibre1 pcalibre literal">"except
Exception:"</code> or <code class="pcalibre1 pcalibre literal">"except Exception as ex:"</code>. They amount to the same
thing.)</p>
<p class="pcalibre1 pcalibre calibre7">This creates the <strong class="pcalibre1 pcalibre calibre9">worst kind of bug</strong>. Have you ever been
troubleshooting a bug, and just couldn’t figure out where in the code
base it came from, even after hours of searching, getting more and
more frustrated as the minutes and hours roll by? <em class="pcalibre1 calibre8 pcalibre">This is how you
create that in Python.</em></p>
<p class="pcalibre1 pcalibre calibre7">I first understood this anti-pattern after joining an engineering
team, in an explosively-growing Silicon Valley start-up. The
company’s product was a web service, which needed to be up 24/7. So
engineers took turns being "on call" in case of a critical issue.  An
obscure Unicode bug somehow kept triggering, waking up an engineer -
in the middle of the night! - several times a week. But no one could
figure out how to reproduce the bug, or even track down exactly how it
was happening in the large code base.</p>
<p class="pcalibre1 pcalibre calibre7">After a few months of this nonsense, some of the senior engineers got
fed up and devoted themselves to rooting out the problem. One senior
engineer did nothing for <em class="pcalibre1 calibre8 pcalibre">three full days</em> except investigate it,
ignoring other responsibilities as they piled up. He made some
progress, and took useful notes on what he found, but in the end did
not figure it out. He ran out of time, and had to give up.</p>
<p class="pcalibre1 pcalibre calibre7">Then, a second senior engineer took over. Using those notes as a
starting point, he also dug into it, ignoring emails and other
commitments for <em class="pcalibre1 calibre8 pcalibre">another three full days</em> to track down the
problem. And he failed. He make progress, adding usefully to the
notes. But in the end, he had to give up too, when other
responsibilities could no longer be ignored.</p>
<p class="pcalibre1 pcalibre calibre7">Finally, after these six days, they passed the torch to me - the new
engineer on the team. I wasn’t too familiar with the code base, but
their notes gave me a lot to go on. So I dove in on Day 7, and
completely ignored everything else for six hours straight.</p>
<p class="pcalibre1 pcalibre calibre7">And finally, late in the day, I was able to isolate the problem to a single
block of code:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">try</span>:
    extract_address(location_data)
<span class="pcalibre1 pcalibre calibre18">except</span>:
    <span class="pcalibre1 pcalibre calibre18">pass</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">That was it. The data in <code class="pcalibre1 pcalibre literal">location_data</code> was corrupted, causing the
<code class="pcalibre1 pcalibre literal">extract_address</code> call to raise a <code class="pcalibre1 pcalibre literal">UnicodeError</code>. Which the program
then <em class="pcalibre1 calibre8 pcalibre">completely silenced</em>. Not even producing a stack trace; simply
moving on, as if nothing had happened.</p>
<p class="pcalibre1 pcalibre calibre7">After nearly <em class="pcalibre1 calibre8 pcalibre">seven full days</em> of engineer effort, we pinpointed the
error to this one block of code. I un-suppressed the exception, and
was almost immediately able to reproduce the bug - with a full and
very informative stack trace.</p>
<p class="pcalibre1 pcalibre calibre7">Once I did that, can you guess how long it took us to fix the bug?</p>
<p class="pcalibre1 pcalibre calibre7"><strong class="pcalibre1 pcalibre calibre9">TEN MINUTES</strong>.</p>
<p class="pcalibre1 pcalibre calibre7">That’s right. A full WEEK of engineer time was wasted, all because
this anti-pattern somehow snuck into our code base. Had it not, then
the first time it woke up an engineer, it would have been obvious what
the problem was, and how to fix it. The code would have been patched
by the end of the day, and we would all have moved on to bigger and
better things.</p>
<p class="pcalibre1 pcalibre calibre7">The cruelty of this anti-pattern comes from how it completely hides
<em class="pcalibre1 calibre8 pcalibre">all</em> helpful information. Normally, when a bug causes a problem in
your code, you can inspect the stack trace; identify what lines of
code are involved; and start solving it. With The Most Diabolical
Python Antipattern (TMDPA), none of that information is
available. What line of code did the error come from? Which <em class="pcalibre1 calibre8 pcalibre">file</em> in
your Python application, for that matter? In fact, what was the
exception type?  Was it a <code class="pcalibre1 pcalibre literal">KeyError</code>? A <code class="pcalibre1 pcalibre literal">UnicodeError</code>? Or even a
<code class="pcalibre1 pcalibre literal">NameError</code>, coming from a mis-typed variable name? Was it <code class="pcalibre1 pcalibre literal">OSError</code>,
and if so, what was its <code class="pcalibre1 pcalibre literal">errno</code>? You don’t know. You <em class="pcalibre1 calibre8 pcalibre">can’t</em> know.</p>
<p class="pcalibre1 pcalibre calibre7">In fact, TMDPA often <strong class="pcalibre1 pcalibre calibre9">hides the fact that an error even occurs</strong>. This
is one of the ways bugs hide from you during development, then sneak
into production, where they’re free to cause real damage.</p>
<p class="pcalibre1 pcalibre calibre7">We never did figure out why the original developer wrote <code class="pcalibre1 pcalibre literal">except:
pass</code> to begin with. I think that at the time, <code class="pcalibre1 pcalibre literal">location_data</code> may
have sometimes been empty, causing <code class="pcalibre1 pcalibre literal">extract_address</code> to
innocuously raise a <code class="pcalibre1 pcalibre literal">ValueError</code>. In other words, if <code class="pcalibre1 pcalibre literal">ValueError</code> was
raised, it was appropriate to ignore that and move on. By the time the
other two engineers and I were involved, the code base had changed so
that was no longer how things worked. But the broad <code class="pcalibre1 pcalibre literal">except</code> block
remained, like a land mine lurking in a lush field.</p>
<p class="pcalibre1 pcalibre calibre7">So why do people do this? Well, no one <em class="pcalibre1 calibre8 pcalibre">wants</em> to wreak such havoc in
their Python code, of course. People do this because they expect
errors to occur in the normal course of operation, in some specific
way. They are simply catching too broadly, without realizing the full
implications.</p>
<p class="pcalibre1 pcalibre calibre7">So what do you do instead? There are two basic choices. In most cases,
it’s best to modify the <code class="pcalibre1 pcalibre literal">except</code> clause to catch a more specific
exception. For the situation above, this would have been a much better
choice:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">try</span>:
    extract_address(location_data)
<span class="pcalibre1 pcalibre calibre18">except</span> <span class="pcalibre1 pcalibre calibre18">ValueError</span>:
    <span class="pcalibre1 pcalibre calibre18">pass</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Here, <code class="pcalibre1 pcalibre literal">ValueError</code> is caught and appropriately ignored. If
<code class="pcalibre1 pcalibre literal">UnicodeError</code> raises, it propagates and (if not caught) the program
crashes. That would have been <em class="pcalibre1 calibre8 pcalibre">great</em> in our situation. The error log
would have a full stack trace clearly telling us what happened, and
we’d be able to fix it in ten minutes.</p>
<p class="pcalibre1 pcalibre calibre7">As a variation, you may want to insert some logging:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">try</span>:
    extract_address(location_data)
<span class="pcalibre1 pcalibre calibre18">except</span> <span class="pcalibre1 pcalibre calibre18">ValueError</span>:
    logging.info(
        <span class="pcalibre1 pcalibre calibre13">"Invalid location for user </span><span class="pcalibre1 pcalibre calibre20">%s</span><span class="pcalibre1 pcalibre calibre13">"</span>, username)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">The other reason people write <code class="pcalibre1 pcalibre literal">except: pass</code> is a bit more
valid. Sometimes, a code path simply must broadly catch all
exceptions, and continue running regardless. This is common in the
top-level loop for a long-running, persistent process. The problem
is that <code class="pcalibre1 pcalibre literal">except: pass</code> hides all information about the problem,
including that the problem even exists.</p>
<p class="pcalibre1 pcalibre calibre7">Fortunately, Python provides an easy way to capture that error event,
and all the information you need to fix it. The <code class="pcalibre1 pcalibre literal">logging</code> module has a
function called <code class="pcalibre1 pcalibre literal">exception</code>, which will log your message <em class="pcalibre1 calibre8 pcalibre">along with
the full stack trace of the current exception</em>. So you can write code
like this:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">import</span> <span class="pcalibre1 pcalibre calibre18">logging</span>
<span class="pcalibre1 pcalibre calibre18">def</span> get_number():
    <span class="pcalibre1 pcalibre calibre18">return</span> int(<span class="pcalibre1 pcalibre calibre13">'foo'</span>)
<span class="pcalibre1 pcalibre calibre18">try</span>:
    x = get_number()
<span class="pcalibre1 pcalibre calibre18">except</span>:
    logging.exception(<span class="pcalibre1 pcalibre calibre13">'Caught an error'</span>)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">The log will contain the error message, followed by a formatted stack trace spread across several lines:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11">ERROR:root:Caught an error
Traceback (most recent call last):
  File "example-logging-exception.py", line 5, in &lt;module&gt;
    x = get_number()
  File "example-logging-exception.py", line 3, in get_number
    return int('foo')
ValueError: invalid literal for int() with base 10: 'foo'</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">This stack trace is <em class="pcalibre1 calibre8 pcalibre">priceless</em>. Especially in more complex
applications, it’s often not enough to know the file and line number
where an error occurs. It’s at least as important to know <em class="pcalibre1 calibre8 pcalibre">how</em> that
function or method was called…​ what path of executed code led to it
being invoked. Otherwise you can never determine what conditions lead
to that function or method being called in the first place. The stack
trace, in contrast, gives you everything you need to know.</p>
<p class="pcalibre1 pcalibre calibre7">I wish <code class="pcalibre1 pcalibre literal">"except: pass"</code> was not valid Python syntax. I think much grief
would be spared if it was. But it’s not my call, and changing it now
is probably not practical. Your only defense is to be vigilant. That
includes educating your fellow developers. Does your team hold regular
engineering meetings? Ask for five minutes at the next one to explain
this antipattern, the cost it has to everyone’s productivity, and the
simple solutions.</p>
<p class="pcalibre1 pcalibre calibre7">Even better: if there are local Python or technical meetups in your
area, volunteer to give a short talk - five to fifteen minutes. These
meetups almost always need speakers, and you will be helping so many
of your fellow developers in the audience.</p>
<p class="pcalibre1 calibre7 pcalibre7">There is a longer article explaining this situation at
<a class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4" href="https://powerfulpython.com/blog/the-most-diabolical-python-antipattern/">https://powerfulpython.com/blog/the-most-diabolical-python-antipattern/</a>
. Simply sharing the URL will educate people too.  And feel free to
write your own blog post, with your own explanation of the situation,
and how to fix it. Serve your fellow engineers by evangelizing this
important knowledge.</p>
</section>
<footer class="pcalibre1 pcalibre calibre15">
<div class="calibre16 pcalibre1 pcalibre"></div><div class="pcalibre1 pcalibre chapter-footer">
<div class="pcalibre1 pcalibre footnotes">
<aside id="calibre_link-29" type="footnote" class="calibre2 pcalibre1 pcalibre">
<p class="pcalibre1 calibre17 pcalibre"><sup class="noteref1 pcalibre1 pcalibre"><a href="#calibre_link-33" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">1</a></sup> Not a real library, so far as I know. But after this book is published, I’m sure one of you will make a library with that name, just to mess with me.</p>
</aside>
<aside id="calibre_link-30" type="footnote" class="calibre2 pcalibre1 pcalibre">
<p class="pcalibre1 calibre17 pcalibre"><sup class="noteref1 pcalibre1 pcalibre"><a href="#calibre_link-34" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">2</a></sup> Especially in larger applications, exception handling often integrates with logging. See the logging chapter for details.</p>
</aside>
<aside id="calibre_link-31" type="footnote" class="calibre2 pcalibre1 pcalibre">
<p class="pcalibre1 calibre17 pcalibre"><sup class="noteref1 pcalibre1 pcalibre"><a href="#calibre_link-35" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">3</a></sup> Python 2 does something different, and more complex. We’ll cover that in detail later. For now, keep reading.</p>
</aside>
<aside id="calibre_link-32" type="footnote" class="calibre2 pcalibre1 pcalibre">
<p class="pcalibre1 calibre17 pcalibre"><sup class="noteref1 pcalibre1 pcalibre"><a href="#calibre_link-36" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">4</a></sup> It’s better to make this a class method of <code class="pcalibre1 pcalibre literal">Money</code>, rather than a separate function. That is a separate topic, though; see <code class="pcalibre1 pcalibre literal">@classmethod</code> in the object-oriented patterns chapter for details.</p>
</aside>
</div>
</div>
</footer>
</section>
</div>


<div id="calibre_link-138" class="pcalibre1 pcalibre calibre">
<section class="calibre2 pcalibre1 pcalibre" id="calibre_link-180" title="Classes and Objects: Beyond The Basics" type="chapter">
<header id="calibre_link-96" class="calibre2 pcalibre1 pcalibre">
<div class="pcalibre1 pcalibre chapter-header">
<h1 class="pcalibre1 chapter-title pcalibre">CLASSES AND OBJECTS <small class="subtitle pcalibre1 pcalibre"><b class="pcalibre1 pcalibre calibre6">BEYOND</b> <b class="pcalibre1 pcalibre calibre6">THE</b> <b class="pcalibre1 pcalibre calibre6">BASICS</b></small></h1>
</div>
</header>
<p class="pcalibre1 pcalibre calibre7">This chapter assumes you are familiar with Python’s OOP basics:
creating classes, defining methods, and using inheritance. We build on
this.</p>
<p class="pcalibre1 pcalibre calibre7">As with any object-oriented language, it’s useful to learn about
<strong class="pcalibre1 pcalibre calibre9">design patterns</strong> - reusable solutions to common problems involving
classes and objects. A LOT has been written about design
patterns. Curiously, though, much of what’s out there doesn’t
completely apply to Python - or, at least, it applies <em class="pcalibre1 calibre8 pcalibre">differently</em>.</p>
<p class="pcalibre1 pcalibre calibre7">That’s because many of these design-pattern books, articles, and blog
posts are for languages like Java, C++ and C#. But as a language,
Python is quite different.  Its dynamic typing, first-class functions,
and other additions all mean the "standard" design patterns just work
differently.</p>
<p class="pcalibre1 pcalibre calibre7">So let’s learn what Pythonic OOP is <em class="pcalibre1 calibre8 pcalibre">really</em> about.</p>
<section class="calibre2 pcalibre1 pcalibre" title="Quick Note on Python 2">
<h2 id="calibre_link-97" class="pcalibre1 pcalibre calibre1">Quick Note on Python 2</h2>
<p class="pcalibre1 pcalibre calibre7">
This chapter uses Python 3 syntax. Python 2.7 is nearly the same, and
I’ll point out the few differences as we go along. But there is one
<em class="pcalibre1 calibre8 pcalibre">big</em> difference worth emphasizing here.</p>
<p class="pcalibre1 pcalibre calibre7">In modern Python, all classes need to inherit from a built-in base
class called <code class="pcalibre1 pcalibre literal">object</code>. (It’s lowercased, defying the normal
convention.) This happens automatically for all classes in Python 3:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13"># Python 3</span>
... <span class="pcalibre1 pcalibre calibre18">class</span> <span class="pcalibre1 pcalibre calibre18">Dog</span>:
...     <span class="pcalibre1 pcalibre calibre18">def</span> speak(self):
...         <span class="pcalibre1 pcalibre calibre18">return</span> <span class="pcalibre1 pcalibre calibre13">"woof"</span>
...
&gt;&gt;&gt; dog = Dog()
&gt;&gt;&gt; isinstance(dog, object)
True</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">In Python 2, you must explicitly inherit your classes from
<code class="pcalibre1 pcalibre literal">object</code>. Fail to do this, and your class builds on "old-style
classes":</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13"># Python 2</span>
... <span class="pcalibre1 pcalibre calibre18">class</span> <span class="pcalibre1 pcalibre calibre18">DogFromObject</span>(object):
...     <span class="pcalibre1 pcalibre calibre18">def</span> speak(self):
...         <span class="pcalibre1 pcalibre calibre18">return</span> <span class="pcalibre1 pcalibre calibre13">"woof"</span>
...
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre18">class</span> <span class="pcalibre1 pcalibre calibre18">DogNotFromObject</span>:
...     <span class="pcalibre1 pcalibre calibre18">def</span> speak(self):
...         <span class="pcalibre1 pcalibre calibre18">return</span> <span class="pcalibre1 pcalibre calibre13">"woof"</span>
...
&gt;&gt;&gt; issubclass(DogFromObject, object)
True
&gt;&gt;&gt; issubclass(DogNotFromObject, object)
False</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">If you don’t already base your Python 2 classes on <code class="pcalibre1 pcalibre literal">object</code>, start
today. Old-style classes are long obsolete, and removed in Python
3; they partially or completely break many important tools in Python’s
object system, like properties and <code class="pcalibre1 pcalibre literal">super()</code>. The rest of this
chapter assumes you’re inheriting from <code class="pcalibre1 pcalibre literal">object</code>.</p>
</section>
<section class="calibre2 pcalibre1 pcalibre" title="Properties">
<h2 id="calibre_link-98" class="pcalibre1 pcalibre calibre1">Properties</h2>
<p class="pcalibre1 pcalibre calibre7">


In
object-oriented programming, a <em class="pcalibre1 calibre8 pcalibre">property</em> is a special sort of object
attribute. It’s almost a cross between a method and an attribute. The
idea is that you can, when designing the class, create "attributes"
whose reading, writing, and so on can be managed by special
methods. In Python, you do this with a decorator named
<code class="pcalibre1 pcalibre literal">property</code>. Here’s an example:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">class</span> <span class="pcalibre1 pcalibre calibre18">Person</span>:
    <span class="pcalibre1 pcalibre calibre18">def</span> __init__(self, firstname, lastname):
        self.firstname = firstname
        self.lastname = lastname

    @property
    <span class="pcalibre1 pcalibre calibre18">def</span> fullname(self):
        <span class="pcalibre1 pcalibre calibre18">return</span> self.firstname + <span class="pcalibre1 pcalibre calibre13">" "</span> + self.lastname</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">By instantiating this, I can access <code class="pcalibre1 pcalibre literal">fullname</code> as a kind of virtual
attribute:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; joe = Person(<span class="pcalibre1 pcalibre calibre13">"Joe"</span>, <span class="pcalibre1 pcalibre calibre13">"Smith"</span>)
&gt;&gt;&gt; joe.fullname
<span class="pcalibre1 pcalibre calibre13">'Joe Smith'</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Notice carefully the members here: there are two attributes called
<code class="pcalibre1 pcalibre literal">firstname</code> and <code class="pcalibre1 pcalibre literal">lastname</code>, set in the constructor. There is also a
method called <code class="pcalibre1 pcalibre literal">fullname</code>. But after creating the object, we reference
<code class="pcalibre1 pcalibre literal">joe.fullname</code> as an attribute; we don’t call <code class="pcalibre1 pcalibre literal">joe.fullname()</code> as a
method.</p>
<p class="pcalibre1 pcalibre calibre7">This is all due to the <code class="pcalibre1 pcalibre literal">@property</code> decorator. When applied to a
method, this decorator makes it inaccessible as a method. You must
access it as an attribute. In fact, if you try to call it as a method,
you get an error:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; joe.fullname()
Traceback (most recent call last):
  File <span class="pcalibre1 pcalibre calibre13">"&lt;stdin&gt;"</span>, line 1, <span class="pcalibre1 pcalibre calibre18">in</span> &lt;module&gt;
<span class="pcalibre1 pcalibre calibre18">TypeError</span>: <span class="pcalibre1 pcalibre calibre13">'str'</span> object <span class="pcalibre1 pcalibre calibre18">is</span> <span class="pcalibre1 pcalibre calibre18">not</span> callable</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">As defined above, <code class="pcalibre1 pcalibre literal">fullname</code> is read-only. We can’t modify
it:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; joe.fullname = <span class="pcalibre1 pcalibre calibre13">"Joseph Smith"</span>
Traceback (most recent call last):
  File <span class="pcalibre1 pcalibre calibre13">"&lt;stdin&gt;"</span>, line 1, <span class="pcalibre1 pcalibre calibre18">in</span> &lt;module&gt;
<span class="pcalibre1 pcalibre calibre18">AttributeError</span>: can<span class="pcalibre1 pcalibre calibre13">'t set attribute</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">In other words, Python properties are read-only by default. Another
way of saying this is that <code class="pcalibre1 pcalibre literal">@property</code> automatically defines a
<em class="pcalibre1 calibre8 pcalibre">getter</em>, but not a <em class="pcalibre1 calibre8 pcalibre">setter</em>. If you do want <code class="pcalibre1 pcalibre literal">fullname</code> to be
writable, here is how you define the setter:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">class</span> <span class="pcalibre1 pcalibre calibre18">Person</span>:
    <span class="pcalibre1 pcalibre calibre18">def</span> __init__(self, firstname, lastname):
        self.firstname = firstname
        self.lastname = lastname

    @property
    <span class="pcalibre1 pcalibre calibre18">def</span> fullname(self):
        <span class="pcalibre1 pcalibre calibre18">return</span> self.firstname + <span class="pcalibre1 pcalibre calibre13">" "</span> + self.lastname

    @fullname.setter
    <span class="pcalibre1 pcalibre calibre18">def</span> fullname(self, value):
        self.firstname, self.lastname = value.split(<span class="pcalibre1 pcalibre calibre13">" "</span>, 1)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">This lets us assign to <code class="pcalibre1 pcalibre literal">joe.fullname</code>:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; joe = Person(<span class="pcalibre1 pcalibre calibre13">"Joe"</span>, <span class="pcalibre1 pcalibre calibre13">"Smith"</span>)
&gt;&gt;&gt; joe.firstname
<span class="pcalibre1 pcalibre calibre13">'Joe'</span>
&gt;&gt;&gt; joe.lastname
<span class="pcalibre1 pcalibre calibre13">'Smith'</span>
&gt;&gt;&gt; joe.fullname = <span class="pcalibre1 pcalibre calibre13">"Joseph Smith"</span>
&gt;&gt;&gt; joe.firstname
<span class="pcalibre1 pcalibre calibre13">'Joseph'</span>
&gt;&gt;&gt; joe.lastname
<span class="pcalibre1 pcalibre calibre13">'Smith'</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">The first time I saw this, I had all sorts of questions. "Wait, why is
<code class="pcalibre1 pcalibre literal">fullname</code> defined twice? And why is the second decorator named
<code class="pcalibre1 pcalibre literal">@fullname</code>, and what’s this <code class="pcalibre1 pcalibre literal">setter</code> attribute? How on earth does
this even compile?"</p>
<p class="pcalibre1 pcalibre calibre7">The code is actually correct, and designed to work this way. The
<code class="pcalibre1 pcalibre literal">@property</code> <code class="pcalibre1 pcalibre literal">def</code> <code class="pcalibre1 pcalibre literal">fullname</code> must come first. That creates the property
to begin with, and <em class="pcalibre1 calibre8 pcalibre">also</em> creates the getter. By "create the
property", I mean that an object named <code class="pcalibre1 pcalibre literal">fullname</code> exists <em class="pcalibre1 calibre8 pcalibre">in the
namespace of the class</em>, and it has a method named <code class="pcalibre1 pcalibre literal">fullname.setter</code>.
This <code class="pcalibre1 pcalibre literal">fullname.setter</code> is a decorator that is applied to the next
<code class="pcalibre1 pcalibre literal">def fullname</code>, christening it as the setter for the <code class="pcalibre1 pcalibre literal">fullname</code>
property.</p>
<p class="pcalibre1 pcalibre calibre7">It’s okay to not fully understand how this all works. A full
explanation relies on understanding both implementing decorators, and
Python’s descriptor protocol, both of which are beyond the scope of
what we want to focus on here. Fortunately, you don’t have to
understand <em class="pcalibre1 calibre8 pcalibre">how</em> it works in order to use it.</p>
<p class="pcalibre1 pcalibre calibre7">(Besides getting and setting, you can handle the <code class="pcalibre1 pcalibre literal">del</code> operation for
the object attribute by decorating with <code class="pcalibre1 pcalibre literal">@fullname.deleter</code>. You won’t
need this very often, but it’s available when you do.)</p>
<p class="pcalibre1 pcalibre calibre7">What you see here with the <code class="pcalibre1 pcalibre literal">Person</code> class is one way properties are
useful: magic attributes whose values are derived from other
values. This denormalizes the object’s data, and lets you access the
property value as an attribute instead of as a method. You’ll see a
situation where that’s extremely useful later.</p>
<p class="pcalibre1 pcalibre calibre7">Properties enable a useful collection of design patterns. One - as
mentioned - is in creating read-only member variables. In <code class="pcalibre1 pcalibre literal">Person</code>,
the <code class="pcalibre1 pcalibre literal">fullname</code> "member variable" is a dynamic attribute; it doesn’t
exist on its own, but instead calculates its value at
run-time.</p>
<p class="pcalibre1 pcalibre calibre7">It’s also common to have the property backed by a single, non-public
member variable. That pattern looks like this:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">class</span> <span class="pcalibre1 pcalibre calibre18">Coupon</span>:
    <span class="pcalibre1 pcalibre calibre18">def</span> __init__(self, amount):
        self._amount = amount
    @property
    <span class="pcalibre1 pcalibre calibre18">def</span> amount(self):
        <span class="pcalibre1 pcalibre calibre18">return</span> self._amount</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">This allows the class itself to modify the value internally, but
prevent outside code from doing so:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; coupon = Coupon(1.25)
&gt;&gt;&gt; coupon.amount
1.25
&gt;&gt;&gt; coupon.amount = 1.50
Traceback (most recent call last):
  File <span class="pcalibre1 pcalibre calibre13">"&lt;stdin&gt;"</span>, line 1, <span class="pcalibre1 pcalibre calibre18">in</span> &lt;module&gt;
<span class="pcalibre1 pcalibre calibre18">AttributeError</span>: can<span class="pcalibre1 pcalibre calibre13">'t set attribute</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">In Python, prefixing a member variable by a single underscore signals
the variable is non-public, i.e. it should only be accessed
internally, inside methods of that class, or its
subclasses.<sup class="pcalibre1 pcalibre noteref">[<a href="#calibre_link-139" id="calibre_link-143" type="noteref" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">1</a>]</sup> What this pattern says is "you can access this
variable, but not change it".</p>
<p class="pcalibre1 pcalibre calibre7">Between "regular member variable" and "ready-only" is another pattern:
allow changing the attribute, but validate it first. Suppose my
event-management application has a <code class="pcalibre1 pcalibre literal">Ticket</code> class, representing
tickets sold to concert-goers:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">class</span> <span class="pcalibre1 pcalibre calibre18">Ticket</span>:
    <span class="pcalibre1 pcalibre calibre18">def</span> __init__(self, price):
        self.price = price
    <span class="pcalibre1 pcalibre calibre13"># And some other methods...</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">One day, we find a bug in our web UI, which lets some shifty customers
adjust the price to a negative value…​ so we ended up actually
<em class="pcalibre1 calibre8 pcalibre">paying</em> them to go to the concert. Not good!</p>
<p class="pcalibre1 pcalibre calibre7">The first priority is, of course, to fix the bug in the UI. But how do
we modify our code to prevent this from ever happening again? Before
reading further, look at the <code class="pcalibre1 pcalibre literal">Ticket</code> class and ponder - how could you
use properties to make this kind of bug impossible in the future?</p>
<p class="pcalibre1 pcalibre calibre7">The answer: verify the new price is non-zero in the setter:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre13"># Version 1...</span>
<span class="pcalibre1 pcalibre calibre18">class</span> <span class="pcalibre1 pcalibre calibre18">Ticket</span>:
    <span class="pcalibre1 pcalibre calibre18">def</span> __init__(self, price):
        self._price = price
    @property
    <span class="pcalibre1 pcalibre calibre18">def</span> price(self):
        <span class="pcalibre1 pcalibre calibre18">return</span> self._price
    @price.setter
    <span class="pcalibre1 pcalibre calibre18">def</span> price(self, new_price):
        <span class="pcalibre1 pcalibre calibre13"># Only allow positive prices.</span>
        <span class="pcalibre1 pcalibre calibre18">if</span> new_price &lt; 0:
            <span class="pcalibre1 pcalibre calibre18">raise</span> <span class="pcalibre1 pcalibre calibre18">ValueError</span>(<span class="pcalibre1 pcalibre calibre13">"Nice try"</span>)
        self._price = new_price</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">This lets the price be adjusted…​ but only to sensible values:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11">&gt;&gt;&gt; t = Ticket(42)
&gt;&gt;&gt; t.price = 24 # This is allowed.
&gt;&gt;&gt; print(t.price)
24
&gt;&gt;&gt; t.price = -1 # This is NOT.
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 11, in price
ValueError: Nice try</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">However, there’s a defect in this new <code class="pcalibre1 pcalibre literal">Ticket</code> class. Can you spot
what it is? (And how to fix it?)</p>
<p class="pcalibre1 pcalibre calibre7">The problem is that while we can’t <em class="pcalibre1 calibre8 pcalibre">change</em> the price to a negative
value, this first version lets us <em class="pcalibre1 calibre8 pcalibre">create</em> a ticket with a negative
price to begin with. That’s because we write <code class="pcalibre1 pcalibre literal">self._price = price</code> in
the constructor. The solution is to use the <em class="pcalibre1 calibre8 pcalibre">setter</em> in the
constructor instead:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre13"># Final version, with modified constructor. (Constructor</span>
<span class="pcalibre1 pcalibre calibre13"># is different; code for getter &amp; setter is the same.)</span>
<span class="pcalibre1 pcalibre calibre18">class</span> <span class="pcalibre1 pcalibre calibre18">Ticket</span>:
    <span class="pcalibre1 pcalibre calibre18">def</span> __init__(self, price):
        <span class="pcalibre1 pcalibre calibre13"># instead of "self._price = price"</span>
        self.price = price
    @property
    <span class="pcalibre1 pcalibre calibre18">def</span> price(self):
        <span class="pcalibre1 pcalibre calibre18">return</span> self._price
    @price.setter
    <span class="pcalibre1 pcalibre calibre18">def</span> price(self, new_price):
        <span class="pcalibre1 pcalibre calibre13"># Only allow positive prices.</span>
        <span class="pcalibre1 pcalibre calibre18">if</span> new_price &lt; 0:
            <span class="pcalibre1 pcalibre calibre18">raise</span> <span class="pcalibre1 pcalibre calibre18">ValueError</span>(<span class="pcalibre1 pcalibre calibre13">"Nice try"</span>)
        self._price = new_price</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Yes, you can reference <code class="pcalibre1 pcalibre literal">self.price</code> in methods of the class. When we
write <code class="pcalibre1 pcalibre literal">self.price = price</code>, Python translates this to calling the
<code class="pcalibre1 pcalibre literal">price</code> setter - i.e., the second <code class="pcalibre1 pcalibre literal">price()</code> method. This final version
of <code class="pcalibre1 pcalibre literal">Ticket</code> centralizes all reads AND writes of <code class="pcalibre1 pcalibre literal">self._price</code> in the
property. It’s a useful encapsulation principle in general. The idea
is you centralize any special behavior for that member variable in the
getter and setter, even for the class’s internal code. In practice,
sometimes methods need to violate this rule; you simply reference
<code class="pcalibre1 pcalibre literal">self._price</code> and move on. But avoid that where you can, and you will
tend to benefit from higher quality code.</p>
<section class="calibre2 pcalibre1 pcalibre" title="Properties and Refactoring">
<h3 id="calibre_link-181" class="pcalibre1 calibre21 pcalibre">Properties and Refactoring</h3>
<p class="pcalibre1 pcalibre calibre7">
Properties are important in most languages today.  Here’s a situation
that often plays out. Imagine writing a simple money class:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">class</span> <span class="pcalibre1 pcalibre calibre18">Money</span>:
    <span class="pcalibre1 pcalibre calibre18">def</span> __init__(self, dollars, cents):
        self.dollars = dollars
        self.cents = cents
    <span class="pcalibre1 pcalibre calibre13"># And some other methods...</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Suppose you put this class in a library, which many developers are
using. People on your current team, perhaps developers on different
teams. Or maybe you release it as open-source, so developers
around the world use and rely on this class.</p>
<p class="pcalibre1 pcalibre calibre7">Now, one day you realize many of <code class="pcalibre1 pcalibre literal">Money</code>​'s methods - which do calculations
on the money amount - can be simpler and more straightforward
if they operate on the total number of cents, rather than
dollars and cents separately. So you refactor the internal state:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">class</span> <span class="pcalibre1 pcalibre calibre18">Money</span>:
    <span class="pcalibre1 pcalibre calibre18">def</span> __init__(self, dollars, cents):
        self.total_cents = dollars * 100 + cents</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">This minor change creates a MAJOR maintainability problem. Can you spot it?</p>
<p class="pcalibre1 pcalibre calibre7">Here’s the trouble: your original <code class="pcalibre1 pcalibre literal">Money</code> has attributes named
<code class="pcalibre1 pcalibre literal">dollars</code> and <code class="pcalibre1 pcalibre literal">cents</code>. And since many developers are using these,
changing to <code class="pcalibre1 pcalibre literal">total_cents</code> breaks all their code!</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>money = Money(27, 12)
message = <span class="pcalibre1 pcalibre calibre13">"I have {:d} dollars and {:d} cents."</span>
<span class="pcalibre1 pcalibre calibre13"># This line breaks, because there's no longer</span>
<span class="pcalibre1 pcalibre calibre13"># dollars or cents attributes.</span>
<span class="pcalibre1 pcalibre calibre18">print</span>(message.format(money.dollars, money.cents))</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">If no one but you uses this class, there’s no real problem - you can just
refactor your own code. But if that’s not the case, coordinating this
change with everyone’s different code bases is a nightmare. It becomes
a barrier to improving your own code.</p>
<p class="pcalibre1 pcalibre calibre7">So, what do you do? Can you think of a way to handle this situation?</p>
<p class="pcalibre1 pcalibre calibre7">You get out of this mess is with properties. You want two things to
happen:</p>
<div class="pcalibre1 pcalibre itemized-list">
<ol class="pcalibre1 arabic pcalibre">
<li value="1" class="pcalibre1 pcalibre calibre4">
<span class="pcalibre1 principal pcalibre">Use <code class="pcalibre1 pcalibre literal">total_cents</code> internally, and</span>
</li>
<li value="2" class="pcalibre1 pcalibre calibre4">
<span class="pcalibre1 principal pcalibre">All code using <code class="pcalibre1 pcalibre literal">dollars</code> and <code class="pcalibre1 pcalibre literal">cents</code> continues to work, without modification.</span>
</li>
</ol>
</div>
<p class="pcalibre1 pcalibre calibre7">You do this by replacing <code class="pcalibre1 pcalibre literal">dollars</code> and <code class="pcalibre1 pcalibre literal">cents</code> with <code class="pcalibre1 pcalibre literal">total_cents</code>
internally, but also creating getters and setters for these
attributes. Take a look:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">class</span> <span class="pcalibre1 pcalibre calibre18">Money</span>:
    <span class="pcalibre1 pcalibre calibre18">def</span> __init__(self, dollars, cents):
        self.total_cents = dollars * 100 + cents
    <span class="pcalibre1 pcalibre calibre13"># Getter and setter for dollars...</span>
    @property
    <span class="pcalibre1 pcalibre calibre18">def</span> dollars(self):
        <span class="pcalibre1 pcalibre calibre18">return</span> self.total_cents // 100
    @dollars.setter
    <span class="pcalibre1 pcalibre calibre18">def</span> dollars(self, new_dollars):
        self.total_cents = 100 * new_dollars + self.cents
    <span class="pcalibre1 pcalibre calibre13"># And for cents.</span>
    @property
    <span class="pcalibre1 pcalibre calibre18">def</span> cents(self):
        <span class="pcalibre1 pcalibre calibre18">return</span> self.total_cents % 100
    @cents.setter
    <span class="pcalibre1 pcalibre calibre18">def</span> cents(self, new_cents):
        self.total_cents = 100 * self.dollars + new_cents</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Now, I can get and set <code class="pcalibre1 pcalibre literal">dollars</code> and <code class="pcalibre1 pcalibre literal">cents</code> all day:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; money = Money(27, 12)
&gt;&gt;&gt; money.total_cents
2712
&gt;&gt;&gt; money.cents
12
&gt;&gt;&gt; money.dollars = 35
&gt;&gt;&gt; money.total_cents
3512</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Python’s way of doing properties brings many benefits. In
languages like Java, the following story often plays out:</p>
<div class="pcalibre1 pcalibre itemized-list">
<ol class="pcalibre1 arabic pcalibre">
<li value="1" class="pcalibre1 pcalibre calibre4">
<span class="pcalibre1 principal pcalibre">A newbie developer starts writing Java classes. They want to expose
some state, so create public member variables.</span>
</li>
<li value="2" class="pcalibre1 pcalibre calibre4">
<span class="pcalibre1 principal pcalibre">They use this class everywhere. Other developers use it too.</span>
</li>
<li value="3" class="pcalibre1 pcalibre calibre4">
<span class="pcalibre1 principal pcalibre">One day, they want to change the name or type of that member
variable, or even do away with it entirely (like what we did with
<code class="pcalibre1 pcalibre literal">Money</code>).</span>
</li>
<li value="4" class="pcalibre1 pcalibre calibre4">
<span class="pcalibre1 principal pcalibre">But that would break everyone’s code. So they can’t.</span>
</li>
</ol>
</div>
<p class="pcalibre1 pcalibre calibre7">Because of this, Java developers quickly learn to make all their
variables private by default - proactively creating getters and
setters for <em class="pcalibre1 calibre8 pcalibre">every</em> publicly exposed chunk of data. They realize
this boilerplate is far less painful than the alternative, because if
everyone must use the public getters and setters to begin with, you
always have the freedom to make internal changes later.</p>
<p class="pcalibre1 pcalibre calibre7">This works well enough. But it <em class="pcalibre1 calibre8 pcalibre">is</em> distracting, and just enough
trouble that there’s always the temptation to make that member
variable public, and be done with it.</p>
<p class="pcalibre1 pcalibre calibre7">In Python, we have the best of both worlds. We make member variables
public by default, refactoring them as properties if and when we ever
need to. No one using our code even has to know.</p>
</section>
</section>
<section class="calibre2 pcalibre1 pcalibre" title="The Factory Patterns">
<h2 id="calibre_link-99" class="pcalibre1 pcalibre calibre1">The Factory Patterns</h2>
<p class="pcalibre1 pcalibre calibre7">There are several design patterns with the word "factory" in their
names. Their unifying idea is providing a handy, simplified way to
create useful, potentially complex objects.  The two most important
forms are:</p>
<div class="pcalibre1 pcalibre itemized-list">
<ul class="pcalibre1 calibre14 pcalibre">
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">Where the object’s type is fixed, but we want to have several
different ways to create it. This is called the <em class="pcalibre1 calibre8 pcalibre">Simple Factory Pattern</em>.</span>
</li>
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">Where the factory dynamically chooses one of several different
types. This is called the <em class="pcalibre1 calibre8 pcalibre">Factory Method Pattern</em>.</span>
</li>
</ul>
</div>
<p class="pcalibre1 pcalibre calibre7">Let’s look at how you do these in Python.</p>
<section class="calibre2 pcalibre1 pcalibre" title="Alternative Constructors: The Simple Factory">
<h3 id="calibre_link-182" class="pcalibre1 calibre21 pcalibre">Alternative Constructors: The Simple Factory</h3>
<p class="pcalibre1 pcalibre calibre7">

Imagine a simple <code class="pcalibre1 pcalibre literal">Money</code> class, suitable for currencies which have
dollars and cents:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">class</span> <span class="pcalibre1 pcalibre calibre18">Money</span>:
    <span class="pcalibre1 pcalibre calibre18">def</span> __init__(self, dollars, cents):
        self.dollars = dollars
        self.cents = cents</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">We looked at this in the previous section, refactoring its attributes
- but let’s roll back, and focus instead on the constructor’s
interface. This constructor is convenient when we have the dollars and
cents as separate integer variables. But there are many other ways to
specify an amount of money. Perhaps you’re modeling a giant jar of
pennies:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre13"># Emptying the penny jar...</span>
total_pennies = 3274
<span class="pcalibre1 pcalibre calibre13"># // is integer division</span>
dollars = total_pennies // 100
cents = total_pennies % 100
total_cash = Money(dollars, cents)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Suppose your code splits pennies into dollars and cents over and over,
and you’re tired of repeating this calculation. You could change the
constructor, but that means refactoring all <code class="pcalibre1 pcalibre literal">Money</code>-creating code, and
perhaps a lot of code fits the current constructor better anyway. Some
languages let you define several constructors, but Python
makes you pick one.</p>
<p class="pcalibre1 pcalibre calibre7">In this case, you can usefully create a <em class="pcalibre1 calibre8 pcalibre">factory function</em> taking the
arguments you want, creating and returning the object:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre13"># Factory function taking a single argument, returning</span>
<span class="pcalibre1 pcalibre calibre13"># an appropriate Money instance.</span>
<span class="pcalibre1 pcalibre calibre18">def</span> money_from_pennies(total_cents):
    dollars = total_cents // 100
    cents = total_cents % 100
    <span class="pcalibre1 pcalibre calibre18">return</span> Money(dollars, cents)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Imagine that, in the same code base, you also routinely need to parse
a string like <code class="pcalibre1 pcalibre literal">"$140.75"</code>. Here’s another factory function for that:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre13"># Another factory, creating Money from a string amount.</span>
<span class="pcalibre1 pcalibre calibre18">import</span> <span class="pcalibre1 pcalibre calibre18">re</span>
<span class="pcalibre1 pcalibre calibre18">def</span> money_from_string(amount):
    match = re.search(
        <span class="pcalibre1 pcalibre calibre13">r'^\$(?P&lt;dollars&gt;\d+)\.(?P&lt;cents&gt;\d\d)$'</span>, amount)
    <span class="pcalibre1 pcalibre calibre18">if</span> match <span class="pcalibre1 pcalibre calibre18">is</span> None:
        <span class="pcalibre1 pcalibre calibre18">raise</span> <span class="pcalibre1 pcalibre calibre18">ValueError</span>(<span class="pcalibre1 pcalibre calibre13">"Invalid amount: "</span> + repr(amount))
    dollars = int(match.group(<span class="pcalibre1 pcalibre calibre13">'dollars'</span>))
    cents = int(match.group(<span class="pcalibre1 pcalibre calibre13">'cents'</span>))
    <span class="pcalibre1 pcalibre calibre18">return</span> Money(dollars, cents)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">These are effectively alternate constructors: callables we can use
with different arguments, which are parsed and used to create the
final object. But this approach has problems. First,
it’s awkward to have them as separate functions, defined outside of
the class. But much more importantly: what happens if you subclass
<code class="pcalibre1 pcalibre literal">Money</code>? Suddenly <code class="pcalibre1 pcalibre literal">money_from_string</code> and <code class="pcalibre1 pcalibre literal">money_from_pennies</code> are
worthless. The base <code class="pcalibre1 pcalibre literal">Money</code> class is hard-coded.</p>
<p class="pcalibre1 pcalibre calibre7">Python solves these problems in unique way, absent from other
languages: the <code class="pcalibre1 pcalibre literal">classmethod</code> decorator. Use it like this:

</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">class</span> <span class="pcalibre1 pcalibre calibre18">Money</span>:
    <span class="pcalibre1 pcalibre calibre18">def</span> __init__(self, dollars, cents):
        self.dollars = dollars
        self.cents = cents
    @classmethod
    <span class="pcalibre1 pcalibre calibre18">def</span> from_pennies(cls, total_cents):
        dollars = total_cents // 100
        cents = total_cents % 100
        <span class="pcalibre1 pcalibre calibre18">return</span> cls(dollars, cents)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">The function <code class="pcalibre1 pcalibre literal">money_from_pennies</code> is now a method of the <code class="pcalibre1 pcalibre literal">Money</code>
class, called <code class="pcalibre1 pcalibre literal">from_pennies</code>. But it has a new argument: <code class="pcalibre1 pcalibre literal">cls</code>. When
applied to a method definition, <code class="pcalibre1 pcalibre literal">classmethod</code> modifies how that method
is invoked and interpreted. The first argument is not <code class="pcalibre1 pcalibre literal">self</code>, which
would be an <em class="pcalibre1 calibre8 pcalibre">instance</em> of the class. The first argument is now <em class="pcalibre1 calibre8 pcalibre">the
class itself</em>. In the method body, <code class="pcalibre1 pcalibre literal">self</code> isn’t mentioned at all;
instead, <code class="pcalibre1 pcalibre literal">cls</code> is a variable holding the current class object -
<code class="pcalibre1 pcalibre literal">Money</code> in this case. So the last line is creating a new instance of
<code class="pcalibre1 pcalibre literal">Money</code>:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; piggie_bank_cash = Money.from_pennies(3217)
&gt;&gt;&gt; type(piggie_bank_cash)
&lt;<span class="pcalibre1 pcalibre calibre18">class</span> <span class="pcalibre1 pcalibre calibre19">'</span><span class="pcalibre1 pcalibre calibre18">__main__</span>.Money<span class="pcalibre1 pcalibre calibre13">'&gt;</span>
&gt;&gt;&gt; piggie_bank_cash.dollars
32
&gt;&gt;&gt; piggie_bank_cash.cents
17</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Notice <code class="pcalibre1 pcalibre literal">from_pennies</code> is invoked off the class itself, not an instance
of the class. This already is nicer code organization. But the real
benefit is with inheritance:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">&gt;&gt;&gt; class</span> <span class="pcalibre1 pcalibre calibre18">TipMoney</span>(Money):
<span class="pcalibre1 pcalibre calibre18">... </span>    <span class="pcalibre1 pcalibre calibre18">pass</span>
<span class="pcalibre1 pcalibre calibre18">...</span>
<span class="pcalibre1 pcalibre calibre18">&gt;&gt;&gt; </span>tip = TipMoney.from_pennies(475)
<span class="pcalibre1 pcalibre calibre18">&gt;&gt;&gt; </span>type(tip)
&lt;class '__main__.TipMoney'&gt;</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">This is the <em class="pcalibre1 calibre8 pcalibre">real</em> benefit of class methods. You define it once on the
base class, and all subclasses can leverage it, substituting their own
type for <code class="pcalibre1 pcalibre literal">cls</code>. <strong class="pcalibre1 pcalibre calibre9">This makes class methods perfect for the simple
factory in Python.</strong> The final line returns an instance of <code class="pcalibre1 pcalibre literal">cls</code>,
using its regular constructor. And <code class="pcalibre1 pcalibre literal">cls</code> refers to whatever the
current class is: <code class="pcalibre1 pcalibre literal">Money</code>, <code class="pcalibre1 pcalibre literal">TipMoney</code>, or some other subclass.</p>
<p class="pcalibre1 pcalibre calibre7">For the record, here’s how we translate <code class="pcalibre1 pcalibre literal">money_from_string</code>:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">def</span> from_string(cls, amount):
    match = re.search(
        <span class="pcalibre1 pcalibre calibre13">r'^\$(?P&lt;dollars&gt;\d+)\.(?P&lt;cents&gt;\d\d)$'</span>, amount)
    <span class="pcalibre1 pcalibre calibre18">if</span> match <span class="pcalibre1 pcalibre calibre18">is</span> None:
        <span class="pcalibre1 pcalibre calibre18">raise</span> <span class="pcalibre1 pcalibre calibre18">ValueError</span>(<span class="pcalibre1 pcalibre calibre13">"Invalid amount: "</span> + repr(amount))
    dollars = int(match.group(<span class="pcalibre1 pcalibre calibre13">'dollars'</span>))
    cents = int(match.group(<span class="pcalibre1 pcalibre calibre13">'cents'</span>))
    <span class="pcalibre1 pcalibre calibre18">return</span> cls(dollars, cents)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Class methods are a superior way to implement factories like this in
Python. If we subclass <code class="pcalibre1 pcalibre literal">Money</code>, that subclass will have <code class="pcalibre1 pcalibre literal">from_pennies</code>
and <code class="pcalibre1 pcalibre literal">from_string</code> methods that create objects of that subclass,
without any extra work on our part. And if we change the name of the
<code class="pcalibre1 pcalibre literal">Money</code> class, we only have to change it in one place, not three.</p>
<p class="pcalibre1 pcalibre calibre7">This form of the factory pattern is called "simple factory", a name I
don’t love. I prefer to call it "alternate constructor". Especially in
the context of Python, it describes well what <code class="pcalibre1 pcalibre literal">@classmethod</code> is most
useful for.  And it suggests a general principle for designing your
classes. Look at this complete code of the <code class="pcalibre1 pcalibre literal">Money</code> class, and I’ll
explain:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">import</span> <span class="pcalibre1 pcalibre calibre18">re</span>
<span class="pcalibre1 pcalibre calibre18">class</span> <span class="pcalibre1 pcalibre calibre18">Money</span>:
    <span class="pcalibre1 pcalibre calibre18">def</span> __init__(self, dollars, cents):
        self.dollars = dollars
        self.cents = cents
    @classmethod
    <span class="pcalibre1 pcalibre calibre18">def</span> from_pennies(cls, total_cents):
        dollars = total_cents // 100
        cents = total_cents % 100
        <span class="pcalibre1 pcalibre calibre18">return</span> cls(dollars, cents)
    @classmethod
    <span class="pcalibre1 pcalibre calibre18">def</span> from_string(cls, amount):
        match = re.search(
            <span class="pcalibre1 pcalibre calibre13">r'^\$(?P&lt;dollars&gt;\d+)\.(?P&lt;cents&gt;\d\d)$'</span>, amount)
        <span class="pcalibre1 pcalibre calibre18">if</span> match <span class="pcalibre1 pcalibre calibre18">is</span> None:
            <span class="pcalibre1 pcalibre calibre18">raise</span> <span class="pcalibre1 pcalibre calibre18">ValueError</span>(<span class="pcalibre1 pcalibre calibre13">"Invalid amount: "</span> + repr(amount))
        dollars = int(match.group(<span class="pcalibre1 pcalibre calibre13">'dollars'</span>))
        cents = int(match.group(<span class="pcalibre1 pcalibre calibre13">'cents'</span>))
        <span class="pcalibre1 pcalibre calibre18">return</span> cls(dollars, cents)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">You can think of this class as having several constructors. As a
general rule, you’ll want to make <code class="pcalibre1 pcalibre literal">__init__</code> the most generic one,
and implement the others as class methods. Sometimes, that means one
of the class methods will be used more often than <code class="pcalibre1 pcalibre literal">__init__</code>.</p>
<p class="pcalibre1 pcalibre calibre7">When using a new class, most developer’s intuition will be to reach
for the default constructor first, without thinking to check the
provided class methods - if they even know about that feature of
Python in the first place. So in that situation, you may need to
educate your teammates.  (Hint: Good examples in the class’s code docs
go a long way.)</p>
</section>
<section class="calibre2 pcalibre1 pcalibre" title="Dynamic Type: The Factory Method Pattern">
<h3 id="calibre_link-183" class="pcalibre1 calibre21 pcalibre">Dynamic Type: The Factory Method Pattern</h3>
<p class="pcalibre1 pcalibre calibre7">

This next factory pattern, called "Factory Method", is quite
different. The idea is that the factory will create an object, but
will choose its type from one of several possibilities, dynamically
deciding at run-time based on some criteria. It’s typically used when
you have one base class, and are creating an object that can be one of
several different derived classes.</p>
<p class="pcalibre1 pcalibre calibre7">Let’s see an example. Imagine you are implementing an image processing
library, creating classes to read the image from storage. So you
create a base <code class="pcalibre1 pcalibre literal">ImageReader</code> class, and several derived types:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">import</span> <span class="pcalibre1 pcalibre calibre18">abc</span>
<span class="pcalibre1 pcalibre calibre18">class</span> <span class="pcalibre1 pcalibre calibre18">ImageReader</span>(metaclass=abc.ABCMeta):
    <span class="pcalibre1 pcalibre calibre18">def</span> __init__(self, path):
        self.path = path
    @abc.abstractmethod
    <span class="pcalibre1 pcalibre calibre18">def</span> read(self):
        <span class="pcalibre1 pcalibre calibre18">pass</span> <span class="pcalibre1 pcalibre calibre13"># Subclass must implement.</span>
    <span class="pcalibre1 pcalibre calibre18">def</span> __repr__(self):
        <span class="pcalibre1 pcalibre calibre18">return</span> <span class="pcalibre1 pcalibre calibre13">'{}({})'</span>.format(self.__class__.__name__, self.path)

<span class="pcalibre1 pcalibre calibre18">class</span> <span class="pcalibre1 pcalibre calibre18">GIFReader</span>(ImageReader):
    <span class="pcalibre1 pcalibre calibre18">def</span> read(self):
        <span class="pcalibre1 pcalibre calibre13">"Read a GIF"</span>

<span class="pcalibre1 pcalibre calibre18">class</span> <span class="pcalibre1 pcalibre calibre18">JPEGReader</span>(ImageReader):
    <span class="pcalibre1 pcalibre calibre18">def</span> read(self):
        <span class="pcalibre1 pcalibre calibre13">"Read a JPEG"</span>

<span class="pcalibre1 pcalibre calibre18">class</span> <span class="pcalibre1 pcalibre calibre18">PNGReader</span>(ImageReader):
    <span class="pcalibre1 pcalibre calibre18">def</span> read(self):
        <span class="pcalibre1 pcalibre calibre13">"Read a PNG"</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">The <code class="pcalibre1 pcalibre literal">ImageReader</code> class is marked abstract, requiring subclasses to
implement the <code class="pcalibre1 pcalibre literal">read</code> method. So far, so good.</p>
<p class="pcalibre1 pcalibre calibre7">Now, when reading an image file, if its extension is ".gif", I want to
use <code class="pcalibre1 pcalibre literal">GIFReader</code>. And if it is a JPEG image, I want to use
<code class="pcalibre1 pcalibre literal">JPEGReader</code>. And so on. The logic is</p>
<div class="pcalibre1 pcalibre itemized-list">
<ul class="pcalibre1 calibre14 pcalibre">
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">Analyze the file path name to get the extension,</span>
</li>
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">choose the correct reader class based on that,</span>
</li>
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">and finally create the appropriate reader object.</span>
</li>
</ul>
</div>
<p class="pcalibre1 pcalibre calibre7">This is a prime candidate for automation. Let’s define a
little helper function:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">def</span> extension_of(path):
    position_of_last_dot = path.rfind(<span class="pcalibre1 pcalibre calibre13">'.'</span>)
    <span class="pcalibre1 pcalibre calibre18">return</span> path[position_of_last_dot+1:]</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">With these pieces, we can now define the factory:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre13"># First version of get_image_reader().</span>
<span class="pcalibre1 pcalibre calibre18">def</span> get_image_reader(path):
    image_type = extension_of(path)
    reader_class = None
    <span class="pcalibre1 pcalibre calibre18">if</span> image_type == <span class="pcalibre1 pcalibre calibre13">'gif'</span>:
        reader_class = GIFReader
    <span class="pcalibre1 pcalibre calibre18">elif</span> image_type == <span class="pcalibre1 pcalibre calibre13">'jpg'</span>:
        reader_class = JPEGReader
    <span class="pcalibre1 pcalibre calibre18">elif</span> image_type == <span class="pcalibre1 pcalibre calibre13">'png'</span>:
        reader_class = PNGReader
    <span class="pcalibre1 pcalibre calibre18">assert</span> reader_class <span class="pcalibre1 pcalibre calibre18">is</span> <span class="pcalibre1 pcalibre calibre18">not</span> None, \
        <span class="pcalibre1 pcalibre calibre13">'Unknown extension: {}'</span>.format(image_type)
    <span class="pcalibre1 pcalibre calibre18">return</span> reader_class(path)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Classes in Python can be put in variables, just like any other
object. We take full advantage here, by storing the appropriate
<code class="pcalibre1 pcalibre literal">ImageReader</code> subclass in <code class="pcalibre1 pcalibre literal">reader_class</code>. Once we decide on the proper
value, the last line creates and returns the reader object.</p>
<p class="pcalibre1 pcalibre calibre7">This correctly-working code is already more concise, readable and
maintainable than what some languages force you to go through. But in
Python, we can do better. We can use the built-in dictionary type to
make it even more readable and easy to maintain over time:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>READERS = {
    <span class="pcalibre1 pcalibre calibre13">'gif'</span> : GIFReader,
    <span class="pcalibre1 pcalibre calibre13">'jpg'</span> : JPEGReader,
    <span class="pcalibre1 pcalibre calibre13">'png'</span> : PNGReader,
    }
<span class="pcalibre1 pcalibre calibre18">def</span> get_image_reader(path):
    reader_class = READERS[extension_of(path)]
    <span class="pcalibre1 pcalibre calibre18">return</span> reader_class(path)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Here we have a global variable mapping filename extensions to
<code class="pcalibre1 pcalibre literal">ImageReader</code> subclasses. This lets us readably implement
<code class="pcalibre1 pcalibre literal">get_image_reader</code> in two lines. Finding the correct class is a simple
dictionary lookup, and then we instantiate and return the object. And
if we support new image formats in the future, we simply add a line in
the <code class="pcalibre1 pcalibre literal">READERS</code> definition. (And, of course, define its reader class.)</p>
<p class="pcalibre1 pcalibre calibre7">What if we encounter an extension not in the mapping, like <code class="pcalibre1 pcalibre literal">tiff</code>?  As
written above, the code will raise a <code class="pcalibre1 pcalibre literal">KeyError</code>. That may be what we
want. Or closely related, perhaps we want to catch that, and re-raise
a different exception.</p>
<p class="pcalibre1 pcalibre calibre7">Alternatively, we may want to fall back on some default. Let’s create
a new reader class, meant as an all-purpose fallback:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">class</span> <span class="pcalibre1 pcalibre calibre18">RawByteReader</span>(ImageReader):
    <span class="pcalibre1 pcalibre calibre18">def</span> read(self):
        <span class="pcalibre1 pcalibre calibre13">"Read raw bytes"</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Then you can write the factory like:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">def</span> get_image_reader(path):
    <span class="pcalibre1 pcalibre calibre18">try</span>:
        reader_class = READERS[extension_of(path)]
    <span class="pcalibre1 pcalibre calibre18">except</span> <span class="pcalibre1 pcalibre calibre18">KeyError</span>:
        reader_class = RawByteReader
    <span class="pcalibre1 pcalibre calibre18">return</span> reader_class(path)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">or more briefly</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">def</span> get_image_reader(path):
    <span class="pcalibre1 pcalibre calibre18">return</span> READERS.get(extension_of(path), RawByteReader)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">This design pattern is commonly called the "factory method" pattern,
which wins my award for Worst Design Pattern Name In History. That
name (which appears to originate from a Java implementation detail)
fails to tell you anything about what it’s actually <em class="pcalibre1 calibre8 pcalibre">for</em>. I myself
call it the "dynamic type" pattern, which I feel is much more
descriptive and useful.</p>
</section>
</section>
<section class="calibre2 pcalibre1 pcalibre" title="The Observer Pattern">
<h2 id="calibre_link-100" class="pcalibre1 pcalibre calibre1">The Observer Pattern</h2>
<p class="pcalibre1 pcalibre calibre7">
The Observer pattern provides a "one to many" relationship. That’s
vague, so let’s make it more specific.</p>
<p class="pcalibre1 pcalibre calibre7">In the observer pattern, there’s one root object, called the

<em class="pcalibre1 calibre8 pcalibre">observable</em>. This object knows how to detect some kind of event of
interest. It can literally be anything: a customer makes a new
purchase; someone subscribes to an email list; or maybe it monitors a
fleet of cloud instances, detecting when a machine’s disk usage
exceeds 75%. You use this pattern when the code to <em class="pcalibre1 calibre8 pcalibre">reliably</em> detect
the event of interest is at least slightly complicated; that detection
code is encapsulated inside the observable.</p>
<p class="pcalibre1 pcalibre calibre7">Now, you also have other objects, called

<em class="pcalibre1 calibre8 pcalibre">observers</em>, which need to
know when that event occurs, taking some action in response. You don’t
want to re-implement the robust detection algorithm in each, of
course. Instead, these observers register themselves with the
observable. The observable then notifies each observer - by calling a
method on that observer - for each event. This separation of concerns
is the heart of the observer pattern.</p>
<p class="pcalibre1 pcalibre calibre7">Now, I must tell you, I don’t like the names of things in this
pattern. The words "observable" and "observer" are a bit obscure, and
sound confusingly similar - especially to those whose native tongue is
not English. There is another terminology, however, which many
developers find easier: <em class="pcalibre1 calibre8 pcalibre">pub-sub</em>.
</p>
<p class="pcalibre1 pcalibre calibre7">In this formulation, instead of "observable", you create a <em class="pcalibre1 calibre8 pcalibre">publisher</em>
object, which watches for events. And you have one or more
<em class="pcalibre1 calibre8 pcalibre">subscribers</em> who ask that publisher to notify them when the event
happens. I’ve found the pattern is easier to reason about when looked
at in this way, so that’s the terminology I’m going to use.</p>
<p class="pcalibre1 pcalibre calibre7">Let’s make this concrete, with code.</p>
<section class="calibre2 pcalibre1 pcalibre" title="The Simple Observer">
<h3 id="calibre_link-184" class="pcalibre1 calibre21 pcalibre">The Simple Observer</h3>
<p class="pcalibre1 pcalibre calibre7">We’ll start with the basic observer pattern, as it’s often documented
in design pattern books - except we’ll translate it to Python.  In
this simple form, each subscriber must implement a method called
<code class="pcalibre1 pcalibre literal">update</code>. Here’s an example:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">class</span> <span class="pcalibre1 pcalibre calibre18">Subscriber</span>:
    <span class="pcalibre1 pcalibre calibre18">def</span> __init__(self, name):
        self.name = name
    <span class="pcalibre1 pcalibre calibre18">def</span> update(self, message):
        <span class="pcalibre1 pcalibre calibre18">print</span>(<span class="pcalibre1 pcalibre calibre13">'{} got message "{}"'</span>.format(
            self.name, message))</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7"><code class="pcalibre1 pcalibre literal">update</code> takes a string. It’s okay to define an <code class="pcalibre1 pcalibre literal">update</code> method taking
other arguments, or even calling it something other than <code class="pcalibre1 pcalibre literal">update</code>; the
publisher and subscriber just need to agree on the protocol. But we’ll
use a string.</p>
<p class="pcalibre1 pcalibre calibre7">Now, when a publisher detects an event, it notifies the subscriber by
calling its <code class="pcalibre1 pcalibre literal">update</code> method.  Here’s what a basic <code class="pcalibre1 pcalibre literal">Publisher</code> class
looks like:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">class</span> <span class="pcalibre1 pcalibre calibre18">Publisher</span>:
    <span class="pcalibre1 pcalibre calibre18">def</span> __init__(self):
        self.subscribers = set()
    <span class="pcalibre1 pcalibre calibre18">def</span> register(self, who):
        self.subscribers.add(who)
    <span class="pcalibre1 pcalibre calibre18">def</span> unregister(self, who):
        self.subscribers.discard(who)
    <span class="pcalibre1 pcalibre calibre18">def</span> dispatch(self, message):
        <span class="pcalibre1 pcalibre calibre18">for</span> subscriber <span class="pcalibre1 pcalibre calibre18">in</span> self.subscribers:
            subscriber.update(message)
    <span class="pcalibre1 pcalibre calibre13"># Plus other methods, for detecting the event.</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Let’s step through:</p>
<div class="pcalibre1 pcalibre itemized-list">
<ul class="pcalibre1 calibre14 pcalibre">
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">A publisher needs to keep track of its subscribers, right? We’ll
store them in a set object, named <code class="pcalibre1 pcalibre literal">self.subscribers</code>, created
in the constructor.</span>
</li>
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">A subscriber is added with <code class="pcalibre1 pcalibre literal">register</code>. Its argument <code class="pcalibre1 pcalibre literal">who</code> is an
instance of <code class="pcalibre1 pcalibre literal">Subscriber</code>. Who calls <code class="pcalibre1 pcalibre literal">register</code>? It could be
anyone. The subscriber can register itself; or some external code
can register a subscriber with a specific publisher.</span>
</li>
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre"><code class="pcalibre1 pcalibre literal">unregister</code> is there in case a subscriber no longer needs to be
notified of the events.</span>
</li>
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">When the event of interest occurs, the publisher notifies its
subscribers by calling its <code class="pcalibre1 pcalibre literal">dispatch</code> method. Usually this will be
invoked by the publisher itself, in some other method of the class
(not shown) that implements the event-detection logic. It simply
cycles through the subscribers, calling <code class="pcalibre1 pcalibre literal">.update()</code> on each.</span>
</li>
</ul>
</div>
<p class="pcalibre1 pcalibre calibre7">Using these two classes in code is straightforward enough:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre13"># Create a publisher and some subscribers.</span>
pub = Publisher()
bob = Subscriber(<span class="pcalibre1 pcalibre calibre13">'Bob'</span>)
alice = Subscriber(<span class="pcalibre1 pcalibre calibre13">'Alice'</span>)
john = Subscriber(<span class="pcalibre1 pcalibre calibre13">'John'</span>)

<span class="pcalibre1 pcalibre calibre13"># Register the subscribers, so they get notified.</span>
pub.register(bob)
pub.register(alice)
pub.register(john)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Now, the publisher can dispatch messages:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre13"># Send a message...</span>
pub.dispatch(<span class="pcalibre1 pcalibre calibre13">"It's lunchtime!"</span>)
<span class="pcalibre1 pcalibre calibre13"># John unsubscribes...</span>
pub.unregister(john)
<span class="pcalibre1 pcalibre calibre13"># ... and a new message is sent.</span>
pub.dispatch(<span class="pcalibre1 pcalibre calibre13">"Time for dinner"</span>)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Here’s the output from running the above:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11">John got message "It's lunchtime!"
Bob got message "It's lunchtime!"
Alice got message "It's lunchtime!"
Bob got message "Time for dinner"
Alice got message "Time for dinner"</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">This is the basic observer pattern, and pretty close to how you’d
implement the idea in languages like Java, C#, and C++. But Python’s
feature set differs from those languages. That means we can do
different things.</p>
<p class="pcalibre1 pcalibre calibre7">So let’s explore that. If we leverage Pythonic features, what does
that give us?</p>
</section>
<section class="calibre2 pcalibre1 pcalibre" title="A Pythonic Refinement">
<h3 id="calibre_link-185" class="pcalibre1 calibre21 pcalibre">A Pythonic Refinement</h3>
<p class="pcalibre1 pcalibre calibre7">Python’s functions are first-class objects. That means you can store a
function in a variable - not the value returned when you call a
function, but store the function itself - as well as pass it as an
argument to other functions and methods.  Some languages support this
too (or something like it, such as function pointers), but Python’s
strong support gives us a convenient opportunity for this design pattern.</p>
<p class="pcalibre1 pcalibre calibre7">The standard observer pattern requires the publisher hard-code a
certain method - usually named <code class="pcalibre1 pcalibre literal">update</code> - that the subscriber must
implement. But maybe you need to register a subscriber which doesn’t
have that method. What then? If it’s your own class, you can probably
just add it. Or if you are importing the subscriber class from another
library (which you can’t or don’t want to modify), perhaps you can add
the method by subclassing it.</p>
<p class="pcalibre1 pcalibre calibre7">Or sometimes you can’t do any of those things. Or you <em class="pcalibre1 calibre8 pcalibre">could</em>, but
it’s a lot of trouble, and you want to avoid it. What then?</p>
<p class="pcalibre1 pcalibre calibre7">Let’s extend the traditional observer pattern, and make <code class="pcalibre1 pcalibre literal">register</code>
more flexible. Suppose you have these subscribers:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre13"># This subscriber uses the standard "update"</span>
<span class="pcalibre1 pcalibre calibre18">class</span> <span class="pcalibre1 pcalibre calibre18">SubscriberOne</span>:
    <span class="pcalibre1 pcalibre calibre18">def</span> __init__(self, name):
        self.name = name
    <span class="pcalibre1 pcalibre calibre18">def</span> update(self, message):
        <span class="pcalibre1 pcalibre calibre18">print</span>(<span class="pcalibre1 pcalibre calibre13">'{} got message "{}"'</span>.format(
            self.name, message))
<span class="pcalibre1 pcalibre calibre13"># This one wants to use "receive"</span>
<span class="pcalibre1 pcalibre calibre18">class</span> <span class="pcalibre1 pcalibre calibre18">SubscriberTwo</span>:
    <span class="pcalibre1 pcalibre calibre18">def</span> __init__(self, name):
        self.name = name
    <span class="pcalibre1 pcalibre calibre18">def</span> receive(self, message):
        <span class="pcalibre1 pcalibre calibre18">print</span>(<span class="pcalibre1 pcalibre calibre13">'{} got message "{}"'</span>.format(
            self.name, message))</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7"><code class="pcalibre1 pcalibre literal">SubscriberOne</code> is the same subscriber class we saw
before. <code class="pcalibre1 pcalibre literal">SubscriberTwo</code> is almost the same: instead of <code class="pcalibre1 pcalibre literal">update</code>, it
has a method named <code class="pcalibre1 pcalibre literal">receive</code>. Okay, let’s modify <code class="pcalibre1 pcalibre literal">Publisher</code> so it can
work with objects of either subscriber type:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">class</span> <span class="pcalibre1 pcalibre calibre18">Publisher</span>:
    <span class="pcalibre1 pcalibre calibre18">def</span> __init__(self):
        self.subscribers = dict()
    <span class="pcalibre1 pcalibre calibre18">def</span> register(self, who, callback=None):
        <span class="pcalibre1 pcalibre calibre18">if</span> callback <span class="pcalibre1 pcalibre calibre18">is</span> None:
            callback = who.update
        self.subscribers[who] = callback
    <span class="pcalibre1 pcalibre calibre18">def</span> dispatch(self, message):
        <span class="pcalibre1 pcalibre calibre18">for</span> callback <span class="pcalibre1 pcalibre calibre18">in</span> self.subscribers.values():
            callback(message)
    <span class="pcalibre1 pcalibre calibre18">def</span> unregister(self, who):
        <span class="pcalibre1 pcalibre calibre18">del</span> self.subscribers[who]</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">There’s a lot going on here, so let’s break it down.  Look first at
the constructor: it creates a <code class="pcalibre1 pcalibre literal">dict</code> instead of a set. You’ll see why
in a moment.</p>
<p class="pcalibre1 pcalibre calibre7">Now focus on <code class="pcalibre1 pcalibre literal">register</code>:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>    <span class="pcalibre1 pcalibre calibre18">def</span> register(self, who, callback=None):
        <span class="pcalibre1 pcalibre calibre18">if</span> callback <span class="pcalibre1 pcalibre calibre18">is</span> None:
            callback = who.update
        self.subscribers[who] = callback</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">It can be called with one or <em class="pcalibre1 calibre8 pcalibre">two</em> arguments. With one argument, <code class="pcalibre1 pcalibre literal">who</code>
is a subscriber of some sort, and <code class="pcalibre1 pcalibre literal">callback</code> defaults to
<code class="pcalibre1 pcalibre literal">None</code>. Inside, <code class="pcalibre1 pcalibre literal">callback</code> is set to <code class="pcalibre1 pcalibre literal">who.update</code>.  Notice the lack of
parentheses; <code class="pcalibre1 pcalibre literal">who.update</code> is a <em class="pcalibre1 calibre8 pcalibre">method object</em>. It’s just like a
function object, except it happens to be tied to an instance. And
just like a function object, you can store it in a variable, pass it
as an argument to another function, and so on.<sup class="pcalibre1 pcalibre noteref">[<a href="#calibre_link-140" id="calibre_link-144" type="noteref" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">2</a>]</sup> So we’re storing it in
a variable called <code class="pcalibre1 pcalibre literal">callback</code>.</p>
<p class="pcalibre1 pcalibre calibre7">What if <code class="pcalibre1 pcalibre literal">register</code> is called with 2 arguments? Here’s how that might look:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>pub = Publisher()
alice = SubscriberTwo(<span class="pcalibre1 pcalibre calibre13">'Alice'</span>)
pub.register(alice, alice.receive)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7"><code class="pcalibre1 pcalibre literal">alice.receive</code> is another method object; inside, this object is
assigned to <code class="pcalibre1 pcalibre literal">callback</code>. Regardless of whether <code class="pcalibre1 pcalibre literal">register</code> is called
with one argument or two, the last line inserts <code class="pcalibre1 pcalibre literal">callback</code> into the
dictionary:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>        self.subscribers[who] = callback</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Take a moment to appreciate the remarkable flexibility of Python
dictionaries. Here, you are using an arbitrary instance of either
<code class="pcalibre1 pcalibre literal">SubscriberOne</code> or <code class="pcalibre1 pcalibre literal">SubscriberTwo</code> as a key. These two classes are
unrelated by inheritance, so from Python’s viewpoint they are
completely distinct types. And for that key, you insert a <em class="pcalibre1 calibre8 pcalibre">method
object</em> as its value. Python does this seamlessly, without complaint!
Many languages would make you jump through hoops to accomplish this.</p>
<p class="pcalibre1 pcalibre calibre7">Anyway, now it’s clear why <code class="pcalibre1 pcalibre literal">self.subscribers</code> is a <code class="pcalibre1 pcalibre literal">dict</code> and not a
<code class="pcalibre1 pcalibre literal">set</code>. Earlier, we only needed to keep track to who the subscribers
were.  Now, we also need to remember the callback for each
subscriber. These are used in the <code class="pcalibre1 pcalibre literal">dispatch</code> method:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>    <span class="pcalibre1 pcalibre calibre18">def</span> dispatch(self, message):
        <span class="pcalibre1 pcalibre calibre18">for</span> callback <span class="pcalibre1 pcalibre calibre18">in</span> self.subscribers.values():
            callback(message)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7"><code class="pcalibre1 pcalibre literal">dispatch</code> only needs to cycle through the values,<sup class="pcalibre1 pcalibre noteref">[<a href="#calibre_link-141" id="calibre_link-145" type="noteref" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">3</a>]</sup>
because it just needs to call each subscriber’s update method (even if
it’s not called <code class="pcalibre1 pcalibre literal">update</code>). Notice we don’t have to reference the
subscriber object to call that method; the method object internally
has a reference to its instance (i.e. its â€œselfâ€), so
<code class="pcalibre1 pcalibre literal">callback(message)</code> calls the right method on the right object.  In
fact, the only reason we keep track of subscribers at all is so we can
<code class="pcalibre1 pcalibre literal">unregister</code> them.</p>
<p class="pcalibre1 pcalibre calibre7">Let’s put this together with a few subscribers:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>pub = Publisher()
bob = SubscriberOne(<span class="pcalibre1 pcalibre calibre13">'Bob'</span>)
alice = SubscriberTwo(<span class="pcalibre1 pcalibre calibre13">'Alice'</span>)
john = SubscriberOne(<span class="pcalibre1 pcalibre calibre13">'John'</span>)

pub.register(bob, bob.update)
pub.register(alice, alice.receive)
pub.register(john)

pub.dispatch(<span class="pcalibre1 pcalibre calibre13">"It's lunchtime!"</span>)
pub.unregister(john)
pub.dispatch(<span class="pcalibre1 pcalibre calibre13">"Time for dinner"</span>)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Here’s the output:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11">Bob got message "It's lunchtime!"
Alice got message "It's lunchtime!"
John got message "It's lunchtime!"
Bob got message "Time for dinner"
Alice got message "Time for dinner"</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Now, pop quiz. Look at the <code class="pcalibre1 pcalibre literal">Publisher</code> class again:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">class</span> <span class="pcalibre1 pcalibre calibre18">Publisher</span>:
    <span class="pcalibre1 pcalibre calibre18">def</span> __init__(self):
        self.subscribers = dict()
    <span class="pcalibre1 pcalibre calibre18">def</span> register(self, who, callback=None):
        <span class="pcalibre1 pcalibre calibre18">if</span> callback <span class="pcalibre1 pcalibre calibre18">is</span> None:
            callback = who.update
        self.subscribers[who] = callback
    <span class="pcalibre1 pcalibre calibre18">def</span> dispatch(self, message):
        <span class="pcalibre1 pcalibre calibre18">for</span> callback <span class="pcalibre1 pcalibre calibre18">in</span> self.subscribers.values():
            callback(message)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Here’s the question: does <code class="pcalibre1 pcalibre literal">callback</code> have to be a method of the
subscriber? Or can it be a method of a different object, or something
else? Think about this before you continue…​</p>
<p class="pcalibre1 pcalibre calibre7">It turns out <code class="pcalibre1 pcalibre literal">callback</code> can be <em class="pcalibre1 calibre8 pcalibre">any callable</em>, provided it has a
signature compatible with how it’s called in <code class="pcalibre1 pcalibre literal">dispatch</code>. That means it
can be a method of some other object, or even a normal function. This
lets you register subscriber objects without an update method at all:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre13"># This subscriber doesn't have ANY suitable method!</span>
<span class="pcalibre1 pcalibre calibre18">class</span> <span class="pcalibre1 pcalibre calibre18">SubscriberThree</span>:
    <span class="pcalibre1 pcalibre calibre18">def</span> __init__(self, name):
        self.name = name
<span class="pcalibre1 pcalibre calibre13"># ... but we can define a function...</span>
todd = SubscriberThree(<span class="pcalibre1 pcalibre calibre13">'Todd'</span>)
<span class="pcalibre1 pcalibre calibre18">def</span> todd_callback(message):
    <span class="pcalibre1 pcalibre calibre18">print</span>(<span class="pcalibre1 pcalibre calibre13">'Todd got message "{}"'</span>.format(message))
<span class="pcalibre1 pcalibre calibre13"># ... and pass it to register:</span>
pub.register(todd, todd_callback)
<span class="pcalibre1 pcalibre calibre13"># And then, dispatch a message:</span>
pub.dispatch(<span class="pcalibre1 pcalibre calibre13">"Breakfast is Ready"</span>)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Sure enough, this works:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11">Todd got message "Breakfast is Ready"</code></pre>
</figure>
</section>
<section class="calibre2 pcalibre1 pcalibre" title="Several Channels">
<h3 id="calibre_link-186" class="pcalibre1 calibre21 pcalibre">Several Channels</h3>
<p class="pcalibre1 pcalibre calibre7">So far, we’ve assumed the publisher watches for only one kind of
event. But what if there are several? Can we create a publisher that
knows how to detect all of them, and let subscribers decide which they
want to know about?</p>
<p class="pcalibre1 pcalibre calibre7">To implement this, let’s say a publisher has several <em class="pcalibre1 calibre8 pcalibre">channels</em> that
subscribers can subscribe to.  Each channel notifies for a different
event type. For example, if your program monitors a cluster of virtual
machines, one channel signals when a certain machine’s disk usage
exceeds 75% (a warning sign, but not an immediate emergency); and
another signals when disk usage goes over 90% (much more serious, and
may begin to impact performance on that VM). Some subscribers will
want to know when the 75% threshold is crossed; some, the 90%
threshold; and some might want to be alerted for both. What’s a good
way to express this in Python code?</p>
<p class="pcalibre1 pcalibre calibre7">Let’s work with the mealtime-announcement code above. Rather than
jumping right into the code, let’s mock up the <em class="pcalibre1 calibre8 pcalibre">interface</em> first. We
want to create a publisher with two channels, like so:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre13"># Two channels, named "lunch" and "dinner".</span>
pub = Publisher([<span class="pcalibre1 pcalibre calibre13">'lunch'</span>, <span class="pcalibre1 pcalibre calibre13">'dinner'</span>])</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">So the constructor is different; it takes a list of channel names.
Let’s also pass the channel name to <code class="pcalibre1 pcalibre literal">register</code>, since each subscriber
will register for one or more:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre13"># Three subscribers, of the original type.</span>
bob = Subscriber(<span class="pcalibre1 pcalibre calibre13">'Bob'</span>)
alice = Subscriber(<span class="pcalibre1 pcalibre calibre13">'Alice'</span>)
john = Subscriber(<span class="pcalibre1 pcalibre calibre13">'John'</span>)

<span class="pcalibre1 pcalibre calibre13"># Two args: channel name &amp; subscriber</span>
pub.register(<span class="pcalibre1 pcalibre calibre13">"lunch"</span>, bob)
pub.register(<span class="pcalibre1 pcalibre calibre13">"dinner"</span>, alice)
pub.register(<span class="pcalibre1 pcalibre calibre13">"lunch"</span>, john)
pub.register(<span class="pcalibre1 pcalibre calibre13">"dinner"</span>, john)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Now, on dispatch, the publisher needs to specify the event type. So
just like with <code class="pcalibre1 pcalibre literal">register</code>, we’ll prepend a channel argument:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>pub.dispatch(<span class="pcalibre1 pcalibre calibre13">"lunch"</span>, <span class="pcalibre1 pcalibre calibre13">"It's lunchtime!"</span>)
pub.dispatch(<span class="pcalibre1 pcalibre calibre13">"dinner"</span>, <span class="pcalibre1 pcalibre calibre13">"Dinner is served"</span>)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">When correctly working, we’d expect this output:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11">Bob got message "It's lunchtime!"
John got message "It's lunchtime!"
Alice got message "Dinner is served"
John got message "Dinner is served"</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Pop quiz (and if it’s practical, pause here to write Python code): how
would you implement this new, multi-channel <code class="pcalibre1 pcalibre literal">Publisher</code>?</p>
<p class="pcalibre1 pcalibre calibre7">There are several approaches, but the simplest I’ve found relies on
creating a separate <code class="pcalibre1 pcalibre literal">subscribers</code> dictionary for each channel. One approach:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">class</span> <span class="pcalibre1 pcalibre calibre18">Publisher</span>:
    <span class="pcalibre1 pcalibre calibre18">def</span> __init__(self, channels):
        <span class="pcalibre1 pcalibre calibre13"># Create an empty subscribers dict</span>
        <span class="pcalibre1 pcalibre calibre13"># for every channel</span>
        self.channels = { channel : dict()
                          <span class="pcalibre1 pcalibre calibre18">for</span> channel <span class="pcalibre1 pcalibre calibre18">in</span> channels }
    <span class="pcalibre1 pcalibre calibre18">def</span> register(self, channel, who, callback=None):
        <span class="pcalibre1 pcalibre calibre18">if</span> callback <span class="pcalibre1 pcalibre calibre18">is</span> None:
            callback = who.update
        subscribers = self.channels[channel]
        subscribers[who] = callback
    <span class="pcalibre1 pcalibre calibre18">def</span> dispatch(self, channel, message):
        subscribers = self.channels[channel]
        <span class="pcalibre1 pcalibre calibre18">for</span> subscriber, callback <span class="pcalibre1 pcalibre calibre18">in</span> subscribers.items():
            callback(message)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">This <code class="pcalibre1 pcalibre literal">Publisher</code> has a dict called <code class="pcalibre1 pcalibre literal">self.channels</code>, which maps channel
names (strings) to subscriber dictionaries. <code class="pcalibre1 pcalibre literal">register</code> and <code class="pcalibre1 pcalibre literal">dispatch</code>
are not too different: they simply have an extra step, in which
<code class="pcalibre1 pcalibre literal">subscribers</code> is looked up in <code class="pcalibre1 pcalibre literal">self.channels</code>. I use that variable
just for readability, and I think it’s well worth the extra line of
code:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre13"># Works the same. But a bit less readable.</span>
    <span class="pcalibre1 pcalibre calibre18">def</span> register(self, channel, who, callback=None):
        <span class="pcalibre1 pcalibre calibre18">if</span> callback <span class="pcalibre1 pcalibre calibre18">is</span> None:
            callback = who.update
        self.channels[channel][who] = callback</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">These are some variations of the general observer pattern, and I’m
sure you can imagine more. What I want you to notice are the options
available in Python when you leverage function objects, and other
Pythonic features.</p>
</section>
</section>
<section class="calibre2 pcalibre1 pcalibre" title="Magic Methods">
<h2 id="calibre_link-101" class="pcalibre1 pcalibre calibre1">Magic Methods</h2>
<p class="pcalibre1 pcalibre calibre7">
Suppose we want to create a class to work with angles, in
degrees. We want this class to help us with some standard bookkeeping:</p>
<div class="pcalibre1 pcalibre itemized-list">
<ul class="pcalibre1 calibre14 pcalibre">
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">An angle will be at least zero, but less than 360.</span>
</li>
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">If we create an angle outside this range,
it automatically wraps around to an equivalent, in-range value.</span>
</li>
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">In fact, we want the conversion to happen in a range of situations:</span>
<div class="pcalibre1 pcalibre itemized-list1">
<ul class="pcalibre1 calibre14 pcalibre">
<li class="pcalibre8 pcalibre calibre4">
<span class="pcalibre1 principal pcalibre">If we add 270Âº and 270Âº, it evaluates to 180Âº instead of 540Âº.</span>
</li>
<li class="pcalibre8 pcalibre calibre4">
<span class="pcalibre1 principal pcalibre">If we subtract 180Âº from 90Âº, it evaluates to 270Âº instead of -90Âº.</span>
</li>
<li class="pcalibre8 pcalibre calibre4">
<span class="pcalibre1 principal pcalibre">If we multiply an angle by a real number, it wraps the final
value into the correct range.</span>
</li>
</ul>
</div>
</li>
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">And while we’re at it, we want to enable all the other behaviors we
normally want with numbers: comparisons like "less than" and
"greater or equal than" or "==" (i.e., equals); division (which
doesn’t normally require casting into a valid
range, if you think about it); and so on.</span>
</li>
</ul>
</div>
<p class="pcalibre1 pcalibre calibre7">Let’s see how we might approach this, by creating a basic Angle class:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">class</span> <span class="pcalibre1 pcalibre calibre18">Angle</span>:
    <span class="pcalibre1 pcalibre calibre18">def</span> __init__(self, value):
        self.value = value % 360</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">The modular division in the constructor is kind of neat: if you reason
through it with a few positive and negative values, you’ll find the
math works out correctly whether the angle is overshooting or
undershooting. This meets one of our key criteria already: the angle
is normalized to be from 0 up to 360. But how do we handle addition?
We of course get an error if we try it directly:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11">&gt;&gt;&gt; Angle(30) + Angle(45)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: unsupported operand type(s) for +: 'Angle' and 'Angle'
&gt;&gt;&gt;</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">We can easily define a method called <code class="pcalibre1 pcalibre literal">add</code> or something, which will
let us write code like <code class="pcalibre1 pcalibre literal">angle3 = angle1.add(angle2)</code>. But it’s better
if we can reuse the familiar arithmetic operators everyone knows.
Python lets us do that, through a collection of object hooks called
<em class="pcalibre1 calibre8 pcalibre">magic methods</em>. It lets you define classes so that their instances
can be used with all of Python’s standard operators. That includes
arithmetic (+ - * / //), equality (==), inequality (!=), comparisons
(&lt; &gt; &gt;= &lt;=), bit-shifting operations, and even concepts like
exponentiation and absolute value.</p>
<p class="pcalibre1 pcalibre calibre7">Few classes will need all of these, but sometimes it’s invaluable to
have them available. Let’s see how they can improve our <code class="pcalibre1 pcalibre literal">Angle</code> type.</p>
<section class="calibre2 pcalibre1 pcalibre" title="Simple Math Magic">
<h3 id="calibre_link-187" class="pcalibre1 calibre21 pcalibre">Simple Math Magic</h3>
<p class="pcalibre1 pcalibre calibre7">The pattern for each method is the same. For a given operation - say,
addition - there is a special method name that starts and begins with
double-underscores. For addition, it’s <code class="pcalibre1 pcalibre literal">__add__</code> - the others also
have sensible names. All you have to do is define that method, and
instances of your class can be used with that operator. These are the
magic methods.</p>
<p class="pcalibre1 pcalibre calibre7">When you discuss magic methods in face-to-face, verbal conversation,
you’ll find yourself saying things like "underscore underscore add
underscore underscore" over and over.   That’s a lot
of syllables, and you’ll get tired of it fast. So people in the Python
community use a kind of verbal abbreviation, with a word they
invented: "dunder". That’s not a real word; Python people made it
up. When you say "dunder foo", it means "underscore underscore foo
underscore underscore". This isn’t used in writing, because it’s not
needed - you can just write <code class="pcalibre1 pcalibre literal">__foo__</code>. But at Python gatherings,
you’ll sometimes hear people say it. Use it; it saves you a lot of
energy when talking.</p>
<p class="pcalibre1 pcalibre calibre7">Anyway, back to dunder add - I mean, <code class="pcalibre1 pcalibre literal">__add__</code>. For operations like
addition - which take two values, and return a third - you write the
method like this:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>    <span class="pcalibre1 pcalibre calibre18">def</span> __add__(self, other):
         <span class="pcalibre1 pcalibre calibre18">return</span> Angle(self.value + other.value)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">The first argument needs to be called "self", because this is
Python. The second does not have to be called "other", but often
is. This lets us use the normal addition operator for arithmetic:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11">&gt;&gt;&gt; total = Angle(30) + Angle(45)
&gt;&gt;&gt; total.value
75</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">There are similar operators for subtraction (<code class="pcalibre1 pcalibre literal">__sub__</code>),
multiplication (<code class="pcalibre1 pcalibre literal">__mul__</code>), and so on:</p>
<div class="pcalibre1 pcalibre footnotes">
<div class="pcalibre1 pcalibre content">
<table class="pcalibre1 pcalibre table">
<colgroup class="pcalibre1 calibre22 pcalibre">
<col class="calibre23 pcalibre1 pcalibre"></col>
<col class="calibre23 pcalibre1 pcalibre"></col>
</colgroup>
<tbody class="pcalibre1 pcalibre calibre24">
<tr class="pcalibre1 pcalibre calibre25">
<td class="pcalibre1 pcalibre calibre26"><p class="pcalibre1 pcalibre calibre27"><code class="pcalibre1 pcalibre literal">__add__</code></p></td>
<td class="pcalibre1 pcalibre calibre26"><p class="pcalibre1 pcalibre calibre27">a + b</p></td>
</tr>
<tr class="pcalibre1 pcalibre calibre25">
<td class="pcalibre1 pcalibre calibre26"><p class="pcalibre1 pcalibre calibre27"><code class="pcalibre1 pcalibre literal">__sub__</code></p></td>
<td class="pcalibre1 pcalibre calibre26"><p class="pcalibre1 pcalibre calibre27">a - b</p></td>
</tr>
<tr class="pcalibre1 pcalibre calibre25">
<td class="pcalibre1 pcalibre calibre26"><p class="pcalibre1 pcalibre calibre27"><code class="pcalibre1 pcalibre literal">__mul__</code></p></td>
<td class="pcalibre1 pcalibre calibre26"><p class="pcalibre1 pcalibre calibre27">a * b</p></td>
</tr>
<tr class="pcalibre1 pcalibre calibre25">
<td class="pcalibre1 pcalibre calibre26"><p class="pcalibre1 pcalibre calibre27"><code class="pcalibre1 pcalibre literal">__truediv__</code></p></td>
<td class="pcalibre1 pcalibre calibre26"><p class="pcalibre1 pcalibre calibre27">a / b (floating-point division)</p></td>
</tr>
<tr class="pcalibre1 pcalibre calibre25">
<td class="pcalibre1 pcalibre calibre26"><p class="pcalibre1 pcalibre calibre27"><code class="pcalibre1 pcalibre literal">__mod__</code></p></td>
<td class="pcalibre1 pcalibre calibre26"><p class="pcalibre1 pcalibre calibre27">a % b</p></td>
</tr>
<tr class="pcalibre1 pcalibre calibre25">
<td class="pcalibre1 pcalibre calibre26"><p class="pcalibre1 pcalibre calibre27"><code class="pcalibre1 pcalibre literal">__pow__</code></p></td>
<td class="pcalibre1 pcalibre calibre26"><p class="pcalibre1 pcalibre calibre27">a ** b</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<p class="pcalibre1 pcalibre calibre7">Essentially, Python translates <code class="pcalibre1 pcalibre literal">a + b</code> to <code class="pcalibre1 pcalibre literal">a.__add__(b)</code>; <code class="pcalibre1 pcalibre literal">a % b</code> to
<code class="pcalibre1 pcalibre literal">a.__mod__(b)</code>; and so on. You can also hook into bit-operation operators:</p>
<div class="pcalibre1 pcalibre footnotes">
<div class="pcalibre1 pcalibre content">
<table class="pcalibre1 pcalibre table">
<colgroup class="pcalibre1 calibre22 pcalibre">
<col class="calibre23 pcalibre1 pcalibre"></col>
<col class="calibre23 pcalibre1 pcalibre"></col>
</colgroup>
<tbody class="pcalibre1 pcalibre calibre24">
<tr class="pcalibre1 pcalibre calibre25">
<td class="pcalibre1 pcalibre calibre26"><p class="pcalibre1 pcalibre calibre27"><code class="pcalibre1 pcalibre literal">__lshift__</code></p></td>
<td class="pcalibre1 pcalibre calibre26"><p class="pcalibre1 pcalibre calibre27">a &lt;&lt; b</p></td>
</tr>
<tr class="pcalibre1 pcalibre calibre25">
<td class="pcalibre1 pcalibre calibre26"><p class="pcalibre1 pcalibre calibre27"><code class="pcalibre1 pcalibre literal">__rshift__</code></p></td>
<td class="pcalibre1 pcalibre calibre26"><p class="pcalibre1 pcalibre calibre27">a &gt;&gt; b</p></td>
</tr>
<tr class="pcalibre1 pcalibre calibre25">
<td class="pcalibre1 pcalibre calibre26"><p class="pcalibre1 pcalibre calibre27"><code class="pcalibre1 pcalibre literal">__and__</code></p></td>
<td class="pcalibre1 pcalibre calibre26"><p class="pcalibre1 pcalibre calibre27">a &amp; b</p></td>
</tr>
<tr class="pcalibre1 pcalibre calibre25">
<td class="pcalibre1 pcalibre calibre26"><p class="pcalibre1 pcalibre calibre27"><code class="pcalibre1 pcalibre literal">__xor__</code></p></td>
<td class="pcalibre1 pcalibre calibre26"><p class="pcalibre1 pcalibre calibre27">a ^ b</p></td>
</tr>
<tr class="pcalibre1 pcalibre calibre25">
<td class="pcalibre1 pcalibre calibre26"><p class="pcalibre1 pcalibre calibre27"><code class="pcalibre1 pcalibre literal">__or__</code></p></td>
<td class="pcalibre1 pcalibre calibre26"><p class="pcalibre1 pcalibre calibre27">a | b</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<p class="pcalibre1 pcalibre calibre7">So <code class="pcalibre1 pcalibre literal">a &amp; b</code> translates to <code class="pcalibre1 pcalibre literal">a.__and__(b)</code>, for example. Since <code class="pcalibre1 pcalibre literal">__and__</code>
corresponds to the bitwise-and operator (for expressions like <code class="pcalibre1 pcalibre literal">"foo &amp;
bar"</code>), you might wonder what the magic method is for <em class="pcalibre1 calibre8 pcalibre">logical</em>-and
(<code class="pcalibre1 pcalibre literal">"foo and bar"</code>), or logical-or (<code class="pcalibre1 pcalibre literal">"foo or bar"</code>). Sadly, there is
none. For this reason, sometimes libraries will hijack the <code class="pcalibre1 pcalibre literal">&amp;</code> and <code class="pcalibre1 pcalibre literal">|</code>
operators to mean logical and/or instead of bitwise and/or, if the
author feels the logical version is more important.</p>
<p class="pcalibre1 pcalibre calibre7">The default representation of an <code class="pcalibre1 pcalibre literal">Angle</code> object isn’t very useful:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11">&gt;&gt;&gt; Angle(30)
&lt;__main__.Angle object at 0x106df9198&gt;</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">It tells us the type, and the hex object ID, but we’d rather it tell
us something about the value of the angle.  There are two magic methods
that can help. The first is <code class="pcalibre1 pcalibre literal">__str__</code>, which is used when printing a
result:

</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>    <span class="pcalibre1 pcalibre calibre18">def</span> __str__(self):
        <span class="pcalibre1 pcalibre calibre18">return</span> <span class="pcalibre1 pcalibre calibre13">'{} degrees'</span>.format(self.value)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">The <code class="pcalibre1 pcalibre literal">print()</code> function uses this, as well as <code class="pcalibre1 pcalibre literal">str()</code>, and the string
formatting operations:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11">&gt;&gt;&gt; print(Angle(30))
30 degrees
&gt;&gt;&gt; print('{}'.format(Angle(30) + Angle(45)))
75 degrees
&gt;&gt;&gt; str(Angle(135))
'135 degrees'</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Sometimes, you want a string representation that is more precise,
which might be at odds with a human-friendly representation. Imagine
you have several subclasses (e.g., <code class="pcalibre1 pcalibre literal">PitchAngle</code> and <code class="pcalibre1 pcalibre literal">YawAngle</code> in some
kind of aircraft-related library), and want to easily log the exact
type and arguments needed to recreate the object. Python provides a
second magic method for this purpose, called <code class="pcalibre1 pcalibre literal">__repr__</code>:
 </p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>    <span class="pcalibre1 pcalibre calibre18">def</span> __repr__(self):
        <span class="pcalibre1 pcalibre calibre18">return</span> <span class="pcalibre1 pcalibre calibre13">'Angle({})'</span>.format(self.value)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">You access this by calling either the <code class="pcalibre1 pcalibre literal">repr()</code> built-in function (think
of it as working like <code class="pcalibre1 pcalibre literal">str()</code>, but invokes <code class="pcalibre1 pcalibre literal">__repr__</code> instead of
<code class="pcalibre1 pcalibre literal">__str__</code>), or by passing the <code class="pcalibre1 pcalibre literal">!r</code> conversion to the formatting
string:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11">&gt;&gt;&gt; repr(Angle(30))
'Angle(30)'
&gt;&gt;&gt; print('{!r}'.format(Angle(30) + Angle(45)))
Angle(75)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">The official guideline is that the output of <code class="pcalibre1 pcalibre literal">__repr__</code> is something
that can be passed to <code class="pcalibre1 pcalibre literal">eval()</code> to recreate the object exactly.  It’s
not enforced by the language, and isn’t always practical, or even
possible. But when it is, doing so is useful for logging and
debugging.</p>
<p class="pcalibre1 pcalibre calibre7">We also want to be able to compare two <code class="pcalibre1 pcalibre literal">Angle</code> objects. The most basic
comparison is equality, provided by <code class="pcalibre1 pcalibre literal">__eq__</code>. It should return True
or False:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>    <span class="pcalibre1 pcalibre calibre18">def</span> __eq__(self, other):
        <span class="pcalibre1 pcalibre calibre18">return</span> self.value == other.value</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">If defined, this method is used by the <code class="pcalibre1 pcalibre literal">==</code> operator:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11">&gt;&gt;&gt; Angle(3) == Angle(3)
True
&gt;&gt;&gt; Angle(7) == Angle(1)
False</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">By default, the <code class="pcalibre1 pcalibre literal">==</code> operator for objects is based off the object
ID. That’s rarely useful:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11">&gt;&gt;&gt; class BadAngle:
...     def __init__(self, value):
...         self.value = value
...
&gt;&gt;&gt; BadAngle(3) == BadAngle(3)
False</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">The <code class="pcalibre1 pcalibre literal">!=</code> operator has its own magic method, <code class="pcalibre1 pcalibre literal">__ne__</code>. It works the
same way:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>    <span class="pcalibre1 pcalibre calibre18">def</span> __ne__(self, other):
        <span class="pcalibre1 pcalibre calibre18">return</span> self.value != other.value</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">What happens if you don’t implement <code class="pcalibre1 pcalibre literal">__ne__</code>? In Python 3, if you
define <code class="pcalibre1 pcalibre literal">__eq__</code> but not <code class="pcalibre1 pcalibre literal">__ne__</code>, then the <code class="pcalibre1 pcalibre literal">!=</code> operator will use
<code class="pcalibre1 pcalibre literal">__eq__</code>, negating the output. Especially for simple classes like
<code class="pcalibre1 pcalibre literal">Angle</code>, this default behavior is logically valid. So in this case, we
don’t need to define a <code class="pcalibre1 pcalibre literal">__ne__</code> method at all. For more complex types,
the concepts of equality and inequality may have more subtle nuances,
and you will need to implement both.</p>
<p class="pcalibre1 pcalibre calibre7">What’s left are the fuzzier comparison operations; less than, greater
than, and so on.  Python’s documentation calls these "rich comparison"
methods, so you can feel wealthy when using them:</p>
<div class="pcalibre1 pcalibre itemized-list">
<ul class="pcalibre1 calibre14 pcalibre">
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre"><code class="pcalibre1 pcalibre literal">__lt__</code> for "less than" (&lt;)</span>
</li>
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre"><code class="pcalibre1 pcalibre literal">__le__</code> for "less than or equal" (&lt;=)</span>
</li>
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre"><code class="pcalibre1 pcalibre literal">__gt__</code> for "greater than" (&gt;)</span>
</li>
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre"><code class="pcalibre1 pcalibre literal">__ge__</code> for "greater than or equal" (&gt;=)</span>
</li>
</ul>
</div>
<p class="pcalibre1 pcalibre calibre7">For example:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>    <span class="pcalibre1 pcalibre calibre18">def</span> __gt__(self, other):
        <span class="pcalibre1 pcalibre calibre18">return</span> self.value &gt; other.value</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Now the greater-than operator works correctly:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11">&gt;&gt;&gt; Angle(100) &gt; Angle(50)
True</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Similar with <code class="pcalibre1 pcalibre literal">__ge__</code>, <code class="pcalibre1 pcalibre literal">__lt__</code>, etc. If you don’t define these, you get an
error, at least in Python 3:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11">&gt;&gt;&gt; BadAngle(8) &gt; BadAngle(4)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: unorderable types: BadAngle() &gt; BadAngle()</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7"><code class="pcalibre1 pcalibre literal">__gt__</code> and <code class="pcalibre1 pcalibre literal">__lt__</code> are reflections of each other. What that means
is that, in many cases, you only have to define one of them. Suppose
you implement <code class="pcalibre1 pcalibre literal">__gt__</code> but not <code class="pcalibre1 pcalibre literal">__lt__</code>, then do this:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11">&gt;&gt;&gt; a1 = Angle(3)
&gt;&gt;&gt; a2 = Angle(7)
&gt;&gt;&gt; a1 &lt; a2
True</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">This works thanks to some just-in-time introspection the Python
runtime does. The <code class="pcalibre1 pcalibre literal">a1 &lt; a2</code> is, semantically, equivalent to
<code class="pcalibre1 pcalibre literal">a1.__lt__(a2)</code>. If <code class="pcalibre1 pcalibre literal">Angle.__lt__</code> is indeed defined, that semantic
equivalent is executed, and the expression evaluates to its return
value.</p>
<p class="pcalibre1 pcalibre calibre7">For normal scalar numbers, <code class="pcalibre1 pcalibre literal">n &lt; m</code> is true if and only if <code class="pcalibre1 pcalibre literal">m &gt; n</code>. For
this reason, if <code class="pcalibre1 pcalibre literal">__lt__</code> does not exist, but <code class="pcalibre1 pcalibre literal">__gt__</code> does, then
Python will rewrite the angle comparison: <code class="pcalibre1 pcalibre literal">a1.__lt__(a2)</code> becomes
<code class="pcalibre1 pcalibre literal">a2.__gt__(a1)</code>. This is then evaluated, and the expression <code class="pcalibre1 pcalibre literal">a1 &lt;
a2</code> is set to its return value.</p>
<p class="pcalibre1 pcalibre calibre7">Note there are situations where this is actually <em class="pcalibre1 calibre8 pcalibre">not</em> what you
want. Imagine a <code class="pcalibre1 pcalibre literal">Point</code> type, for example, with two coordinates, x and
y. You want <code class="pcalibre1 pcalibre literal">point1 &lt; point2</code> to be <code class="pcalibre1 pcalibre literal">True</code> if and only if <code class="pcalibre1 pcalibre literal">point1.x &lt;
point2.x</code>, AND <code class="pcalibre1 pcalibre literal">point1.y &lt; point2.y</code>. Similarly for <code class="pcalibre1 pcalibre literal">point1 &gt;
point2</code>. There are many points for which both <code class="pcalibre1 pcalibre literal">point1 &lt; point2</code> and
<code class="pcalibre1 pcalibre literal">point1 &gt; point2</code> should both evaluate to <code class="pcalibre1 pcalibre literal">False</code>.</p>
<p class="pcalibre1 pcalibre calibre7">For types like this, you will want to implement both <code class="pcalibre1 pcalibre literal">__gt__</code> and
<code class="pcalibre1 pcalibre literal">__lt__</code> (and <code class="pcalibre1 pcalibre literal">__ge__</code> and <code class="pcalibre1 pcalibre literal">__le__</code>.) You might also need to
raise <code class="pcalibre1 pcalibre literal">NotImplemented</code> in the method. This built-in exception signals to the
Python runtime that the operation is not supported, at least for these arguments.</p>
<section class="calibre2 pcalibre1 pcalibre" title="Shortcut: functools.total_ordering">
<h4 id="calibre_link-188" class="pcalibre1 pcalibre calibre28">Shortcut: functools.total_ordering</h4>
<p class="pcalibre1 pcalibre calibre7">The <code class="pcalibre1 pcalibre literal">functools</code> module in the standard library defines a class decorator
named <code class="pcalibre1 pcalibre literal">total_ordering</code>. In practice, for any class which needs to
implement all the rich comparison operations, using this labor-saving
decorator should be your first choice.</p>
<p class="pcalibre1 pcalibre calibre7">In essence: in your class, you define both <code class="pcalibre1 pcalibre literal">__eq__</code> and <strong class="pcalibre1 pcalibre calibre9">one</strong> of the
comparison magic methods: <code class="pcalibre1 pcalibre literal">__lt__</code>, <code class="pcalibre1 pcalibre literal">__le__</code>, <code class="pcalibre1 pcalibre literal">__gt__</code>, or
<code class="pcalibre1 pcalibre literal">__ge__</code>. (You can define more than one, but it’s not necessary.) Then
you apply the decorator to the <em class="pcalibre1 calibre8 pcalibre">class</em>:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">import</span> <span class="pcalibre1 pcalibre calibre18">functools</span>
@functools.total_ordering
<span class="pcalibre1 pcalibre calibre18">class</span> <span class="pcalibre1 pcalibre calibre18">Angle</span>:
    <span class="pcalibre1 pcalibre calibre13"># ...</span>
    <span class="pcalibre1 pcalibre calibre18">def</span> __eq__(self, other):
        <span class="pcalibre1 pcalibre calibre18">return</span> self.value == other.value
    <span class="pcalibre1 pcalibre calibre18">def</span> __gt__(self, other):
        <span class="pcalibre1 pcalibre calibre18">return</span> self.value &gt; other.value</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">When you do this, all missing rich comparison operators are supplied,
defined in terms of <code class="pcalibre1 pcalibre literal">__eq__</code> and the one operator you defined. This
can save you a fair amount of typing.</p>
<p class="pcalibre1 pcalibre calibre7">There are a few situations where you won’t want to use
<code class="pcalibre1 pcalibre literal">total_ordering</code>. One is if the comparison logic for the type is not
well-behaved enough that each operator can be inferred from the other,
via straightforward boolean logic. The <code class="pcalibre1 pcalibre literal">Point</code> class is an example of
this, as might some types if what you are implementing boils down to
some kind of abstract algebra engine.</p>
<p class="pcalibre1 pcalibre calibre7">The other reasons not to use it are (1) performance, and (2) the more
complex stack traces it generates are more trouble than they are
worth. Generally, I recommend you assume these are <em class="pcalibre1 calibre8 pcalibre">not</em> a problem
until proven otherwise. It’s entirely possible you will never
encounter one of the involved stack traces. And the relatively
inefficient implementations that <code class="pcalibre1 pcalibre literal">total_ordering</code> provides are
unlikely to be a problem unless deep inside some nested loop. Starting
with <code class="pcalibre1 pcalibre literal">total_ordering</code> takes little effort, and you can always simply
remove it and hand-code the other magic methods if you need to.</p>
</section>
<section class="calibre2 pcalibre1 pcalibre" title="Python 2 != Python 3">
<h4 id="calibre_link-189" class="pcalibre1 pcalibre calibre28">Python 2 != Python 3</h4>
<p class="pcalibre1 pcalibre calibre7">Some magic methods operate a bit differently in Python 2. For
example,, if <code class="pcalibre1 pcalibre literal">__eq__</code> is defined but <code class="pcalibre1 pcalibre literal">__ne__</code> is not, then <code class="pcalibre1 pcalibre literal">!=</code>
does <em class="pcalibre1 calibre8 pcalibre">not</em> use <code class="pcalibre1 pcalibre literal">__eq__</code>. Instead, it relies on the default
comparison based on object ID:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre13"># Python 2.</span>
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre18">class</span> <span class="pcalibre1 pcalibre calibre18">BadAngle</span>(object):
...     <span class="pcalibre1 pcalibre calibre18">def</span> __init__(self, value):
...         self.value = value
...     <span class="pcalibre1 pcalibre calibre18">def</span> __eq__(self, other):
...         <span class="pcalibre1 pcalibre calibre18">return</span> self.value == other.value
...
&gt;&gt;&gt; BadAngle(3) != BadAngle(3)
True</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">You will probably never actually want this behavior (which is why it
was changed in Python 3). So for Python 2, if you do define <code class="pcalibre1 pcalibre literal">__eq__</code>,
be sure to define <code class="pcalibre1 pcalibre literal">__ne__</code> also:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre13"># A good default __ne__ for Python 2.</span>
<span class="pcalibre1 pcalibre calibre13"># This is basically what Python 3 does automatically.</span>
    <span class="pcalibre1 pcalibre calibre18">def</span> __ne__(self, other):
        <span class="pcalibre1 pcalibre calibre18">return</span> <span class="pcalibre1 pcalibre calibre18">not</span> self.__eq__(other)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">In Python 3, if you don’t define <code class="pcalibre1 pcalibre literal">__lt__</code>, and then try
to compare two objects with the <code class="pcalibre1 pcalibre literal">&lt;</code> operator, you get a <code class="pcalibre1 pcalibre literal">TypeError</code>.
And likewise for <code class="pcalibre1 pcalibre literal">__gt__</code> and the others. That’s a <em class="pcalibre1 calibre8 pcalibre">very</em> good
thing. In Python 2, you instead get a default ordering based off the
object ID. This can lead to truly infuriating bugs:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"># Python 2.
&gt;&gt;&gt; class BadAngle(object):
...     def __init__(self, value):
...         self.value = value
...
&gt;&gt;&gt;
&gt;&gt;&gt; BadAngle(6) &lt; BadAngle(5)
True
&gt;&gt;&gt; BadAngle(6) &lt; BadAngle(5)
False</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">What the heck just happened? When parsing and running the first
<code class="pcalibre1 pcalibre literal">BadAngle(6) &lt; BadAngle(5)</code> line, the Python runtime created two
<code class="pcalibre1 pcalibre literal">BadAngle</code> instances. It turns out the left-hand object was created
with an ID whose value happens to be less than that of the right-hand
object. So the expression evaluates as <code class="pcalibre1 pcalibre literal">True</code>. In the second line, the
opposite happened: the right-hand object won the race, so to speak, so
the expression evaluates as <code class="pcalibre1 pcalibre literal">False</code>. Watch out for this race condition
if you employ magic methods in Python 2.</p>
</section>
</section>
</section>
<section class="calibre2 pcalibre1 pcalibre" title="Rebelliously Misusing Magic Methods">
<h2 id="calibre_link-102" class="pcalibre1 pcalibre calibre1">Rebelliously Misusing Magic Methods</h2>
<p class="pcalibre1 pcalibre calibre7">Magic methods are interesting enough, and quite handy when you need
them. A realistic currency type is a good example. But depending on
the kind of applications you work on, it’s not all that often you will
need to define a class whose instances can be added, subtracted, or
compared.</p>
<p class="pcalibre1 pcalibre calibre7">Things get much more interesting, though, when you don’t follow the
rules.</p>
<p class="pcalibre1 pcalibre calibre7">Here’s a fascinating fact: methods like <code class="pcalibre1 pcalibre literal">__add__</code> are <em class="pcalibre1 calibre8 pcalibre">supposed</em> to do
addition. But it turns out Python doesn’t require it. And methods like
<code class="pcalibre1 pcalibre literal">__gt__</code> are <em class="pcalibre1 calibre8 pcalibre">supposed</em> to return <code class="pcalibre1 pcalibre literal">True</code> or <code class="pcalibre1 pcalibre literal">False</code>. But if you write
a <code class="pcalibre1 pcalibre literal">__gt__</code> which returns something that isn’t a <code class="pcalibre1 pcalibre literal">bool</code>…​ Python won’t
complain at all.</p>
<p class="pcalibre1 pcalibre calibre7">This creates some <em class="pcalibre1 calibre8 pcalibre">amazing</em> possibilities.</p>
<p class="pcalibre1 pcalibre calibre7">To illustrate, let me tell you about Pandas.   As
you may know, this is an excellent data-processing library. It’s
become extremely popular among data scientists who use Python (like
some of you reading this). Pandas has a convenient data type called a
<code class="pcalibre1 pcalibre literal">DataFrame</code>. It represents a two-dimensional collection of data,
organized into rows, with labeled columns:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">import</span> <span class="pcalibre1 pcalibre calibre18">pandas</span>
df = pandas.DataFrame({
        <span class="pcalibre1 pcalibre calibre13">'A'</span>: [-137, 22, -3, 4, 5],
        <span class="pcalibre1 pcalibre calibre13">'B'</span>: [10, 11, 121, 13, 14],
        <span class="pcalibre1 pcalibre calibre13">'C'</span>: [3, 6, 91, 12, 15],
    })</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">There are several ways to create a <code class="pcalibre1 pcalibre literal">DataFrame</code>; here I’ve chosen
to use a dictionary. The keys are column names; the values
are lists, which become that column’s data. So you visually
rotate each list 90 degrees:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre18">print</span>(df)
     A    B   C
0 -137   10   3
1   22   11   6
2   -3  121  91
3    4   13  12
4    5   14  15</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">The rows are numbered for you, and the columns nicely labeled in a
header. The <code class="pcalibre1 pcalibre literal">A</code> column, for example, has different positive and
negative numbers.</p>
<p class="pcalibre1 pcalibre calibre7">Now, one of the many useful things you can do with a <code class="pcalibre1 pcalibre literal">DataFrame</code> is
filter out rows meeting certain criteria.  This doesn’t change the
original dataframe; instead, it creates a <em class="pcalibre1 calibre8 pcalibre">new</em> dataframe, containing
just the rows you want. For example, you can say "give me the rows of
<code class="pcalibre1 pcalibre literal">df</code> in which the <code class="pcalibre1 pcalibre literal">A</code> column has a positive value":</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; positive_a = df[df.A &gt; 0]
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre18">print</span>(positive_a)
    A   B   C
1  22  11   6
3   4  13  12
4   5  14  15</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">All you have to do is pass in <code class="pcalibre1 pcalibre literal">"df &gt; 0"</code> in the square
brackets.</p>
<p class="pcalibre1 pcalibre calibre7">But there’s something weird going on here.  Take a look at the line in
which <code class="pcalibre1 pcalibre literal">positive_a</code> is defined. Do you notice anything unusual there?
Anything strange?</p>
<p class="pcalibre1 pcalibre calibre7">Here’s what is odd: the expression <code class="pcalibre1 pcalibre literal">"df &gt; 0"</code> ought to evaluate to
either <code class="pcalibre1 pcalibre literal">True</code>, or <code class="pcalibre1 pcalibre literal">False</code>. Right? It’s supposed to be a boolean
value…​ with exactly <em class="pcalibre1 calibre8 pcalibre">one bit</em> of information. But the source
dataframe, <code class="pcalibre1 pcalibre literal">df</code>, has many rows. Realistic dataframes can easily have
tens of thousands, even <em class="pcalibre1 calibre8 pcalibre">millions</em> of rows of data. There’s no way a
boolean literal can express which of those rows to keep, and which to
discard. <strong class="pcalibre1 pcalibre calibre9">How does this even work?</strong></p>
<p class="pcalibre1 pcalibre calibre7">Well…​ turns out, it’s not boolean at all:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">&gt;&gt;&gt; </span>comparison = (df.A &gt; 0)
<span class="pcalibre1 pcalibre calibre18">&gt;&gt;&gt; </span>type(comparison)
&lt;class 'pandas.core.series.Series'&gt;
<span class="pcalibre1 pcalibre calibre18">&gt;&gt;&gt; print</span>(comparison)
0    False
1     True
2    False
3     True
4     True
Name: A, dtype: bool</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Yes, you can do that, thanks to Python’s dynamic type system. Python
translates <code class="pcalibre1 pcalibre literal">"df.A &gt; 0"</code> into <code class="pcalibre1 pcalibre literal">"df.A.__gt__(0)"</code>. And that <code class="pcalibre1 pcalibre literal">__gt__</code>
method doesn’t have to return a bool. In fact, in Pandas, it returns a
<code class="pcalibre1 pcalibre literal">Series</code> object (which is like a vector of data), containing <code class="pcalibre1 pcalibre literal">True</code> or
<code class="pcalibre1 pcalibre literal">False</code> for each row. And when that’s passed into <code class="pcalibre1 pcalibre literal">df[]</code> - the square
brackets being handled by the <code class="pcalibre1 pcalibre literal">__getitem__</code> method - that <code class="pcalibre1 pcalibre literal">Series</code>
object is used to filter rows.</p>
<p class="pcalibre1 pcalibre calibre7">To see what this looks like, let’s re-invent part of the interface of
Pandas. I’ll create a library called <code class="pcalibre1 pcalibre literal">fakepandas</code>, which instead of
<code class="pcalibre1 pcalibre literal">DataFrame</code> has a type called <code class="pcalibre1 pcalibre literal">Dataset</code>:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">class</span> <span class="pcalibre1 pcalibre calibre18">Dataset</span>:
    <span class="pcalibre1 pcalibre calibre18">def</span> __init__(self, data):
        self.data = data
        self.labels = sorted(data.keys())
    <span class="pcalibre1 pcalibre calibre18">def</span> __getattr__(self, label: str):
        <span class="pcalibre1 pcalibre calibre13">"Makes references like df.A work."</span>
        <span class="pcalibre1 pcalibre calibre18">return</span> Column(label)
    <span class="pcalibre1 pcalibre calibre13"># Plus some other methods.</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">If I have a <code class="pcalibre1 pcalibre literal">Dataset</code> object named <code class="pcalibre1 pcalibre literal">ds</code>, with a column named <code class="pcalibre1 pcalibre literal">A</code>, the
<code class="pcalibre1 pcalibre literal">__getattr__</code> method makes references like <code class="pcalibre1 pcalibre literal">ds.A</code> return a <code class="pcalibre1 pcalibre literal">Column</code>
object:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">import</span> <span class="pcalibre1 pcalibre calibre18">operator</span>
<span class="pcalibre1 pcalibre calibre18">class</span> <span class="pcalibre1 pcalibre calibre18">Column</span>:
    <span class="pcalibre1 pcalibre calibre18">def</span> __init__(self, name):
        self.name = name
    <span class="pcalibre1 pcalibre calibre18">def</span> __gt__(self, value):
         <span class="pcalibre1 pcalibre calibre18">return</span> Comparison(self.name, value, operator.gt)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">This <code class="pcalibre1 pcalibre literal">Column</code> class has a <code class="pcalibre1 pcalibre literal">__gt__</code> method, which makes expressions
like <code class="pcalibre1 pcalibre literal">"ds.A &gt; 0"</code> return an instance of a class called
<code class="pcalibre1 pcalibre literal">Comparison</code>. It represents a lazy calculation, for when the actual
filtering happens later. Notice its constructor arguments: a column
name, a threshold value, and a callable to implement the
comparison. (The <code class="pcalibre1 pcalibre literal">operator</code> module has a function called <code class="pcalibre1 pcalibre literal">gt</code>, taking
two arguments, expressing a greater-than comparison).</p>
<p class="pcalibre1 pcalibre calibre7">You can even support complex filtering criteria like <code class="pcalibre1 pcalibre literal">ds[ds.C + 2 &lt;
ds.B]</code>.  It’s all possible by leveraging magic methods in these
unorthodox ways.  If you care about the details, there’s an article
delving into that.<sup class="pcalibre1 pcalibre noteref">[<a href="#calibre_link-142" id="calibre_link-146" type="noteref" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">4</a>]</sup>  My goal here
isn’t to tell you how to re-invent the Pandas interface, so much as to
get you to realize what’s possible.</p>
<p class="pcalibre1 calibre7 pcalibre7">Have you ever implemented a compiler? If so, you know the parsing
phase is a significant development challenge. Using Python magic
methods in this manner does much of the hard work of lexing and
parsing for you. And the best part is how natural and intuitive the
result can be for end users.  You are essentially implementing a
mini-language on top of regular Python syntax, but consistently enough
that people quickly become fluent and productive with its rules. And
they often won’t even think to ask why the rules seem to be bent; they
won’t notice <code class="pcalibre1 pcalibre literal">"df.A &gt; 0"</code> isn’t acting like a boolean.  That’s a clear
sign of success. It means you designed your library so well, other
developers become effortlessly productive.</p>
</section>
<footer class="pcalibre1 pcalibre calibre15">
<div class="calibre16 pcalibre1 pcalibre"></div><div class="pcalibre1 pcalibre chapter-footer">
<div class="pcalibre1 pcalibre footnotes">
<aside id="calibre_link-139" type="footnote" class="calibre2 pcalibre1 pcalibre">
<p class="pcalibre1 calibre17 pcalibre"><sup class="noteref1 pcalibre1 pcalibre"><a href="#calibre_link-143" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">1</a></sup> This isn’t enforced by Python itself.  If your teammates don’t already honor this widely-followed convention, you’ll have to educate them.</p>
</aside>
<aside id="calibre_link-140" type="footnote" class="calibre2 pcalibre1 pcalibre">
<p class="pcalibre1 calibre17 pcalibre"><sup class="noteref1 pcalibre1 pcalibre"><a href="#calibre_link-144" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">2</a></sup> This is all detailed in the "Advanced Functions" chapter.</p>
</aside>
<aside id="calibre_link-141" type="footnote" class="calibre2 pcalibre1 pcalibre">
<p class="pcalibre1 calibre17 pcalibre"><sup class="noteref1 pcalibre1 pcalibre"><a href="#calibre_link-145" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">3</a></sup> In Python 2: Remember, use <code class="pcalibre1 pcalibre literal">.viewvalues()</code> instead of <code class="pcalibre1 pcalibre literal">.values()</code>.</p>
</aside>
<aside id="calibre_link-142" type="footnote" class="calibre2 pcalibre1 pcalibre">
<p class="pcalibre1 calibre17 pcalibre"><sup class="noteref1 pcalibre1 pcalibre"><a href="#calibre_link-146" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">4</a></sup> See <a class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4" href="https://powerfulpython.com/blog/rebellious-magic-methods-python-syntax/">https://powerfulpython.com/blog/rebellious-magic-methods-python-syntax/</a> . The article explains these ideas in richer detail, and includes the full code of <code class="pcalibre1 pcalibre literal">fakepandas</code> and its unit test suite.</p>
</aside>
</div>
</div>
</footer>
</section>
</div>


<div id="calibre_link-46" class="pcalibre1 pcalibre calibre">
<section class="calibre2 pcalibre1 pcalibre" id="calibre_link-190" title="Automated Testing and TDD" type="chapter">
<header id="calibre_link-103" class="calibre2 pcalibre1 pcalibre">
<div class="pcalibre1 pcalibre chapter-header">
<h1 class="pcalibre1 chapter-title pcalibre"> <small class="subtitle pcalibre1 pcalibre"><b class="pcalibre1 pcalibre calibre6">AUTOMATED</b> <b class="pcalibre1 pcalibre calibre6">TESTING</b> <b class="pcalibre1 pcalibre calibre6">AND</b> <b class="pcalibre1 pcalibre calibre6">TDD</b></small></h1>
</div>
</header>
<p class="pcalibre1 pcalibre calibre7">



Writing automated tests is one of those things that separates average
developers from the best in the world.  Master this skill, and you
will be able to write <em class="pcalibre1 calibre8 pcalibre">far</em> more complex and powerful software than
you ever could before. It’s a superpower, and changes the arc of
your career.</p>
<p class="pcalibre1 pcalibre calibre7">There are roughly two kinds of readers for this chapter. Some of you
have, so far, little or no experience writing automated tests, in any
language. This chapter is primarily written for you. It introduces
many fundamental ideas of test automation, explains the problems it is
supposed to solve, and teaches how to apply Python’s tools for doing
so.</p>
<p class="pcalibre1 pcalibre calibre7">   Or you might
be someone with extensive experience using standard test frameworks in
other languages: JUnit in Java, PHPUnit in PHP, and so on. Generally
speaking, if you have mastered an xUnit framework in another language,
and are fluent in Python, you may be able to start skimming the
Python’s <code class="pcalibre1 pcalibre literal">unittest</code> module
docs​<sup class="pcalibre1 pcalibre noteref">[<a href="#calibre_link-47" id="calibre_link-54" type="noteref" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">1</a>]</sup>
and be productive in minutes. Python’s
test library, <code class="pcalibre1 pcalibre literal">unittest</code>, was originally based on JUnit 3, and maps
very closely to how most xUnit libraries work.<sup class="pcalibre1 pcalibre noteref">[<a href="#calibre_link-48" id="calibre_link-55" type="noteref" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">2</a>]</sup></p>
<p class="pcalibre1 pcalibre calibre7">If you are more experienced, I believe it’s worth your time to at
least skim the chapter, and perhaps study it thoroughly. In writing, I
invested a great deal of effort weaving in useful, real-world wisdom -
both for software testing in general, and for Python
specifically. This includes topics like how to organize Python test
code; writing test code which is maintainable; useful, Python-only
features like subtests; and even cognitive aspects of
programming…​ getting into an enjoyable, highly productive "flow"
state via test-driven development.</p>
<p class="pcalibre1 pcalibre calibre7">With that in mind, let’s start with the core ideas for writing
automated tests. We’ll then focus on writing them for Python programs.</p>
<section class="calibre2 pcalibre1 pcalibre" title="What is Test-Driven Development?">
<h2 id="calibre_link-104" class="pcalibre1 pcalibre calibre1">What is Test-Driven Development?</h2>
<p class="pcalibre1 pcalibre calibre7">An <em class="pcalibre1 calibre8 pcalibre">automated test</em> is a program that tests another
program. Generally, it tests a specific portion of that program: a
function, a method, a class, or some group of these things. We call
that portion the "system under test". If the system under test is
working correctly, the test passes; if not, our test catches that
error, and immediately tells us what is wrong. Real applications
accumulate many of these tests as development proceeds.</p>
<p class="pcalibre1 pcalibre calibre7">    People have different
names for different kinds of automated tests: unit tests, integration
tests, end-to-end tests, etc. These distinctions can be useful, but we
won’t need to worry about them right now. They all share the same
foundation.</p>
<p class="pcalibre1 pcalibre calibre7">

In this chapter, we do <em class="pcalibre1 calibre8 pcalibre">test-driven development</em>, or TDD. Test-driven
development means you start working on each new feature or bugfix by
writing the automated test for it <strong class="pcalibre1 pcalibre calibre9">first</strong>. You run that test, verify
it fails, and only then do you write the actual code for the
feature. You know you are done when the test passes.</p>
<p class="pcalibre1 pcalibre calibre7">This is a different process from implementing the feature first,
<strong class="pcalibre1 pcalibre calibre9">then</strong> writing a test for it after. Writing the test first forces you
to think through the interfaces of your code, answering the
question "how will I know my code is working?" That immediate
benefit is useful, but not the whole story.</p>
<p class="pcalibre1 pcalibre calibre7">
<strong class="pcalibre1 pcalibre calibre9">The greatest mid-term benefits are mostly cognitive.</strong> As you become
competent and comfortable with test-driven development, you learn to
easily get into a state of flow - where you find yourself repeatedly
implementing feature after feature, keeping your focus with ease for
long periods of time. You can honestly surprise and delight yourself
with how much you’ve accomplished in a few hours of coding.</p>
<p class="pcalibre1 pcalibre calibre7">But the greatest benefits emerge over time. We’ve all done substantial
refactorings  of a large code base, changing
fundamental aspects of its architecture.<sup class="pcalibre1 pcalibre noteref">[<a href="#calibre_link-49" id="calibre_link-56" type="noteref" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">3</a>]</sup>  Such refactorings - which threaten to
break the application in confusing, hidden ways - become
straightforward and safe using TDD. You take the existing body of
tests, updating where needed and introducing new tests as
appropriate. Then all you have to do is make them pass. It may still
be a ton of work. But you can be fairly confident in the correctness
and robustness of the result, instead of hoping and praying.</p>
<p class="pcalibre1 pcalibre calibre7">Among developers who know how to write tests, some love to do
test-driven development in their day to day work. Some like to do it
part of the time; some hate it, and do it rarely, or never. However,
the absolute best way to quickly master unit testing is to strictly do
test-driven development for a while. So I’ll teach you how to do
that. You don’t have to do it forever if you don’t want to.</p>
<p class="pcalibre1 pcalibre calibre7">Python’s standard library ships with two modules for creating unit
tests: <code class="pcalibre1 pcalibre literal">doctest</code> and <code class="pcalibre1 pcalibre literal">unittest</code>.  
 Most engineering teams prefer <code class="pcalibre1 pcalibre literal">unittest</code>, as it
is more full-featured than <code class="pcalibre1 pcalibre literal">doctest</code>. This isn’t just a convenience.
There is a real ceiling of complexity that <code class="pcalibre1 pcalibre literal">doctest</code> can handle, and
real applications will quickly bump up against that limit. With
<code class="pcalibre1 pcalibre literal">unittest</code>, the sky is more or less the limit.</p>
<p class="pcalibre1 pcalibre calibre7">In addition - as noted above - <code class="pcalibre1 pcalibre literal">unittest</code> maps almost exactly to the
xUnit libraries used in many other languages.  If you are
already familiar with Python, and have used JUnit,
PHPUnit, or any other xUnit library in any language, you
will feel right at home with unittest. That said, <code class="pcalibre1 pcalibre literal">unittest</code> has some
unique tools and idioms - partly because of differences in the Python
language, and partly from unique extensions and improvements. We will
learn the best of what <code class="pcalibre1 pcalibre literal">unittest</code> has to offer as we go along.</p>
</section>
<section class="calibre2 pcalibre1 pcalibre" title="Unit Tests And Simple Assertions">
<h2 id="calibre_link-105" class="pcalibre1 pcalibre calibre1">Unit Tests And Simple Assertions</h2>
<p class="pcalibre1 pcalibre calibre7">Imagine a class representing an angle:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; small_angle = Angle(60)
&gt;&gt;&gt; small_angle.degrees
60
&gt;&gt;&gt; small_angle.is_acute()
True
&gt;&gt;&gt; big_angle = Angle(320)
&gt;&gt;&gt; big_angle.is_acute()
False
&gt;&gt;&gt; funny_angle = Angle(1081)
&gt;&gt;&gt; funny_angle.degrees
1
&gt;&gt;&gt; total_angle = small_angle.add(big_angle)
&gt;&gt;&gt; total_angle.degrees
20</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">As you can see, <code class="pcalibre1 pcalibre literal">Angle</code> keeps track of the angle size, wrapping around
so it’s in a range of 0 up to 360 degrees. There is also an <code class="pcalibre1 pcalibre literal">is_acute</code>
method, to tell you if its size is under 90 degrees, and an <code class="pcalibre1 pcalibre literal">add</code>
method for arithmetic.<sup class="pcalibre1 pcalibre noteref">[<a href="#calibre_link-50" id="calibre_link-57" type="noteref" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">4</a>]</sup></p>
<p class="pcalibre1 pcalibre calibre7">Suppose this <code class="pcalibre1 pcalibre literal">Angle</code> class is defined in a file named <code class="pcalibre1 pcalibre literal">angle.py</code>.
Here’s how we create a simple test for it - in a separate file, named
<code class="pcalibre1 pcalibre literal">test_angle.py</code>:</p>
<p class="pcalibre1 pcalibre calibre7"></p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">import</span> <span class="pcalibre1 pcalibre calibre18">unittest</span>
<span class="pcalibre1 pcalibre calibre18">from</span> <span class="pcalibre1 pcalibre calibre18">angle</span> <span class="pcalibre1 pcalibre calibre18">import</span> Angle

<span class="pcalibre1 pcalibre calibre18">class</span> <span class="pcalibre1 pcalibre calibre18">TestAngle</span>(unittest.TestCase):
    <span class="pcalibre1 pcalibre calibre18">def</span> test_degrees(self):
        small_angle = Angle(60)
        self.assertEqual(60, small_angle.degrees)
        self.assertTrue(small_angle.is_acute())
        big_angle = Angle(320)
        self.assertFalse(big_angle.is_acute())
        funny_angle = Angle(1081)
        self.assertEqual(1, funny_angle.degrees)

    <span class="pcalibre1 pcalibre calibre18">def</span> test_arithmetic(self):
        small_angle = Angle(60)
        big_angle = Angle(320)
        total_angle = small_angle.add(big_angle)
        self.assertEqual(20, total_angle.degrees,
                         <span class="pcalibre1 pcalibre calibre13">'Adding angles with wrap-around'</span>)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">As you look over this code, notice a few things:</p>
<div class="pcalibre1 pcalibre itemized-list">
<ul class="pcalibre1 calibre14 pcalibre">
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">There’s a class called <code class="pcalibre1 pcalibre literal">TestAngle</code>. You just define it, not
create any instance of it. This subclasses <code class="pcalibre1 pcalibre literal">TestCase</code>.</span>
</li>
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">You define two methods, <code class="pcalibre1 pcalibre literal">test_degrees</code> and <code class="pcalibre1 pcalibre literal">test_arithmetic</code>.</span>
</li>
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">Both <code class="pcalibre1 pcalibre literal">test_degrees</code> and <code class="pcalibre1 pcalibre literal">test_arithmetic</code> have assertions, using
some methods of <code class="pcalibre1 pcalibre literal">TestCase</code>: <code class="pcalibre1 pcalibre literal">assertEqual</code>, <code class="pcalibre1 pcalibre literal">assertTrue</code>, and
<code class="pcalibre1 pcalibre literal">assertFalse</code>.</span>
</li>
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">The last assertion includes a custom message, as its third argument.</span>
</li>
</ul>
</div>
<p class="pcalibre1 pcalibre calibre7">To see how this works, let’s define a stub for the <code class="pcalibre1 pcalibre literal">Angle</code> class in <code class="pcalibre1 pcalibre literal">angles.py</code>:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre13"># angle.py, version 1</span>
<span class="pcalibre1 pcalibre calibre18">class</span> <span class="pcalibre1 pcalibre calibre18">Angle</span>:
    <span class="pcalibre1 pcalibre calibre18">def</span> __init__(self, degrees):
        self.degrees = 0
    <span class="pcalibre1 pcalibre calibre18">def</span> is_acute(self):
        <span class="pcalibre1 pcalibre calibre18">return</span> False
    <span class="pcalibre1 pcalibre calibre18">def</span> add(self, other_angle):
        <span class="pcalibre1 pcalibre calibre18">return</span> Angle(0)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">This <code class="pcalibre1 pcalibre literal">Angle</code> class defines all the attributes and methods it is
expected to have, but otherwise can’t do anything useful.  We need a
stub like this to verify the test can run correctly, and alert us to
the fact that the code isn’t working yet.</p>
<p class="pcalibre1 pcalibre calibre7">The <code class="pcalibre1 pcalibre literal">unittest</code> module is not just used to define tests, but also to
run them. You do so on the command line like this:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11">python3 -m unittest test_angles.py</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">When you run the test,<sup class="pcalibre1 pcalibre noteref">[<a href="#calibre_link-51" id="calibre_link-58" type="noteref" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">5</a>]</sup> and
you’ll see the following output:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11">$ python3 -m unittest test_angle.py
FF
========================================================
FAIL: test_arithmetic (test_angle.TestAngle)
--------------------------------------------------------
Traceback (most recent call last):
  File "/src/test_angle.py", line 18, in test_arithmetic
    self.assertEqual(20, total_angle.degrees, 'Adding angles with wrap-around')
AssertionError: 20 != 0 : Adding angles with wrap-around

========================================================
FAIL: test_degrees (test_angle.TestAngle)
--------------------------------------------------------
Traceback (most recent call last):
  File "/src/test_angle.py", line 7, in test_degrees
    self.assertEqual(60, small_angle.degrees)
AssertionError: 60 != 0

--------------------------------------------------------
Ran 2 tests in 0.001s

FAILED (failures=2)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Notice:</p>
<div class="pcalibre1 pcalibre itemized-list">
<ul class="pcalibre1 calibre14 pcalibre">
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">Both test methods are shown. They both have a failed assertion
highlighted.</span>
</li>
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre"><code class="pcalibre1 pcalibre literal">test_degrees</code> makes several assertions, but only the first one has
been run - once it fails, the others are not executed.</span>
</li>
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">For each failing assertion, you are given the line number; the
expected and actual values; and its test method.</span>
</li>
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">The custom message in <code class="pcalibre1 pcalibre literal">test_arithmetic</code> shows up in the output.</span>
</li>
</ul>
</div>
<p class="pcalibre1 pcalibre calibre7">This demonstrates one useful way to organize your test code. In a
single test module (<code class="pcalibre1 pcalibre literal">test_angle.py</code>), you define one or more
subclasses of <code class="pcalibre1 pcalibre literal">unittest.TestCase</code>. Here, I just define <code class="pcalibre1 pcalibre literal">TestAngle</code>,
containing tests for the <code class="pcalibre1 pcalibre literal">Angle</code> class. Within this, I create several
test methods, for testing different aspects of the class. And in each
of these test methods, I can have as many assertions as makes sense.</p>
<p class="pcalibre1 pcalibre calibre7">Some of the naming conventions matter. It’s traditional to start a
test class name with the string <code class="pcalibre1 pcalibre literal">Test</code>, but that is not
required; <code class="pcalibre1 pcalibre literal">unittest</code> will find all subclasses of <code class="pcalibre1 pcalibre literal">TestCase</code>
automatically. But every method must start with the string
"test". If it starts with anything else (even "Test"!), <code class="pcalibre1 pcalibre literal">unittest</code>
will not run its assertions.</p>
<p class="pcalibre1 pcalibre calibre7">Running the test and watching it fail is an important first step. It
verifies that the test does, in fact, actually test your code.  As you
write more and more tests, you’ll occasionally create the test; run
it, expecting it to fail; and find it unexpectedly passes. That’s a
bug in your test code! Fortunately you ran the test first, so you
caught it right away.</p>
<p class="pcalibre1 pcalibre calibre7">In the test code, we defined <code class="pcalibre1 pcalibre literal">test_degrees</code> before <code class="pcalibre1 pcalibre literal">test_arithmetic</code>,
but they were actually run in the opposite order. It’s important to
craft your test methods to be self-contained, and not depend on one
being run before the other; the order of execution is essentially
random.<sup class="pcalibre1 pcalibre noteref">[<a href="#calibre_link-52" id="calibre_link-59" type="noteref" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">6</a>]</sup></p>
<p class="pcalibre1 pcalibre calibre7">At this point, we have a correctly failing test. If I’m using version
control and working in a branch, this is a good commit point -
check in the test code, because it specifies the correct behavior
(even if it’s presently failing). The next step is to actually make
that test pass. Here’s one way to do it:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre13"># angle.py, version 2</span>
<span class="pcalibre1 pcalibre calibre18">class</span> <span class="pcalibre1 pcalibre calibre18">Angle</span>:
    <span class="pcalibre1 pcalibre calibre18">def</span> __init__(self, degrees):
        self.degrees = degrees % 360
    <span class="pcalibre1 pcalibre calibre18">def</span> is_acute(self):
        <span class="pcalibre1 pcalibre calibre18">return</span> self.degrees &lt; 90
    <span class="pcalibre1 pcalibre calibre18">def</span> add(self, other_angle):
        <span class="pcalibre1 pcalibre calibre18">return</span> Angle(self.degrees + other_angle.degrees)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Now when I run my test again, the test passes:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11">python3 -m unittest test_angle1.py
..
--------------------------------------------------------
Ran 2 tests in 0.000s

OK</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">This becomes your second commit in version control.</p>
<p class="pcalibre1 pcalibre calibre7"><code class="pcalibre1 pcalibre literal">assertEqual</code>, <code class="pcalibre1 pcalibre literal">assertTrue</code> and <code class="pcalibre1 pcalibre literal">assertFalse</code> will be the most common
assertion methods you’ll use, along with <code class="pcalibre1 pcalibre literal">assertNotEqual</code> (which does
the opposite of <code class="pcalibre1 pcalibre literal">assertEqual</code>). Many others are provided, such as
<code class="pcalibre1 pcalibre literal">assertIs</code>, <code class="pcalibre1 pcalibre literal">assertIsNone</code>, <code class="pcalibre1 pcalibre literal">assertIn</code>, and <code class="pcalibre1 pcalibre literal">assertIsInstance</code> - along
with "not" variants (e.g. <code class="pcalibre1 pcalibre literal">assertIsNot</code>). Each takes a optional final
message-string argument, like "Adding angles with wrap-around" in
<code class="pcalibre1 pcalibre literal">test_arithmetic</code> above. If the test fails, this is printed in the
output, which can give very helpful advice to whomever is
troubleshooting a broken test.<sup class="pcalibre1 pcalibre noteref">[<a href="#calibre_link-53" id="calibre_link-60" type="noteref" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">7</a>]</sup></p>
<p class="pcalibre1 pcalibre calibre7">If you try checking that two dictionaries are equal, and they are not,
the output is tailored to the data type: highlighting which key is
missing, or which value is incorrect, for example. This also
happens with lists, tuples, and sets, making troubleshooting much
easier. What’s actually happening is that <code class="pcalibre1 pcalibre literal">unittest</code> provides certain
type-specialized assertions, like <code class="pcalibre1 pcalibre literal">assertDictEqual</code>,
<code class="pcalibre1 pcalibre literal">assertListEqual</code>, and more. You almost never need to invoke them
directly: if you invoke <code class="pcalibre1 pcalibre literal">assertEqual</code> with two dictionaries, it
automatically dispatches to <code class="pcalibre1 pcalibre literal">assertDictEqual</code>, and similar for the
other types. So you get this usefully detailed error reporting for
free.</p>
<p class="pcalibre1 pcalibre calibre7">Notice the <code class="pcalibre1 pcalibre literal">assertEqual</code> lines take two arguments, and I always
wrote the expected, correct value first:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>small_angle = Angle(60)
self.assertEqual(60, small_angle.degrees)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">It does not matter whether the expected value is first, or second. But
it’s smart to pick an order and stick with it - at least throughout a
single codebase, and maybe for all code you write. Sticking with a
consistent order greatly improves the readability of your test output,
because you never have to decipher which is which. Believe
me, this will save you a lot of time in the long run. If you’re on a
team, negotiate with them to agree on a consistent order.</p>
</section>
<section class="calibre2 pcalibre1 pcalibre" title="Fixtures And Common Test Setup">
<h2 id="calibre_link-106" class="pcalibre1 pcalibre calibre1">Fixtures And Common Test Setup</h2>
<p class="pcalibre1 pcalibre calibre7">


As an application grows and you write more tests, you will find
yourself writing groups of test methods that start or end with the
same lines of code. This repeated code - which does some kind of
pretest set-up, and/or after-test cleanup - can be consolidated in the
special methods <code class="pcalibre1 pcalibre literal">setUp</code> and <code class="pcalibre1 pcalibre literal">tearDown</code>. When defined in your
<code class="pcalibre1 pcalibre literal">TestCase</code> subclass, <code class="pcalibre1 pcalibre literal">setUp</code> is executed just before each test method
starts; <code class="pcalibre1 pcalibre literal">tearDown</code> is run just after. This is repeated for every
single test method.</p>
<p class="pcalibre1 pcalibre calibre7">Here’s a realistic example of when you might use it. Imagine working
on a tool that saves its state between runs in a special file, in JSON
format. We’ll call this the "state file". On start, it reads the state
from the file; on exit, it rewrites it, if there are any changes. A
stub of this class might look like</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre13"># statefile.py</span>
<span class="pcalibre1 pcalibre calibre18">class</span> <span class="pcalibre1 pcalibre calibre18">State</span>:
    <span class="pcalibre1 pcalibre calibre18">def</span> __init__(self, state_file_path):
        <span class="pcalibre1 pcalibre calibre13"># Load the stored state data, and save</span>
        <span class="pcalibre1 pcalibre calibre13"># it in self.data.</span>
        self.data = { }
    <span class="pcalibre1 pcalibre calibre18">def</span> close(self):
        <span class="pcalibre1 pcalibre calibre13"># Handle any changes on application exit.</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">In fleshing out this stub, we want our tests to verify the following:</p>
<div class="pcalibre1 pcalibre itemized-list">
<ul class="pcalibre1 calibre14 pcalibre">
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">If I add a new key-value pair to the state, it is recorded
correctly in the state file.</span>
</li>
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">If I alter the value of an existing key, that updated value is
written to the state file.</span>
</li>
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">If the state is not changed, the state file’s content stays the
same.</span>
</li>
</ul>
</div>
<p class="pcalibre1 pcalibre calibre7">For each test, we want the state file to be in a known starting
state. Afterwards, we want to remove that file, so our tests don’t
leave garbage files on the filesystem. Here’s how the <code class="pcalibre1 pcalibre literal">setUp</code> and
<code class="pcalibre1 pcalibre literal">tearDown</code> methods accomplish this:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">import</span> <span class="pcalibre1 pcalibre calibre18">os</span>
<span class="pcalibre1 pcalibre calibre18">import</span> <span class="pcalibre1 pcalibre calibre18">unittest</span>
<span class="pcalibre1 pcalibre calibre18">import</span> <span class="pcalibre1 pcalibre calibre18">shutil</span>
<span class="pcalibre1 pcalibre calibre18">import</span> <span class="pcalibre1 pcalibre calibre18">tempfile</span>
<span class="pcalibre1 pcalibre calibre18">from</span> <span class="pcalibre1 pcalibre calibre18">statefile</span> <span class="pcalibre1 pcalibre calibre18">import</span> State

INITIAL_STATE = <span class="pcalibre1 pcalibre calibre13">'{"foo": 42, "bar": 17}'</span>

<span class="pcalibre1 pcalibre calibre18">class</span> <span class="pcalibre1 pcalibre calibre18">TestState</span>(unittest.TestCase):
    <span class="pcalibre1 pcalibre calibre18">def</span> setUp(self):
        self.testdir = tempfile.mkdtemp()
        self.state_file_path = os.path.join(
            self.testdir, <span class="pcalibre1 pcalibre calibre13">'statefile.json'</span>)
        <span class="pcalibre1 pcalibre calibre18">with</span> open(self.state_file_path, <span class="pcalibre1 pcalibre calibre13">'w'</span>) <span class="pcalibre1 pcalibre calibre18">as</span> outfile:
            outfile.write(INITIAL_STATE)
        self.state = State(self.state_file_path)

    <span class="pcalibre1 pcalibre calibre18">def</span> tearDown(self):
        shutil.rmtree(self.testdir)

    <span class="pcalibre1 pcalibre calibre18">def</span> test_change_value(self):
        self.state.data[<span class="pcalibre1 pcalibre calibre13">"foo"</span>] = 21
        self.state.close()
        reloaded_statefile = State(self.state_file_path)
        self.assertEqual(21,
            reloaded_statefile.data[<span class="pcalibre1 pcalibre calibre13">"foo"</span>])

    <span class="pcalibre1 pcalibre calibre18">def</span> test_remove_value(self):
        <span class="pcalibre1 pcalibre calibre18">del</span> self.state.data[<span class="pcalibre1 pcalibre calibre13">"bar"</span>]
        self.state.close()
        reloaded_statefile = State(self.state_file_path)
        self.assertNotIn(<span class="pcalibre1 pcalibre calibre13">"bar"</span>, reloaded_statefile.data)

    <span class="pcalibre1 pcalibre calibre18">def</span> test_no_change(self):
        self.state.close()
        <span class="pcalibre1 pcalibre calibre18">with</span> open(self.state_file_path) <span class="pcalibre1 pcalibre calibre18">as</span> handle:
            checked_content = handle.read()
        self.assertEqual(checked_content, INITIAL_STATE)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">In <code class="pcalibre1 pcalibre literal">setUp</code>, we create a fresh temporary directory, and write the
contents of <code class="pcalibre1 pcalibre literal">INITIAL_DATA</code> inside. Since we know each test will be
working with a <code class="pcalibre1 pcalibre literal">State</code> object based on that initial data, we go ahead
and create that object, and save it in <code class="pcalibre1 pcalibre literal">self.state</code>. Each test can
then work with that object, confident it is in the same consistent
starting state, regardless of what any other test method does. In
effect, <code class="pcalibre1 pcalibre literal">setUp</code> creates a private sandbox for each test method.</p>
<p class="pcalibre1 pcalibre calibre7">The tests in <code class="pcalibre1 pcalibre literal">TestState</code> would all work reliably with just
<code class="pcalibre1 pcalibre literal">setUp</code>. But we also want to clean up the temporary files we created;
otherwise, they will accumulate over time with repeated test runs. The
<code class="pcalibre1 pcalibre literal">tearDown</code> method will run after each <code class="pcalibre1 pcalibre literal">test_*</code> method completes, even
if some of its assertions fail. This ensures the temp files and
directories are all removed completely.</p>
<p class="pcalibre1 pcalibre calibre7">The generic term for this kind of pre-test preparation is called a
<em class="pcalibre1 calibre8 pcalibre">test fixture</em>. A test fixture is whatever needs to be done before a
test can properly run. In this case, we set up the text fixture by
creating the state file, and the <code class="pcalibre1 pcalibre literal">State</code> object. A text fixture can be
a mock database; a set of files in a known state; some kind of network
connection; or even starting a server process. You can do all these
with <code class="pcalibre1 pcalibre literal">setUp</code>.</p>
<p class="pcalibre1 pcalibre calibre7"><code class="pcalibre1 pcalibre literal">tearDown</code> is for shutting down and cleaning up the text fixture:
deleting files, stopping the server process, etc.  For some kinds of
tests, a tear-down might not be at all optional. If <code class="pcalibre1 pcalibre literal">setUp</code> starts
some kind of server process, for example, and <code class="pcalibre1 pcalibre literal">tearDown</code> fails to
terminate it, then <code class="pcalibre1 pcalibre literal">setUp</code> may not be able to run for the next
test.</p>
<p class="pcalibre1 pcalibre calibre7">The camel-casing matters: people sometimes misspell them as <code class="pcalibre1 pcalibre literal">setup</code> or
<code class="pcalibre1 pcalibre literal">teardown</code>, then wonder why they don’t seem to be invoked. Also, any
uncaught exception in either <code class="pcalibre1 pcalibre literal">setUp</code> or <code class="pcalibre1 pcalibre literal">tearDown</code> will cause
<code class="pcalibre1 pcalibre literal">unittest</code> to mark the test method as failing (which means it will clearly
show up in the test output), then immediately skip to the next test.
For errors in <code class="pcalibre1 pcalibre literal">setUp</code>, this means none of that test’s assertions will
run (though it’s still marked as failing). For <code class="pcalibre1 pcalibre literal">tearDown</code>, the test is
marked as failing, even if all the individual assertions passed.</p>
</section>
<section class="calibre2 pcalibre1 pcalibre" title="Asserting Exceptions">
<h2 id="calibre_link-107" class="pcalibre1 pcalibre calibre1">Asserting Exceptions</h2>
<p class="pcalibre1 pcalibre calibre7">Sometimes your code is supposed to raise an exception, under certain
exceptional conditions. If that condition occurs, and your code does
<em class="pcalibre1 calibre8 pcalibre">not</em> raise the correct exception, that’s a bug. How do you write test
code for this situation?</p>
<p class="pcalibre1 pcalibre calibre7">You can verify that behavior with a special method of <code class="pcalibre1 pcalibre literal">TestCase</code>,
called <code class="pcalibre1 pcalibre literal">assertRaises</code>. It’s used
in a <code class="pcalibre1 pcalibre literal">with</code> statement in your test; the block under the <code class="pcalibre1 pcalibre literal">with</code>
statement is asserted to raise the exception. For example,
suppose you are writing a library that translates Roman numerals into
integers. You might define a function called <code class="pcalibre1 pcalibre literal">roman2int</code>:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; roman2int(<span class="pcalibre1 pcalibre calibre13">"XVI"</span>)
16
&gt;&gt;&gt; roman2int(<span class="pcalibre1 pcalibre calibre13">"II"</span>)
2</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">In thinking about the best way to design this function, you decide
that passing nonsensical input to <code class="pcalibre1 pcalibre literal">roman2int</code> should raise a
<code class="pcalibre1 pcalibre literal">ValueError</code>. Here’s how you write a test to assert that behavior:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11">import unittest
from roman import roman2int

class TestRoman(unittest.TestCase):
    def test_roman2int_error(self):
        with self.assertRaises(ValueError):
            roman2int("This is not a valid roman numeral.")</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">If you run this test, and <code class="pcalibre1 pcalibre literal">roman2int</code> does NOT raise the error, this
is the result:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11">$ python3 -m unittest test_roman2int.py
F
========================================================
FAIL: test_roman2int_error (test_roman2int.TestRoman)
--------------------------------------------------------
Traceback (most recent call last):
  File "/src/test_roman2int.py", line 7, in test_roman2int_error
    roman2int("This is not a valid roman numeral.")
AssertionError: ValueError not raised

--------------------------------------------------------
Ran 1 test in 0.000s

FAILED (failures=1)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">When you fix the bug, and <code class="pcalibre1 pcalibre literal">roman2int</code> raises <code class="pcalibre1 pcalibre literal">ValueError</code> like it
should, the test passes.</p>
</section>
<section class="calibre2 pcalibre1 pcalibre" title="Using Subtests">
<h2 id="calibre_link-108" class="pcalibre1 pcalibre calibre1">Using Subtests</h2>
<p class="pcalibre1 pcalibre calibre7">
Python 3 has a new feature called subtests, allowing you to
conveniently iterate through a collection of test inputs. Imagine a
function called <code class="pcalibre1 pcalibre literal">numwords</code>, which counts the number of unique words in
a string (ignoring punctuation, spelling and spaces):</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; numwords(<span class="pcalibre1 pcalibre calibre13">"Good, good morning. Beautiful morning!"</span>)
3</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Suppose you want to test how <code class="pcalibre1 pcalibre literal">numwords</code> handles excess whitespace. You
can easily imagine a dozen different reasonable inputs that will
result in the same return value, and want to verify it can handle them
all. You might create something like this:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">class</span> <span class="pcalibre1 pcalibre calibre18">TestWords</span>(unittest.TestCase):
    <span class="pcalibre1 pcalibre calibre18">def</span> test_whitespace(self):
        self.assertEqual(2, numwords(<span class="pcalibre1 pcalibre calibre13">"foo bar"</span>))
        self.assertEqual(2, numwords(<span class="pcalibre1 pcalibre calibre13">"    foo bar"</span>))
        self.assertEqual(2, numwords(<span class="pcalibre1 pcalibre calibre13">"foo</span><span class="pcalibre1 pcalibre calibre20">\t</span><span class="pcalibre1 pcalibre calibre13">bar"</span>))
        self.assertEqual(2, numwords(<span class="pcalibre1 pcalibre calibre13">"foo   bar"</span>))
        self.assertEqual(2, numwords(<span class="pcalibre1 pcalibre calibre13">"foo bar    </span><span class="pcalibre1 pcalibre calibre20">\t</span><span class="pcalibre1 pcalibre calibre13">   </span><span class="pcalibre1 pcalibre calibre20">\t</span><span class="pcalibre1 pcalibre calibre13">"</span>))
        <span class="pcalibre1 pcalibre calibre13"># And so on, and so on...</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Seems a bit repetitive, doesn’t it? The only thing varying is the
argument to <code class="pcalibre1 pcalibre literal">numwords</code>. We might benefit from using a for loop:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>    <span class="pcalibre1 pcalibre calibre18">def</span> test_whitespace_forloop(self):
        texts = [
            <span class="pcalibre1 pcalibre calibre13">"foo bar"</span>,
            <span class="pcalibre1 pcalibre calibre13">"    foo bar"</span>,
            <span class="pcalibre1 pcalibre calibre13">"foo</span><span class="pcalibre1 pcalibre calibre20">\t</span><span class="pcalibre1 pcalibre calibre13">bar"</span>,
            <span class="pcalibre1 pcalibre calibre13">"foo   bar"</span>,
            <span class="pcalibre1 pcalibre calibre13">"foo bar    </span><span class="pcalibre1 pcalibre calibre20">\t</span><span class="pcalibre1 pcalibre calibre13">   </span><span class="pcalibre1 pcalibre calibre20">\t</span><span class="pcalibre1 pcalibre calibre13">"</span>,
            ]
        <span class="pcalibre1 pcalibre calibre18">for</span> text <span class="pcalibre1 pcalibre calibre18">in</span> texts:
            self.assertEqual(2, numwords(text))</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">At first glance, this is certainly more maintainable. If we add new
variants, it’s just another line in the <code class="pcalibre1 pcalibre literal">texts</code> list. And if I rename
<code class="pcalibre1 pcalibre literal">numwords</code>, I only need to change it in one place in the test.</p>
<p class="pcalibre1 pcalibre calibre7">However, using a for loop like this creates more problems than it
solves. Suppose you run this test, and get the following failure:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11">$ python3 -m unittest test_words_forloop.py
F
========================================================
FAIL: test_whitespace_forloop (test_words_forloop.TestWords)
--------------------------------------------------------
Traceback (most recent call last):
  File "/src/test_words_forloop.py", line 17, in test_whitespace_forloop
    self.assertEqual(2, numwords(text))
AssertionError: 2 != 3

--------------------------------------------------------
Ran 1 test in 0.000s

FAILED (failures=1)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Look closely, and you’ll realize that <code class="pcalibre1 pcalibre literal">numwords</code> returned 3 when it
was supposed to return 2.  Pop quiz: out of all the inputs in the
list, which caused the bad return value?</p>
<p class="pcalibre1 pcalibre calibre7">The way we’ve written the test, there is no way to know. All you can
infer is that at least one of the test inputs produced an incorrect
value. You don’t know which one. That’s the first problem. The second
is that the test stops when the first failure happens. If several test
inputs are causing errors, it would be helpful to know that right
away. (Of course, the original version has this shortcoming too.)
Knowing all the failing inputs, and the incorrect results they create,
would be <em class="pcalibre1 calibre8 pcalibre">very</em> helpful for quickly understanding what’s going on.</p>
<p class="pcalibre1 pcalibre calibre7">Python 3.4 introduced a new feature, called <em class="pcalibre1 calibre8 pcalibre">subtests</em>, that gives you
the best of all worlds.  Our for-loop solution is actually quite
close. All we have to do is add one line - can you spot it below?</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>    <span class="pcalibre1 pcalibre calibre18">def</span> test_whitespace_subtest(self):
        texts = [
            <span class="pcalibre1 pcalibre calibre13">"foo bar"</span>,
            <span class="pcalibre1 pcalibre calibre13">"    foo bar"</span>,
            <span class="pcalibre1 pcalibre calibre13">"foo</span><span class="pcalibre1 pcalibre calibre20">\t</span><span class="pcalibre1 pcalibre calibre13">bar"</span>,
            <span class="pcalibre1 pcalibre calibre13">"foo   bar"</span>,
            <span class="pcalibre1 pcalibre calibre13">"foo bar    </span><span class="pcalibre1 pcalibre calibre20">\t</span><span class="pcalibre1 pcalibre calibre13">   </span><span class="pcalibre1 pcalibre calibre20">\t</span><span class="pcalibre1 pcalibre calibre13">"</span>,
            ]
        <span class="pcalibre1 pcalibre calibre18">for</span> text <span class="pcalibre1 pcalibre calibre18">in</span> texts:
            <span class="pcalibre1 pcalibre calibre18">with</span> self.subTest(text=text):
                self.assertEqual(2, numwords(text))</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Just inside the for loop, we write <code class="pcalibre1 pcalibre literal">with
self.subTest(text=text)</code>. This creates a context in which assertions
can be made, and even fail. Regardless of whether they pass or not,
the test continues with the next iteration of the for loop. At the end, <em class="pcalibre1 calibre8 pcalibre">all</em>
failures are collected and reported in the test result output, like
this:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11">$ python3 -m unittest test_words_subtest.py

========================================================
FAIL: test_whitespace_subtest (test_words_subtest.TestWords) (text='foo\tbar')
--------------------------------------------------------
Traceback (most recent call last):
  File "/src/test_words_subtest.py", line 16, in test_whitespace_subtest
    self.assertEqual(2, numwords(text))
AssertionError: 2 != 3

========================================================
FAIL: test_whitespace_subtest (test_words_subtest.TestWords) (text='foo bar    \t   \t')
--------------------------------------------------------
Traceback (most recent call last):
  File "/src/test_words_subtest.py", line 16, in test_whitespace_subtest
    self.assertEqual(2, numwords(text))
AssertionError: 2 != 4

--------------------------------------------------------
Ran 1 test in 0.000s

FAILED (failures=2)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Behold the opulence of information in this output:</p>
<div class="pcalibre1 pcalibre itemized-list">
<ul class="pcalibre1 calibre14 pcalibre">
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">Each individual failing input has its own detailed summary.</span>
</li>
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">We are told what the full value of <code class="pcalibre1 pcalibre literal">text</code> was.</span>
</li>
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">We are told what the actual returned value was, clearly compared to
the expected value.</span>
</li>
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">No values are skipped. We can be confident that these two
are the <em class="pcalibre1 calibre8 pcalibre">only</em> failures.</span>
</li>
</ul>
</div>
<p class="pcalibre1 pcalibre calibre7">This is MUCH better. The two offending inputs are <code class="pcalibre1 pcalibre literal">"foo\tbar"</code> and
<code class="pcalibre1 pcalibre literal">"foo bar    \t   \t"</code>.
These are the only values containing tab characters, so
you can quickly realize the nature of the bug: tab characters are
being counted as separate words.</p>
<p class="pcalibre1 pcalibre calibre7">Let’s look at the three key lines of code again:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>        <span class="pcalibre1 pcalibre calibre18">for</span> text <span class="pcalibre1 pcalibre calibre18">in</span> texts:
            <span class="pcalibre1 pcalibre calibre18">with</span> self.subTest(text=text):
                self.assertEqual(2, numwords(text))</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">The key-value arguments to <code class="pcalibre1 pcalibre literal">self.subTest</code> are used in reporting the
output. They can be anything that helps you understand exactly what is
wrong when a test fails. Often you will want to pass everything
that varies from the test cases; here, that’s only the string passed
to <code class="pcalibre1 pcalibre literal">numwords</code>.</p>
<p class="pcalibre1 pcalibre calibre7">Be clear that in these three lines, the symbol <code class="pcalibre1 pcalibre literal">text</code> is used for two
different things. The <code class="pcalibre1 pcalibre literal">text</code> variable in the for loop is the same
variable that is passed to <code class="pcalibre1 pcalibre literal">numwords</code> on the last line. In the call to
<code class="pcalibre1 pcalibre literal">subTest</code>, the left-hand side of <code class="pcalibre1 pcalibre literal">text=text</code> is actually a parameter
that is used in the reporting output if the test fails. For example,
suppose we wrote it as <code class="pcalibre1 pcalibre literal">input_text</code> instead:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>        <span class="pcalibre1 pcalibre calibre18">for</span> text <span class="pcalibre1 pcalibre calibre18">in</span> texts:
            <span class="pcalibre1 pcalibre calibre18">with</span> self.subTest(input_text=text):
                self.assertEqual(2, numwords(text))</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Then the failure output might look like:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11">FAIL: test_whitespace_subtest (test_words_subtest.TestWords) (input_text='foo\tbar')</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">In other words, the l-value <code class="pcalibre1 pcalibre literal">text</code> in the <code class="pcalibre1 pcalibre literal">assertEqual</code> line has
nothing to do with the argument to <code class="pcalibre1 pcalibre literal">subTest</code>. Just remember that the
arguments to <code class="pcalibre1 pcalibre literal">subTest</code> are only used in the error output when
something goes wrong, and are otherwise ignored completely.</p>
</section>
<section class="calibre2 pcalibre1 pcalibre" title="Final Thoughts">
<h2 id="calibre_link-109" class="pcalibre1 pcalibre calibre1">Final Thoughts</h2>
<p class="pcalibre1 pcalibre calibre7">
Let’s recap the big ideas. Test-driven development means we create
the test first, and whatever stubs we need to make the test run. We
then run it, and watch it fail. <strong class="pcalibre1 pcalibre calibre9">This is an important step.</strong> You
must run the test and see it fail.</p>
<p class="pcalibre1 pcalibre calibre7">This is important for two reasons. You don’t really know if the test
is correct until you verify that it <strong class="pcalibre1 pcalibre calibre9">can</strong> fail. As you write automated
tests more and more over time, you will probably be surprised at how
often you write a test, confident in its correctness, only to discover
it passes when it should fail. As far as I can tell, every good,
experienced software engineer I know still commonly experiences
this…​ even after doing TDD for many years! This is why we build the
habit of always verifying the test fails first.</p>
<p class="pcalibre1 pcalibre calibre7">The second reason is more subtle. As you gain experience with TDD and
become comfortable with it, you will find the cycle of writing
tests and making them pass lets you get into a state of flow. This
means you are enjoyably productive and focused, in a way that is easy
to maintain over time.</p>
<p class="pcalibre1 pcalibre calibre7">Is it important that you strictly follow test-driven development?
People have different opinions on this, some of them <em class="pcalibre1 calibre8 pcalibre">very</em>
strong. Personally, I went through a period of almost a year where I
followed TDD to the letter, very strictly. As a result, I got <em class="pcalibre1 calibre8 pcalibre">very</em>
good at writing tests, and writing high-quality tests very quickly.</p>
<p class="pcalibre1 pcalibre calibre7">Now that I’ve developed that level of skill, I prefer instead to
follow the 80-20 rule, and sometimes the 70-30 or even 50-50 rule. I
have noticed that TDD is most powerful when I have great clarity on the
software’s design, architecture and APIs; it helps me get into an
cognitive state that seems accelerated, so that I can more easily
maintain my mental focus, and produce quality code faster.</p>
<p class="pcalibre1 pcalibre calibre7">But I find it very hard to write good tests when I don’t yet have that
clarity…​ when I am still thinking through how I will structure the
program and organize the code. In fact, I find TDD slows me down in
that phase, as any test I write will probably have to be completely
rewritten several times, if not deleted, before things stabilize. In
these situations, I prefer to get a first version of the code working
through manual testing, then write the tests afterwards.</p>
<p class="pcalibre1 calibre7 pcalibre7">To close with the obvious: Experiment to find what approach works best
for you, and not just follow what someone else writes that you
"should" do. I encourage you to try TDD for a period of time, because
of what it will teach you. But be flexible, and at some point step
back and evaluate how you want to integrate it into your daily
routine.</p>
</section>
<footer class="pcalibre1 pcalibre calibre15">
<div class="calibre16 pcalibre1 pcalibre"></div><div class="pcalibre1 pcalibre chapter-footer">
<div class="pcalibre1 pcalibre footnotes">
<aside id="calibre_link-47" type="footnote" class="calibre2 pcalibre1 pcalibre">
<p class="pcalibre1 calibre17 pcalibre"><sup class="noteref1 pcalibre1 pcalibre"><a href="#calibre_link-54" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">1</a></sup> <a class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4" href="https://docs.python.org/3/library/unittest.html">https://docs.python.org/3/library/unittest.html</a></p>
</aside>
<aside id="calibre_link-48" type="footnote" class="calibre2 pcalibre1 pcalibre">
<p class="pcalibre1 calibre17 pcalibre"><sup class="noteref1 pcalibre1 pcalibre"><a href="#calibre_link-55" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">2</a></sup> You may be in a third category, having a lot of experience with a non-xUnit testing framework. If so, you should probably pretend you’re in the first group. You’ll be able to move quickly.</p>
</aside>
<aside id="calibre_link-49" type="footnote" class="calibre2 pcalibre1 pcalibre">
<p class="pcalibre1 calibre17 pcalibre"><sup class="noteref1 pcalibre1 pcalibre"><a href="#calibre_link-56" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">3</a></sup> If you haven’t done one of these yet, you will.</p>
</aside>
<aside id="calibre_link-50" type="footnote" class="calibre2 pcalibre1 pcalibre">
<p class="pcalibre1 calibre17 pcalibre"><sup class="noteref1 pcalibre1 pcalibre"><a href="#calibre_link-57" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">4</a></sup> The object-oriented chapter talks about "magic methods" like <code class="pcalibre1 pcalibre literal">__add__</code>, which provide a more natural syntax for math-like operations on custom types. This chapter just uses regular methods, in case you haven’t read that chapter yet.</p>
</aside>
<aside id="calibre_link-51" type="footnote" class="calibre2 pcalibre1 pcalibre">
<p class="pcalibre1 calibre17 pcalibre"><sup class="noteref1 pcalibre1 pcalibre"><a href="#calibre_link-58" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">5</a></sup> Python 2 requires you to drop the test file’s <code class="pcalibre1 pcalibre literal">.py</code> extension - in other words, passing the test module name. So you invoke it like <code class="pcalibre1 pcalibre literal">python2.7 -m unittest test_angles</code>. Python 3 lets you do either; we’ll always use the test filename in this chapter, but you can use whichever you prefer.</p>
</aside>
<aside id="calibre_link-52" type="footnote" class="calibre2 pcalibre1 pcalibre">
<p class="pcalibre1 calibre17 pcalibre"><sup class="noteref1 pcalibre1 pcalibre"><a href="#calibre_link-59" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">6</a></sup> If you find yourself wanting to run tests in a certain order, this might be better handled with <code class="pcalibre1 pcalibre literal">setUp</code> and <code class="pcalibre1 pcalibre literal">tearDown</code>, explained in the next section.</p>
</aside>
<aside id="calibre_link-53" type="footnote" class="calibre2 pcalibre1 pcalibre">
<p class="pcalibre1 calibre17 pcalibre"><sup class="noteref1 pcalibre1 pcalibre"><a href="#calibre_link-60" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">7</a></sup> Which could be you, months or years down the road. Be considerate of your future self!</p>
</aside>
</div>
</div>
</footer>
</section>
</div>


<div id="calibre_link-1" class="pcalibre1 pcalibre calibre">
<section class="calibre2 pcalibre1 pcalibre" id="calibre_link-191" title="String Formatting" type="chapter">
<header id="calibre_link-110" class="calibre2 pcalibre1 pcalibre">
<div class="pcalibre1 pcalibre chapter-header">
<h1 class="pcalibre1 chapter-title pcalibre"> <small class="subtitle pcalibre1 pcalibre"><b class="pcalibre1 pcalibre calibre6">STRING</b> <b class="pcalibre1 pcalibre calibre6">FORMATTING</b></small></h1>
</div>
</header>
<p class="pcalibre1 pcalibre calibre7">The situation with string formatting is complicated.</p>
<p class="pcalibre1 pcalibre calibre7">


Once upon a time, Python introduced <em class="pcalibre1 calibre8 pcalibre">percent formatting</em>. It uses <code class="pcalibre1 pcalibre literal">"%"</code>
as a binary operator to render strings:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; drink = <span class="pcalibre1 pcalibre calibre13">"coffee"</span>
&gt;&gt;&gt; price = 2.5
&gt;&gt;&gt; message = <span class="pcalibre1 pcalibre calibre13">"This </span><span class="pcalibre1 pcalibre calibre20">%s</span><span class="pcalibre1 pcalibre calibre13"> costs $</span><span class="pcalibre1 pcalibre calibre20">%.2f</span><span class="pcalibre1 pcalibre calibre13">."</span> % (drink, price)
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre18">print</span>(message)
This coffee costs <span class="pcalibre1 pcalibre calibre19">$</span>2.50.</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">
Later in Python 2’s history, a different style was introduced, called
simply <em class="pcalibre1 calibre8 pcalibre">string formatting</em> (yes, that’s the official name). Its very
different syntax makes any Python string a potential template,
inserting values through the <code class="pcalibre1 pcalibre literal">str.format()</code> method.</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">&gt;&gt;&gt; </span>template = <span class="pcalibre1 pcalibre calibre13">"This {} costs ${:.2f}."</span>
<span class="pcalibre1 pcalibre calibre18">&gt;&gt;&gt; print</span>(template.format(drink, price))
This coffee costs $2.50.</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">
Python 3.6 introduces a third option, called <em class="pcalibre1 calibre8 pcalibre">f-strings</em>. This lets
you write literal strings, prefixed with an "f" character,
interpolating values from the immediate context:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">&gt;&gt;&gt; </span>message = f<span class="pcalibre1 pcalibre calibre13">"This {drink} costs ${price:.02f}."</span>
<span class="pcalibre1 pcalibre calibre18">&gt;&gt;&gt; print</span>(message)
This coffee costs $2.50.</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">So…​ which do you use? Here’s my guidance in a nutshell:</p>
<div class="pcalibre1 pcalibre itemized-list">
<ul class="pcalibre1 calibre14 pcalibre">
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">Go ahead and master <code class="pcalibre1 pcalibre literal">str.format()</code> now. Everything you learn
transfers entirely to f-strings, and you’ll sometimes want to use
<code class="pcalibre1 pcalibre literal">str.format()</code> even in cutting-edge versions of Python.</span>
</li>
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">Prefer f-strings when working in a codebase that supports it -
meaning, all developers and end-users of the code base are certain
to have Python 3.6 or later.</span>
</li>
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">Until then, prefer <code class="pcalibre1 pcalibre literal">str.format()</code>.</span>
</li>
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">Exception: for the <code class="pcalibre1 pcalibre literal">logging</code> module, use percent-formatting, even
if you’re otherwise using f-strings.

</span>
</li>
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">Aside from <code class="pcalibre1 pcalibre literal">logging</code>, don’t use percent-formatting unless legacy
reasons force you to.</span>
</li>
</ul>
</div>
<p class="pcalibre1 pcalibre calibre7">"Which should I use?" is a separate question from "which should a
Python book use for its code examples?" As you’ve noticed, I am using
<code class="pcalibre1 pcalibre literal">str.format()</code> throughout this book. That’s because all modern Python
versions support it, so I know everyone reading this book can use it.</p>
<p class="pcalibre1 pcalibre calibre7">Someday, when Python versions before 3.6 are a distant memory, there
will be no reason not to use f-strings. But when that happens,
<code class="pcalibre1 pcalibre literal">str.format()</code> will still be important. There are string formatting
situations where f-strings are awkward at best, and <code class="pcalibre1 pcalibre literal">str.format()</code> is
well suited. In the meantime, there is a lot of Python code out there
using <code class="pcalibre1 pcalibre literal">str.format()</code>, which you’ll need to be able to read and
understand. Hence, I’m choosing to focus on <code class="pcalibre1 pcalibre literal">str.format()</code> in this
chapter. Conveniently, this also teaches you much about f-strings;
they are more similar than different, because the formatting codes are
nearly identical. <code class="pcalibre1 pcalibre literal">str.format()</code> is also the only practical choice for
most people reading this, and will be for years still.</p>
<p class="pcalibre1 pcalibre calibre7">
 You might wonder if
the old percent-formatting has any place in modern Python. In fact, it
does, due to the <code class="pcalibre1 pcalibre literal">logging</code> module. As you’ll read in its chapter, this
important module is built on percent-formatting in a deep way. It’s
possible to use <code class="pcalibre1 pcalibre literal">str.format()</code> in new logging code, but requires
special steps; and legacy logging code cannot be safely converted in
an automated way. I recommend you just cooperate with the situation,
and use percent-formatting for your log messages.</p>
<p class="pcalibre1 pcalibre calibre7">For those interested, this chapter ends with sections briefly
explaining f-strings and percent-formatting. For now, we’ll focus on
<code class="pcalibre1 pcalibre literal">str.format()</code>. While reading, I highly recommend you have a Python
interpreter prompt open, typing in the examples as you go along.  The
goal is to make its expressive power automatic and easy for you to
use, so that it’s <em class="pcalibre1 calibre8 pcalibre">mentally</em> available to you…​ giving you the easy
ability to use it in the future, without digging into the reference
docs. Most people never master it to this threshold, effectively
denying them most of the benefits of this rich tool. You won’t have
that problem.</p>
<section class="calibre2 pcalibre1 pcalibre" title="Replacing Fields">
<h2 id="calibre_link-111" class="pcalibre1 pcalibre calibre1">Replacing Fields</h2>
<p class="pcalibre1 pcalibre calibre7">
<code class="pcalibre1 pcalibre literal">str.format()</code> lets you start simple, leveraging more complex
extensions as needed. You start by creating a format string. This is
just a regular string, and acts as a kind of template. It contains,
among other text, one or more <em class="pcalibre1 calibre8 pcalibre">replacement fields</em>. These are simply
pairs of opening and closing curly braces: <code class="pcalibre1 pcalibre literal">"Good {}, my friend"</code>. You
then invoke the <code class="pcalibre1 pcalibre literal">format</code> method on that string, passing in one
argument for each replacement field:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13">"Good {}, my friend"</span>.format(<span class="pcalibre1 pcalibre calibre13">"morning"</span>)
<span class="pcalibre1 pcalibre calibre13">'Good morning, my friend'</span>
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13">"Good {}, my friend"</span>.format(<span class="pcalibre1 pcalibre calibre13">"afternoon"</span>)
<span class="pcalibre1 pcalibre calibre13">'Good afternoon, my friend'</span>
&gt;&gt;&gt; offer = <span class="pcalibre1 pcalibre calibre13">"Give me {} dollars and I'll give you a {}."</span>
&gt;&gt;&gt; offer.format(2, <span class="pcalibre1 pcalibre calibre13">"cheeseburger"</span>)
<span class="pcalibre1 pcalibre calibre13">"Give me 2 dollars and I'll give you a cheeseburger."</span>
&gt;&gt;&gt; offer.format(7, <span class="pcalibre1 pcalibre calibre13">"nice shoulder rub"</span>)
<span class="pcalibre1 pcalibre calibre13">"Give me 7 dollars and I'll give you a nice shoulder rub."</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">(If possible, type these examples in an interpreter as you
go along, so you learn them deeply.)  <code class="pcalibre1 pcalibre literal">.format()</code> is a method
returning a new string; the format string itself is not modified.</p>
<p class="pcalibre1 pcalibre calibre7">Notice how fields line up by position, and no type information is
needed. The integer 2 and the string "cheeseburger" are both inserted
without complaint. We’ll see how to specify more precise types for the
fields later.</p>
<p class="pcalibre1 pcalibre calibre7">Within the curly braces of the replacement field, you can specify
numbers starting at 0. These reference the positions of the arguments
passed to <code class="pcalibre1 pcalibre literal">format</code>, and allow you to repeat fields:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13">"{0} is {1}; {1}, {0}"</span>.format(<span class="pcalibre1 pcalibre calibre13">"truth"</span>, <span class="pcalibre1 pcalibre calibre13">"beauty"</span>)
<span class="pcalibre1 pcalibre calibre13">'truth is beauty; beauty, truth'</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">You can also reference fields by a name, and pass the fields as
key-value pairs to <code class="pcalibre1 pcalibre literal">format</code>:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13">"Good {when}, {user}!"</span>.format(
         when=<span class="pcalibre1 pcalibre calibre13">"morning"</span>, user=<span class="pcalibre1 pcalibre calibre13">"John"</span>)
<span class="pcalibre1 pcalibre calibre13">'Good morning, John!'</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">The arguments to <code class="pcalibre1 pcalibre literal">format()</code> don’t actually have to be strings: they
can be objects or lists. Reference within them as you normally
would, within the curly braces:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre18">class</span> <span class="pcalibre1 pcalibre calibre18">Point</span>:
...     <span class="pcalibre1 pcalibre calibre18">def</span> __init__(self, x, y):
...         self.x = x
...         self.y = y
...
&gt;&gt;&gt; point = Point(3, 7)
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13">'The coordinates are {point.x}, {point.y}'</span>.format(
        point=point)
<span class="pcalibre1 pcalibre calibre13">'The coordinates are 3, 7'</span>
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13">'The coordinates are {0.x}, {0.y}'</span>.format(point)
<span class="pcalibre1 pcalibre calibre13">'The coordinates are 3, 7'</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Notice the difference in how you use the point with a named field (the
first format call), versus a numbered field (the second). Here’s how
it looks with a list:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; params = [<span class="pcalibre1 pcalibre calibre13">"morning"</span>, <span class="pcalibre1 pcalibre calibre13">"user"</span>]
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13">"Good {params[0]}, {params[1]}!"</span>.format(params=params)
<span class="pcalibre1 pcalibre calibre13">'Good morning, user!'</span>
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13">"Good {0[0]}, {0[1]}!"</span>.format(params)
<span class="pcalibre1 pcalibre calibre13">'Good morning, user!'</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">You can do the same thing with dictionaries too, though there is one
subtle quirk - can you spot it?</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; params = {<span class="pcalibre1 pcalibre calibre13">"when"</span>: <span class="pcalibre1 pcalibre calibre13">"morning"</span>, <span class="pcalibre1 pcalibre calibre13">"user"</span>:<span class="pcalibre1 pcalibre calibre13">"John"</span>}
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13">"Good {0[when]}, {0[user]}!"</span>.format(params)
<span class="pcalibre1 pcalibre calibre13">'Good morning, John!'</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">See it? The key <code class="pcalibre1 pcalibre literal">when</code> in <code class="pcalibre1 pcalibre literal">{0[when]}</code> does not have quotation marks
around it! In fact, if you do put them in, you get an error. This
quirk was intentionally put in, to make it easier to reference keys
within a string that is bounded by quotes already.</p>
</section>
<section class="calibre2 pcalibre1 pcalibre" title="Number Formats (and &quot;Format Specs&quot;)">
<h2 id="calibre_link-112" class="pcalibre1 pcalibre calibre1">Number Formats (and "Format Specs")</h2>
<p class="pcalibre1 pcalibre calibre7">

Now that you know how to substitute values into different replacement
fields (i.e., pairs of curly braces), you may next want to format a
field as a number. Do this by inserting a colon between the curly
braces, followed by one or more descriptive characters. For example,
use ":d" to format as an integer, and ":f" to format as a
floating-point number.  Here’s how it works:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13">'The magic number is {:d}'</span>.format(42)
<span class="pcalibre1 pcalibre calibre13">'The magic number is 42'</span>
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13">'The magic number is actually {:f}'</span>.format(42)
<span class="pcalibre1 pcalibre calibre13">'The magic number is actually 42.000000'</span>
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13">'But this will cause an error: {:d}'</span>.format(<span class="pcalibre1 pcalibre calibre13">"foo"</span>)
Traceback (most recent call last):
  File <span class="pcalibre1 pcalibre calibre13">"&lt;stdin&gt;"</span>, line 1, <span class="pcalibre1 pcalibre calibre18">in</span> &lt;module&gt;
<span class="pcalibre1 pcalibre calibre18">ValueError</span>: Unknown format code <span class="pcalibre1 pcalibre calibre13">'d'</span> <span class="pcalibre1 pcalibre calibre18">for</span> object of type <span class="pcalibre1 pcalibre calibre13">'str'</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">The number 42 is rendered as either <code class="pcalibre1 pcalibre literal">42</code> or <code class="pcalibre1 pcalibre literal">42.000000</code>, depending on
whether the replacement field is <code class="pcalibre1 pcalibre literal">{:d}</code> or <code class="pcalibre1 pcalibre literal">{:f}</code>. And when we try to
stuff something that isn’t a number in <code class="pcalibre1 pcalibre literal">{:d}</code>, it triggers a fatal
error.</p>
<p class="pcalibre1 pcalibre calibre7">You can combine this with field numbering and naming. Just put that
label before the colon:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13">"The time is {hour:d} o' clock."</span>.format(hour=11)
<span class="pcalibre1 pcalibre calibre13">"The time is 11 o' clock."</span>
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13">"The answer is {0:f}, not {1:f}. But you can round it to {0:d}."</span>.format(12, 14)
<span class="pcalibre1 pcalibre calibre13">'The answer is 12.000000, not 14.000000. But you can round it to 12.'</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">The rule is easy: if you label a field - whether it’s a string name,
or a number - always put that label first within the curly brackets.</p>
<p class="pcalibre1 pcalibre calibre7">The part after after the colon is called a <em class="pcalibre1 calibre8 pcalibre">format spec</em>. There’s
actually many options you can stuff in there, but let’s focus on those
related to formatting numbers first. As you saw, the code for an
integer is <code class="pcalibre1 pcalibre literal">d</code>, converting the argument to an integer, if possible.
If not, it throws a <code class="pcalibre1 pcalibre literal">ValueError</code>. (By the way, "d" stands for "decimal
number", as in a base-ten number.)</p>
<p class="pcalibre1 pcalibre calibre7">Then there’s floating point numbers. With the <code class="pcalibre1 pcalibre literal">f</code> code, we get six
decimal places of precision by default - which are filled with zeros
if necessary:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre18">from</span> <span class="pcalibre1 pcalibre calibre18">math</span> <span class="pcalibre1 pcalibre calibre18">import</span> pi
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13">'The ratio is about {:f}'</span>.format(pi)
<span class="pcalibre1 pcalibre calibre13">'The ratio is about 3.141593'</span>
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13">'{:f} is NOT a good approximation.'</span>.format(3)
<span class="pcalibre1 pcalibre calibre13">'3.000000 is NOT a good approximation.'</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">"f" actually stands for "fixed-point number", not "floating point" -
we’ll see some variations later. We can change the number of fixed
points: writing a period followed by a number means to use that
many decimal places. We put it between the colon and the letter "f",
like so:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13">'The ratio is about {:.3f}'</span>.format(pi)
<span class="pcalibre1 pcalibre calibre13">'The ratio is about 3.142'</span>
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13">'{:.1f} is NOT a good approximation.'</span>.format(3)
<span class="pcalibre1 pcalibre calibre13">'3.0 is NOT a good approximation.'</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">It’s easier for humans to read numbers with many digits if they have
commas. You can tell the formatter to do this by putting a comma after
the colon:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13">"Billions and {:,d}'s"</span>.format(10**9)
<span class="pcalibre1 pcalibre calibre13">"Billions and 1,000,000,000's"</span>
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13">"It works with floating point too: {:,f}"</span>.format(10**9)
<span class="pcalibre1 pcalibre calibre13">'It works with floating point too: 1,000,000,000.000000'</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">For large numbers, sometimes we want scientific notation, also called
exponent notation. We can use the code "E" for that instead:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13">"Billions and {:E}'s"</span>.format(10**9)
<span class="pcalibre1 pcalibre calibre13">"Billions and 1.000000E+09's"</span>
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13">"Precision works the same: {:.2E}"</span>.format(10**9)
<span class="pcalibre1 pcalibre calibre13">'Precision works the same: 1.00E+09'</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">So far, we have seen codes for three presentation types: d (decimal)
for integers; and f (fixed-point) and E (exponential) for
floating-point numbers. We actually have many other choices for both:
read the format-specification mini-language
section​<sup class="pcalibre1 pcalibre noteref">[<a href="#calibre_link-2" id="calibre_link-4" type="noteref" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">1</a>]</sup>
in the Python docs.</p>
</section>
<section class="calibre2 pcalibre1 pcalibre" title="Width, Alignment, and Fill">
<h2 id="calibre_link-113" class="pcalibre1 pcalibre calibre1">Width, Alignment, and Fill</h2>
<p class="pcalibre1 pcalibre calibre7">
In the examples above, the substituted values will take only as much
space as they need, but no more. So <code class="pcalibre1 pcalibre literal">"a{}b".format(n)</code> will render
as <code class="pcalibre1 pcalibre literal">a7b</code> if n is 7 - but not <code class="pcalibre1 pcalibre literal">a07b</code>, for example. But if n is 77, it
will expand to take up four characters instead of three: <code class="pcalibre1 pcalibre literal">a77b</code>.</p>
<p class="pcalibre1 pcalibre calibre7">We can change this default behavior, placing the value in a field of a
certain number of characters. If it’s small enough to fit in there
(i.e. not too many digits or chars), then it will be
right-justified. We specify the width by putting the number of
characters between the colon and the type code:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13">"foo{:7d}bar"</span>.format(753)
<span class="pcalibre1 pcalibre calibre13">'foo    753bar'</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Let’s count the character columns here:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11">foo    753bar
0123456789012</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Positions 3 through 9 are taken up by the replacement field
value. That value only has three characters (753), so the others are
<em class="pcalibre1 calibre8 pcalibre">filled</em> by the space character. We say that the space is the <em class="pcalibre1 calibre8 pcalibre">fill</em>
character here.</p>
<p class="pcalibre1 pcalibre calibre7">By default, the value is right-justified in the field for numbers. But
for strings, it’s left justified:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13">"foo{:7s}bar"</span>.format(<span class="pcalibre1 pcalibre calibre13">"blah"</span>)
<span class="pcalibre1 pcalibre calibre13">'fooblah   bar'</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Generally speaking, it will default to right-justifying for any kind
of number, and left-justify for everything else. We can override the
default, or even just be explicit about what we want, by inserting an
<em class="pcalibre1 calibre8 pcalibre">alignment</em> right before the field width. For right-justifying, this
is the greater-than sign:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13">"foo{:&gt;7d}bar"</span>.format(753)
<span class="pcalibre1 pcalibre calibre13">'foo    753bar'</span>
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13">"foo{:&gt;7s}bar"</span>.format(<span class="pcalibre1 pcalibre calibre13">"blah"</span>)
<span class="pcalibre1 pcalibre calibre13">'foo   blahbar'</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">To left-justify, use a less-than sign:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13">"foo{:&lt;7d}bar"</span>.format(753)
<span class="pcalibre1 pcalibre calibre13">'foo753    bar'</span>
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13">"foo{:&lt;7s}bar"</span>.format(<span class="pcalibre1 pcalibre calibre13">"blah"</span>)
<span class="pcalibre1 pcalibre calibre13">'fooblah   bar'</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Or we can center it, with a caret:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13">"foo{:^7d}bar"</span>.format(753)
<span class="pcalibre1 pcalibre calibre13">'foo  753  bar'</span>
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13">"foo{:^7s}bar"</span>.format(<span class="pcalibre1 pcalibre calibre13">"blah"</span>)
<span class="pcalibre1 pcalibre calibre13">'foo blah  bar'</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">So far, the extra characters in the field have been spaces. That extra
character is called the <em class="pcalibre1 calibre8 pcalibre">fill character</em>, or the <em class="pcalibre1 calibre8 pcalibre">fill</em>. We can
specify a different fill character by placing it just before the
alignment character (&lt;, &gt; or ^):</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13">"foo{:_&gt;7d}bar"</span>.format(753)
<span class="pcalibre1 pcalibre calibre13">'foo____753bar'</span>
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13">"foo{:+&lt;7d}bar"</span>.format(753)
<span class="pcalibre1 pcalibre calibre13">'foo753++++bar'</span>
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13">"foo{:X^7d}bar"</span>.format(753)
<span class="pcalibre1 pcalibre calibre13">'fooXX753XXbar'</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">This is a good time to remember you can combine field names or
indices with these format annotations - just put the name or index to
the left side of the colon:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13">"alpha{x:_&lt;6d}beta{y:+^7d}gamma"</span>.format(x=42, y=17)
<span class="pcalibre1 pcalibre calibre13">'alpha42____beta++17+++gamma'</span>
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13">"{0:_&gt;6d}{1:-^7d}{0:_&lt;6d}"</span>.format(11, 333)
<span class="pcalibre1 pcalibre calibre13">'____11--333--11____'</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Historically, over the long and ongoing lifetime of <code class="pcalibre1 pcalibre literal">printf</code>, it’s
been common to use zero as a fill character for right-justified
integer fields. So if the number 42 is put in a five-character-wide
field, it shows up at "00042". Since people often want to do this, a
shorthand evolved. You can omit the alignment character if the fill is
"0" (zero), and the type is decimal:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13">"foo{:0&gt;7d}bar"</span>.format(753)
<span class="pcalibre1 pcalibre calibre13">'foo0000753bar'</span>
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13">"foo{:07d}bar"</span>.format(753)
<span class="pcalibre1 pcalibre calibre13">'foo0000753bar'</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">That doesn’t generally work for other fill values, though:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13">"foo{:_7d}bar"</span>.format(753)
Traceback (most recent call last):
  File <span class="pcalibre1 pcalibre calibre13">"&lt;stdin&gt;"</span>, line 1, <span class="pcalibre1 pcalibre calibre18">in</span> &lt;module&gt;
<span class="pcalibre1 pcalibre calibre18">ValueError</span>: Invalid format specifier</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">What happens if the value is too big to fit in a tiny field? The
width is actually a <em class="pcalibre1 calibre8 pcalibre">minimum</em> width. So it will expand as needed to
fill it out:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13">"red{:4d}green"</span>.format(123456789)
<span class="pcalibre1 pcalibre calibre13">'red123456789green'</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">There isn’t any way to specify a maximum width. If you need that, you can
convert it to a string, implement your own trimming logic, then
inject that trimmed string:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; value = 123456789 <span class="pcalibre1 pcalibre calibre13"># Or some other number.</span>
&gt;&gt;&gt; trimmed_value = str(value)[:4] <span class="pcalibre1 pcalibre calibre13"># Or last 4, etc.</span>
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13">"red{:&gt;4s}green"</span>.format(trimmed_value)
<span class="pcalibre1 pcalibre calibre13">'red1234green'</span></code></pre>
</figure>
</section>
<section class="calibre2 pcalibre1 pcalibre" title="F-Strings">
<h2 id="calibre_link-114" class="pcalibre1 pcalibre calibre1">F-Strings</h2>
<p class="pcalibre1 pcalibre calibre7">

Python 3.6 introduced an alternative to <code class="pcalibre1 pcalibre literal">str.format()</code>, called
<strong class="pcalibre1 pcalibre calibre9">f-strings</strong>. The formal name is "formatted string literal". Instead of
a <code class="pcalibre1 pcalibre literal">.format()</code> method, you prefix the string with the letters "f" or
"F", putting variable names directly inside the replacement field:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; time_of_day = <span class="pcalibre1 pcalibre calibre13">"afternoon"</span>
&gt;&gt;&gt; f<span class="pcalibre1 pcalibre calibre13">"Good {time_of_day}, my friend"</span>
<span class="pcalibre1 pcalibre calibre13">'Good afternoon, my friend'</span>
&gt;&gt;&gt; F<span class="pcalibre1 pcalibre calibre13">"Good {time_of_day}, my friend"</span>
<span class="pcalibre1 pcalibre calibre13">'Good afternoon, my friend'</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">It’s exactly equivalent to this:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13"># This...</span>
... <span class="pcalibre1 pcalibre calibre13">"Good {time_of_day}, my friend"</span>.format(
...     time_of_day=time_of_day)
<span class="pcalibre1 pcalibre calibre13">'Good afternoon, my friend'</span>
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13"># Or this:</span>
... <span class="pcalibre1 pcalibre calibre13">"Good {}, my friend"</span>.format(time_of_day)
<span class="pcalibre1 pcalibre calibre13">'Good afternoon, my friend'</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">If your values are already stored in locally-readable variables, using
f-strings is more succinct. But you can do more than that. In fact,
the replacement field (i.e. the curly braces) can contain not only a
variable name, but a full Python expression!</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; f<span class="pcalibre1 pcalibre calibre13">"Good {time_of_day.upper()}, my friend"</span>
<span class="pcalibre1 pcalibre calibre13">'Good AFTERNOON, my friend'</span>

&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre18">def</span> reverse(string):
...     <span class="pcalibre1 pcalibre calibre18">return</span> string[::-1]
&gt;&gt;&gt; f<span class="pcalibre1 pcalibre calibre13">"Good {reverse(time_of_day)}, my friend"</span>
<span class="pcalibre1 pcalibre calibre13">'Good noonretfa, my friend'</span>

&gt;&gt;&gt; groceries = [<span class="pcalibre1 pcalibre calibre13">"milk"</span>, <span class="pcalibre1 pcalibre calibre13">"bread"</span>, <span class="pcalibre1 pcalibre calibre13">"broccoli"</span>]
&gt;&gt;&gt; f<span class="pcalibre1 pcalibre calibre13">"I need to get some {groceries[2]}."</span>
<span class="pcalibre1 pcalibre calibre13">'I need to get some broccoli.'</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">You can do this with <code class="pcalibre1 pcalibre literal">str.format()</code>, too, but f-strings express it a
bit more naturally. Aside from that, you can use the normal number
formatting codes. After the expression name, simply write a colon, and
the same code you would use for <code class="pcalibre1 pcalibre literal">str.format()</code>:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre18">from</span> <span class="pcalibre1 pcalibre calibre18">math</span> <span class="pcalibre1 pcalibre calibre18">import</span> pi
&gt;&gt;&gt; f<span class="pcalibre1 pcalibre calibre13">"The ratio is about {pi:f}"</span>
<span class="pcalibre1 pcalibre calibre13">'The ratio is about 3.141593'</span>
&gt;&gt;&gt; f<span class="pcalibre1 pcalibre calibre13">"Which is roughly {pi:0.2f}"</span>
<span class="pcalibre1 pcalibre calibre13">'Which is roughly 3.14'</span>
&gt;&gt;&gt; f<span class="pcalibre1 pcalibre calibre13">"{pi:.0f} is NOT a good approximation."</span>
<span class="pcalibre1 pcalibre calibre13">'3 is NOT a good approximation.'</span>

&gt;&gt;&gt; number = 10**9
&gt;&gt;&gt; f<span class="pcalibre1 pcalibre calibre13">"Billions and {number:,d}'s"</span>
<span class="pcalibre1 pcalibre calibre13">"Billions and 1,000,000,000's"</span>
&gt;&gt;&gt; f<span class="pcalibre1 pcalibre calibre13">"Billions and {number:E}'s"</span>
<span class="pcalibre1 pcalibre calibre13">"Billions and 1.000000E+09's"</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">As well as the width, alignment, and fill:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; num = 753
&gt;&gt;&gt; word = <span class="pcalibre1 pcalibre calibre13">"WOW"</span>
&gt;&gt;&gt; f<span class="pcalibre1 pcalibre calibre13">"foo{num:7d}bar"</span>
<span class="pcalibre1 pcalibre calibre13">'foo    753bar'</span>
&gt;&gt;&gt; f<span class="pcalibre1 pcalibre calibre13">"foo{word:7s}bar"</span>
<span class="pcalibre1 pcalibre calibre13">'fooWOW    bar'</span>
&gt;&gt;&gt; f<span class="pcalibre1 pcalibre calibre13">"foo{word:&gt;7s}bar"</span>
<span class="pcalibre1 pcalibre calibre13">'foo    WOWbar'</span>
&gt;&gt;&gt; f<span class="pcalibre1 pcalibre calibre13">"foo{num:&lt;7d}bar"</span>
<span class="pcalibre1 pcalibre calibre13">'foo753    bar'</span>
&gt;&gt;&gt; f<span class="pcalibre1 pcalibre calibre13">"foo{num:^7d}bar"</span>
<span class="pcalibre1 pcalibre calibre13">'foo  753  bar'</span>
&gt;&gt;&gt; f<span class="pcalibre1 pcalibre calibre13">"foo{num:X^7d}bar"</span>
<span class="pcalibre1 pcalibre calibre13">'fooXX753XXbar'</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Now it’s clear why I emphasize <code class="pcalibre1 pcalibre literal">str.format()</code> in this chapter, and
this book. Practically speaking, all Python programmers need to know
<code class="pcalibre1 pcalibre literal">str.format()</code> anyway; and once you’ve learned it, you are fluent
with f-strings almost immediately.</p>
<p class="pcalibre1 pcalibre calibre7">The main downside to f-strings will become less important over
time. It only works with Python 3.6 and later. That means in order to
use f-strings in your code, you must be working on a codebase which
will only ever be executed on those versions. This applies not only to
your fellow developers, but - more problematically - all end users. If
a customer has installed Python 3.5 on a server, and your program uses
f-strings, they won’t be able to run it unless you can convince them
to upgrade. Which, unfortunately, probably isn’t as high a priority
for them as it is for you.</p>
<p class="pcalibre1 pcalibre calibre7">As I write this, f-strings have been out a short while. But many
Python developers seem to have already fallen in love with them. The
next edition of this book may emphasize them more, depending how
quickly the Python community moves to versions of Python which support
f-strings, and how popular they become. Fortunately, it’s quite easy
to switch back and forth between <code class="pcalibre1 pcalibre literal">str.format()</code> and f-strings; there
seems to be very little mental energy needed to switch. So if you want
to use f-strings, you can do so when it’s practical, and then easily
switch to <code class="pcalibre1 pcalibre literal">str.format()</code> when needed.</p>
</section>
<section class="calibre2 pcalibre1 pcalibre" title="Percent Formatting">
<h2 id="calibre_link-115" class="pcalibre1 pcalibre calibre1">Percent Formatting</h2>
<p class="pcalibre1 pcalibre calibre7">
Modern Python still needs percent formatting in a few places, mainly
when you work with the <code class="pcalibre1 pcalibre literal">logging</code> module. Thankfully, you don’t need to
know all its details. Learning just a few parts of percent formatting
will cover 95% of what you’re likely to need. I’ll focus on that
high-impact portion here; for more detail, consult the official Python
reference.<sup class="pcalibre1 pcalibre noteref">[<a href="#calibre_link-3" id="calibre_link-5" type="noteref" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">2</a>]</sup></p>
<p class="pcalibre1 pcalibre calibre7">
Percent formatting is officially called "printf-style string
formatting", and - like the string formatting in <em class="pcalibre1 calibre8 pcalibre">many</em> languages -
has its roots in C’s <code class="pcalibre1 pcalibre literal">printf()</code>. So if you have experience with that,
you’ll skim through quickly - though there <em class="pcalibre1 calibre8 pcalibre">are</em> a few differences.</p>
<p class="pcalibre1 pcalibre calibre7">It uses the percent character in two ways. Here’s a simple example:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13">"Hello, </span><span class="pcalibre1 pcalibre calibre20">%s</span><span class="pcalibre1 pcalibre calibre13">, today is </span><span class="pcalibre1 pcalibre calibre20">%s</span><span class="pcalibre1 pcalibre calibre13">."</span> % (<span class="pcalibre1 pcalibre calibre13">"Aaron"</span>, <span class="pcalibre1 pcalibre calibre13">"Tuesday"</span>)
<span class="pcalibre1 pcalibre calibre13">'Hello, Aaron, today is Tuesday.'</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Notice percent is used as a binary operator. On its left is
a string; on its right, a tuple of two strings. That string on the
left is called the <em class="pcalibre1 calibre8 pcalibre">format</em>; you can see it has two percent
characters inside. Specifically, it has the sequence <code class="pcalibre1 pcalibre literal">%s</code> twice. These
<code class="pcalibre1 pcalibre literal">%s</code> sequences are called <em class="pcalibre1 calibre8 pcalibre">conversion specifiers</em>. There’s two of
them, and two values in the tuple on the right; they map to each
other. Each value is substituted for its corresponding <code class="pcalibre1 pcalibre literal">%s</code>.</p>
<p class="pcalibre1 pcalibre calibre7">The "s" means that the inserted value is converted to a string; these
are already strings, though, so they are just placed in. You can also
use <code class="pcalibre1 pcalibre literal">%d</code> for an integer:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13">"Here's </span><span class="pcalibre1 pcalibre calibre20">%d</span><span class="pcalibre1 pcalibre calibre13"> dollars and </span><span class="pcalibre1 pcalibre calibre20">%d</span><span class="pcalibre1 pcalibre calibre13"> cents."</span> % (14, 25)
<span class="pcalibre1 pcalibre calibre13">"Here's 14 dollars and 25 cents."</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Sometimes it doesn’t matter much which specifier you use. If that last
format string was <code class="pcalibre1 pcalibre literal">"Here’s %s dollars and %s cents."</code>, it would render
the same. But I recommend you choose the strictest type that will work
for your data; if you expect the value to be an integer, use <code class="pcalibre1 pcalibre literal">%d</code>, so
that if it’s <em class="pcalibre1 calibre8 pcalibre">not</em> an integer, you’ll get a clear stack trace telling
you what’s wrong:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13">"Here's </span><span class="pcalibre1 pcalibre calibre20">%d</span><span class="pcalibre1 pcalibre calibre13"> dollars and </span><span class="pcalibre1 pcalibre calibre20">%d</span><span class="pcalibre1 pcalibre calibre13"> cents."</span> % (14, <span class="pcalibre1 pcalibre calibre13">"a quarter"</span>)
Traceback (most recent call last):
  File <span class="pcalibre1 pcalibre calibre13">"&lt;stdin&gt;"</span>, line 1, <span class="pcalibre1 pcalibre calibre18">in</span> &lt;module&gt;
<span class="pcalibre1 pcalibre calibre18">TypeError</span>: %d format: a number <span class="pcalibre1 pcalibre calibre18">is</span> required, <span class="pcalibre1 pcalibre calibre18">not</span> str</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">(I’m assuming you’d rather discover a lurking bug now, during
development, instead of through an angry customer’s bug report later.)</p>
<p class="pcalibre1 pcalibre calibre7">Sometimes you’ll have just one value to interject. A tuple of one value
must be written with an extra comma, like <code class="pcalibre1 pcalibre literal">(foo,)</code> - because <code class="pcalibre1 pcalibre literal">(foo)</code>
becomes simply <code class="pcalibre1 pcalibre literal">foo</code> in the normal meaning of parentheses for
grouping. So to format a string of one variable, you can type this:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13">"High </span><span class="pcalibre1 pcalibre calibre20">%d</span><span class="pcalibre1 pcalibre calibre13">!"</span> % (5,)
<span class="pcalibre1 pcalibre calibre13">'High 5!'</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Early in Python’s history, people decided typing those extra
characters was a bit annoying, especially given how common it is to
format a string with a single value. So as a special case, when you
have a single specifier, you can pass in a single value instead of a
tuple:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13">"High </span><span class="pcalibre1 pcalibre calibre20">%d</span><span class="pcalibre1 pcalibre calibre13">!"</span> % 5
<span class="pcalibre1 pcalibre calibre13">'High 5!'</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">In addition to <code class="pcalibre1 pcalibre literal">%d</code> and <code class="pcalibre1 pcalibre literal">%s</code>, you can use <code class="pcalibre1 pcalibre literal">%f</code> for
a floating-point number:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13">"I owe you $</span><span class="pcalibre1 pcalibre calibre20">%f</span><span class="pcalibre1 pcalibre calibre13">."</span> % 7.05
<span class="pcalibre1 pcalibre calibre13">'I owe you $7.050000.'</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">You’ll often want to specify its precision - the number of digits to
the right of the decimal. Do this by inserting a <em class="pcalibre1 calibre8 pcalibre">precision code</em>
between <code class="pcalibre1 pcalibre literal">%</code> and <code class="pcalibre1 pcalibre literal">f</code> - which will be a <code class="pcalibre1 pcalibre literal">.</code> (dot) followed by an
integer:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13">"I owe you $</span><span class="pcalibre1 pcalibre calibre20">%.2f</span><span class="pcalibre1 pcalibre calibre13">."</span> % 5.05
<span class="pcalibre1 pcalibre calibre13">'I owe you $5.05.'</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">You can also use <code class="pcalibre1 pcalibre literal">%r</code> (which formats the <code class="pcalibre1 pcalibre literal">repr()</code> of the object). It’s
especially useful for logging and troubleshooting:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre18">class</span> <span class="pcalibre1 pcalibre calibre18">Money</span>:
...     <span class="pcalibre1 pcalibre calibre18">def</span> __init__(self, dollars, cents):
...         self.dollars = dollars
...         self.cents = cents
...     <span class="pcalibre1 pcalibre calibre18">def</span> __repr__(self):
...         <span class="pcalibre1 pcalibre calibre18">return</span> <span class="pcalibre1 pcalibre calibre13">'Money({},{})'</span>.format(
...             self.dollars, self.cents)
&gt;&gt;&gt; cash = Money(127, 82)
&gt;&gt;&gt; <span class="pcalibre1 pcalibre calibre13">"Cash on hand: </span><span class="pcalibre1 pcalibre calibre20">%r</span><span class="pcalibre1 pcalibre calibre13">"</span> % cash
<span class="pcalibre1 pcalibre calibre13">'Cash on hand: Money(127,82)'</span></code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">There is much more to percent formatting than this, but what we’ve
covered lets you read and write most of what you need.</p>
<p class="pcalibre1 pcalibre calibre7">

Now, as mentioned, in modern Python you’ll mainly need to use
percent formatting with the <code class="pcalibre1 pcalibre literal">logging</code> module. However, in that case,
you use it a bit differently. As described in its chapter, the
<code class="pcalibre1 pcalibre literal">logging</code> module includes functions for log events at different levels
of urgency - whether that’s an error, a warning, or even a non-urgent
informational message:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>logging.info(<span class="pcalibre1 pcalibre calibre13">"So far, so good!"</span>)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">You will <em class="pcalibre1 calibre8 pcalibre">very</em> often want to inject run-time values into the
message. For example, if a customer spends a certain amount of money:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>logging.info(<span class="pcalibre1 pcalibre calibre13">"User </span><span class="pcalibre1 pcalibre calibre20">%s</span><span class="pcalibre1 pcalibre calibre13"> spent $</span><span class="pcalibre1 pcalibre calibre20">%0.2f</span><span class="pcalibre1 pcalibre calibre13">"</span>, username, amount)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Notice there’s no binary percent operator! That’s deliberate. The logging
functions are designed to take a format string as the first argument,
and the values to substitute as subsequent arguments. That’s because
not every log message needs to be executed. You can - and often will -
configured your logger to filter out all those boring <code class="pcalibre1 pcalibre literal">info</code> messages,
for example, or omit the overly detailed <code class="pcalibre1 pcalibre literal">debug</code> messages. In other
words, don’t do this:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre13"># NO! Bad code!</span>
logging.info(<span class="pcalibre1 pcalibre calibre13">"User </span><span class="pcalibre1 pcalibre calibre20">%s</span><span class="pcalibre1 pcalibre calibre13"> spent $</span><span class="pcalibre1 pcalibre calibre20">%0.2f</span><span class="pcalibre1 pcalibre calibre13">"</span> % (username, amount))</code></pre>
</figure>
<p class="pcalibre1 calibre7 pcalibre7">Suppose you are filtering out <code class="pcalibre1 pcalibre literal">info</code> messages right now, so the <code class="pcalibre1 pcalibre literal">info</code>
message doesn’t need to actually log. In the first, recommended form,
that <code class="pcalibre1 pcalibre literal">logging.info</code> line in your code is cheap; it’s essentially
treated by Python as a no-op. In the second form, it will still be
translated as a no-op, <em class="pcalibre1 calibre8 pcalibre">but only after that string is rendered.</em> So
you unnecessarily incur the cost of rendering the string, just to
throw it away.  This is all explained in more detail in the logging
chapter; for now, just be aware of the idea.</p>
</section>
<footer class="pcalibre1 pcalibre calibre15">
<div class="calibre16 pcalibre1 pcalibre"></div><div class="pcalibre1 pcalibre chapter-footer">
<div class="pcalibre1 pcalibre footnotes">
<aside id="calibre_link-2" type="footnote" class="calibre2 pcalibre1 pcalibre">
<p class="pcalibre1 calibre17 pcalibre"><sup class="noteref1 pcalibre1 pcalibre"><a href="#calibre_link-4" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">1</a></sup> <a class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4" href="https://docs.python.org/3/library/string.html#format-specification-mini-language">https://docs.python.org/3/library/string.html#format-specification-mini-language</a></p>
</aside>
<aside id="calibre_link-3" type="footnote" class="calibre2 pcalibre1 pcalibre">
<p class="pcalibre1 calibre17 pcalibre"><sup class="noteref1 pcalibre1 pcalibre"><a href="#calibre_link-5" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">2</a></sup> <a class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4" href="https://docs.python.org/3/library/stdtypes.html#printf-style-string-formatting">https://docs.python.org/3/library/stdtypes.html#printf-style-string-formatting</a></p>
</aside>
</div>
</div>
</footer>
</section>
</div>


<div id="calibre_link-125" class="pcalibre1 pcalibre calibre">
<section class="calibre2 pcalibre1 pcalibre" id="calibre_link-192" title="Logging in Python" type="chapter">
<header id="calibre_link-116" class="calibre2 pcalibre1 pcalibre">
<div class="pcalibre1 pcalibre chapter-header">
<h1 class="pcalibre1 chapter-title pcalibre"> <small class="subtitle pcalibre1 pcalibre"><b class="pcalibre1 pcalibre calibre6">LOGGING</b> <b class="pcalibre1 pcalibre calibre6">IN</b> <b class="pcalibre1 pcalibre calibre6">PYTHON</b></small></h1>
</div>
</header>
<p class="pcalibre1 pcalibre calibre7"></p>
<p class="pcalibre1 pcalibre calibre7">Logging is critical in many kinds of software.  For long-running
software systems, it enables continuous telemetry and reporting. And
for <em class="pcalibre1 calibre8 pcalibre">all</em> software, it can provides priceless information for
troubleshooting and post-mortems.  The bigger the application, the
more important logging becomes. But even small scripts can benefit.</p>
<p class="pcalibre1 pcalibre calibre7">Python provides logging through the <code class="pcalibre1 pcalibre literal">logging</code> module. In my opinion,
this module is one of the more technically impressive parts of
Python’s standard library. It’s well-designed, flexible, thread-safe,
and richly powerful. It’s also complex, with many moving parts, making
it hard to learn well. This chapter gets you over most of that
learning curve, so you can fully benefit from what <code class="pcalibre1 pcalibre literal">logging</code> has to
offer. The payoff is well worth it, and will serve you for years.</p>
<p class="pcalibre1 pcalibre calibre7">Broadly, there are two ways to use <code class="pcalibre1 pcalibre literal">logging</code>. One, which I’m calling
the <em class="pcalibre1 calibre8 pcalibre">basic interface</em>,
is appropriate for scripts - meaning, Python programs that are small
enough to fit in a single file. For more substantial applications,
it’s typically better to use <em class="pcalibre1 calibre8 pcalibre">logger objects</em>, which give more flexible, centralized
control, and access to logging hierarchies. We’ll start with the
former, to introduce key ideas.</p>
<section class="calibre2 pcalibre1 pcalibre" title="The Basic Interface">
<h2 id="calibre_link-117" class="pcalibre1 pcalibre calibre1">The Basic Interface</h2>
<p class="pcalibre1 pcalibre calibre7">
Here’s the easiest way to use Python’s logging module:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">import</span> <span class="pcalibre1 pcalibre calibre18">logging</span>
logging.warning(<span class="pcalibre1 pcalibre calibre13">'Look out!'</span>)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Save this in a script and run it, and you’ll see this printed to
standard output:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11">WARNING:root:Look out!</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">You can do useful logging right away, by calling functions in the
<code class="pcalibre1 pcalibre literal">logging</code> module itself. Notice you invoke <code class="pcalibre1 pcalibre literal">logging.warning()</code>, and the
output line starts with <code class="pcalibre1 pcalibre literal">WARNING</code>. You can also call
<code class="pcalibre1 pcalibre literal">logging.error()</code>, which gives a different prefix:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11">ERROR:root:Look out!</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7"> We say that <code class="pcalibre1 pcalibre literal">warning</code> and <code class="pcalibre1 pcalibre literal">error</code> are
at different <em class="pcalibre1 calibre8 pcalibre">message log levels</em>.  You have a spectrum of log levels
to choose from, in order of increasing severity:<sup class="pcalibre1 pcalibre noteref">[<a href="#calibre_link-126" id="calibre_link-132" type="noteref" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">1</a>]</sup></p>
<div class="pcalibre1 pcalibre itemized-list">
<dl class="pcalibre1 pcalibre content">
<dt class="pcalibre1 calibre29 pcalibre">
<span class="pcalibre1 calibre8 pcalibre">debug</span>
</dt>
<dd class="calibre30 pcalibre1 pcalibre">
<span class="pcalibre1 principal pcalibre">Detailed information, typically of interest only when diagnosing problems.</span>
</dd>
<dt class="pcalibre1 calibre29 pcalibre">
<span class="pcalibre1 calibre8 pcalibre">info</span>
</dt>
<dd class="calibre30 pcalibre1 pcalibre">
<span class="pcalibre1 principal pcalibre">Confirmation that things are working as expected.</span>
</dd>
<dt class="pcalibre1 calibre29 pcalibre">
<span class="pcalibre1 calibre8 pcalibre">warning</span>
</dt>
<dd class="calibre30 pcalibre1 pcalibre">
<span class="pcalibre1 principal pcalibre">An indication that something unexpected happened, or indicative of some problem in the near future (e.g. â€˜disk space lowâ€™). The software is still working as expected.</span>
</dd>
<dt class="pcalibre1 calibre29 pcalibre">
<span class="pcalibre1 calibre8 pcalibre">error</span>
</dt>
<dd class="calibre30 pcalibre1 pcalibre">
<span class="pcalibre1 principal pcalibre">Due to a more serious problem, the software has not been able to perform some function.</span>
</dd>
<dt class="pcalibre1 calibre29 pcalibre">
<span class="pcalibre1 calibre8 pcalibre">critical</span>
</dt>
<dd class="calibre30 pcalibre1 pcalibre">
<span class="pcalibre1 principal pcalibre">A serious error, indicating that the program itself may be unable to continue running.</span>
</dd>
</dl>
</div>
<p class="pcalibre1 pcalibre calibre7">You use them all just like <code class="pcalibre1 pcalibre literal">logging.warning()</code> and <code class="pcalibre1 pcalibre literal">logging.error()</code>:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>logging.debug(<span class="pcalibre1 pcalibre calibre13">"Small detail. Useful for troubleshooting."</span>)
logging.info(<span class="pcalibre1 pcalibre calibre13">"This is informative."</span>)
logging.warning(<span class="pcalibre1 pcalibre calibre13">"This is a warning message."</span>)
logging.error(<span class="pcalibre1 pcalibre calibre13">"Uh oh. Something went wrong."</span>)
logging.critical(<span class="pcalibre1 pcalibre calibre13">"We have a big problem!"</span>)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Each has a corresponding uppercased constant in the library (e.g.,
<code class="pcalibre1 pcalibre literal">logging.WARNING</code> for <code class="pcalibre1 pcalibre literal">logging.warning()</code>). You use these when
defining the <em class="pcalibre1 calibre8 pcalibre">log level threshold</em>. Run the above, and here is the
output:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11">WARNING:root:This is a warning message.
ERROR:root:Uh oh. Something went wrong.
CRITICAL:root:We have a big problem!</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Where did the debug and info messages go? As it turns out, the default
logging threshold is <code class="pcalibre1 pcalibre literal">logging.WARNING</code>, which means only messages of
that severity or greater are actually generated; the others are
ignored completely. The order matters in the list above; <code class="pcalibre1 pcalibre literal">debug</code> is
considered strictly less severe than <code class="pcalibre1 pcalibre literal">info</code>, and so on. Change the log
level threshold using the <code class="pcalibre1 pcalibre literal">basicConfig</code> function:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>logging.basicConfig(level=logging.INFO)
logging.info(<span class="pcalibre1 pcalibre calibre13">"This is informative."</span>)
logging.error(<span class="pcalibre1 pcalibre calibre13">"Uh oh. Something went wrong."</span>)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Run this new program, and the <code class="pcalibre1 pcalibre literal">INFO</code> message gets printed:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11">INFO:root:This is informative.
ERROR:root:Uh oh. Something went wrong.</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Again, the order is <code class="pcalibre1 pcalibre literal">debug()</code>, <code class="pcalibre1 pcalibre literal">info()</code>, <code class="pcalibre1 pcalibre literal">warning()</code>, <code class="pcalibre1 pcalibre literal">error()</code> and
<code class="pcalibre1 pcalibre literal">critical()</code>, from lowest to highest severity. When we set the log
level threshold, we declare that we only want to see messages of that
level or higher. Messages of a lower level are not printed. When you set
<code class="pcalibre1 pcalibre literal">level</code> to <code class="pcalibre1 pcalibre literal">logging.DEBUG</code>, you see everything; set it to
<code class="pcalibre1 pcalibre literal">logging.CRITICAL</code>, and you only see critical messages, and so on.</p>
<p class="pcalibre1 pcalibre calibre7">The phrase "log level" means two different things, depending on
context. It can mean the severity of a message, which you set by
choosing which of the functions to use - <code class="pcalibre1 pcalibre literal">logging.warning()</code>, etc.  Or
it can mean the threshold for ignoring messages, which is signaled by
the constants: <code class="pcalibre1 pcalibre literal">logging.WARNING</code>, etc.</p>
<p class="pcalibre1 pcalibre calibre7">You can also use the constants in the more general <code class="pcalibre1 pcalibre literal">logging.log</code>
function - for example, a debug message:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>logging.log(logging.DEBUG,
    <span class="pcalibre1 pcalibre calibre13">"Small detail. Useful for troubleshooting."</span>)
logging.log(logging.INFO, <span class="pcalibre1 pcalibre calibre13">"This is informative."</span>)
logging.log(logging.WARNING, <span class="pcalibre1 pcalibre calibre13">"This is a warning message."</span>)
logging.log(logging.ERROR, <span class="pcalibre1 pcalibre calibre13">"Uh oh. Something went wrong."</span>)
logging.log(logging.CRITICAL, <span class="pcalibre1 pcalibre calibre13">"We have a big problem!"</span>)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">This lets you modify the log level dynamically, at
runtime:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">def</span> log_results(message, level=logging.INFO):
    logging.log(level, <span class="pcalibre1 pcalibre calibre13">"Results: "</span> + message)</code></pre>
</figure>
<section class="calibre2 pcalibre1 pcalibre" title="Why do we have log levels?">
<h3 id="calibre_link-193" class="pcalibre1 calibre21 pcalibre">Why do we have log levels?</h3>
<p class="pcalibre1 pcalibre calibre7">
If you haven’t worked with similar logging systems before, you may
wonder why we have different log levels, and why you’d want to control
the filtering threshold. It’s easiest to see this if you’ve written
Python scripts that include a number of <code class="pcalibre1 pcalibre literal">print()</code> statements -
including some useful for diagnosis when something goes wrong, but a
distraction when everything is working fine.</p>
<p class="pcalibre1 pcalibre calibre7">The fact is, some of those <code class="pcalibre1 pcalibre literal">print()</code> statements are more important
than others. Some indicate mission-critical problems you always want
to know about - possibly to the point of waking up an engineer, so
they can deploy a fix immediately. Some are important, but can wait
until the next work day - and you definitely do NOT want to wake
anyone up for that. Some are details which may have been important in
the past, and might be in the future, so you don’t want to remove
them; in the meantime, they are just line noise.</p>
<p class="pcalibre1 pcalibre calibre7">Having log levels solves all these problems. As you develop and evolve
your code over time, you continually add new logging statements of the
appropriate severity. You now even have the freedom to be
proactive. With "logging" via <code class="pcalibre1 pcalibre literal">print()</code>, each log statement has a cost
- certainly in signal-to-noise ratio, and also potentially in
performance. So you might debate whether to include that print
statement at all.  But with <code class="pcalibre1 pcalibre literal">logging</code>, you can insert <code class="pcalibre1 pcalibre literal">info</code> messages,
for example, to log certain events occurring as they should. In
development, those INFO messages can be very useful to verify certain
things are happening, so you can modify the log level to produce
them. On production, you may not want to have them cluttering up the
logs, so you just set the threshold higher. Or if you are doing some
kind of monitoring on production, and temporarily need that
information, you can adjust the log level threshold to output those
messages; when you are finished, you can adjust it back to exclude
them again.</p>
<p class="pcalibre1 pcalibre calibre7">When troubleshooting, you can liberally introduce <code class="pcalibre1 pcalibre literal">debug</code>-level
statements to provide extra detailed statements. When done, you can
just adjust the log level to turn them off. You can leave them in the
code without cost, eliminating any risk of introducing more bugs when
you go through and remove them. This also leaves them available if
they are needed in the future.</p>
<p class="pcalibre1 pcalibre calibre7"> The log level
symbols are actually set to integers. You can theoretically use these
numbers instead, or even define your own log levels that are (for
example) a third of the way between <code class="pcalibre1 pcalibre literal">WARNING</code> and <code class="pcalibre1 pcalibre literal">ERROR</code>. In normal
practice, it’s best to use the predefined logging levels. Doing
otherwise makes your code harder to read and maintain, and isn’t
worthwhile unless you have a compelling reason.</p>
<p class="pcalibre1 pcalibre calibre7">For reference, the numbers are 50 for <code class="pcalibre1 pcalibre literal">CRITICAL</code>, 40 for <code class="pcalibre1 pcalibre literal">ERROR</code>, 30
for <code class="pcalibre1 pcalibre literal">WARNING</code>, 20 for <code class="pcalibre1 pcalibre literal">INFO</code>, and 10 for <code class="pcalibre1 pcalibre literal">DEBUG</code>.  So when you set the
log level threshold, it’s actually setting a number. The only log
messages emitted are those with a level greater than or equal to that
number.</p>
</section>
</section>
<section class="calibre2 pcalibre1 pcalibre" title="Configuring The Basic Interface">
<h2 id="calibre_link-118" class="pcalibre1 pcalibre calibre1">Configuring The Basic Interface</h2>
<p class="pcalibre1 pcalibre calibre7">
You saw above you can change the loglevel threshold by calling a
function called <code class="pcalibre1 pcalibre literal">basicConfig</code>:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>logging.basicConfig(level=logging.INFO)
logging.debug(<span class="pcalibre1 pcalibre calibre13">"You won't see this message!"</span>)
logging.error(<span class="pcalibre1 pcalibre calibre13">"But you will see this one."</span>)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">If you use it at all, <code class="pcalibre1 pcalibre literal">basicConfig</code> must be called exactly once, and
it must happen before the first logging event. (Meaning, before the
first call to <code class="pcalibre1 pcalibre literal">debug()</code>, or <code class="pcalibre1 pcalibre literal">warning()</code>, etc.) Additionally, if your
program has several threads, it must be called from the main thread -
and <em class="pcalibre1 calibre8 pcalibre">only</em> the main thread. <sup class="pcalibre1 pcalibre noteref">[<a href="#calibre_link-127" id="calibre_link-133" type="noteref" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">2</a>]</sup></p>
<p class="pcalibre1 pcalibre calibre7">You already met one of the configuration options, <code class="pcalibre1 pcalibre literal">level</code>. This is set
to the log level threshold, and is one of <code class="pcalibre1 pcalibre literal">DEBUG</code>, <code class="pcalibre1 pcalibre literal">INFO</code>, <code class="pcalibre1 pcalibre literal">WARNING</code>,
<code class="pcalibre1 pcalibre literal">ERROR</code>, or <code class="pcalibre1 pcalibre literal">CRITICAL</code>. Some of the other options include:</p>
<div class="pcalibre1 pcalibre itemized-list">
<dl class="pcalibre1 pcalibre content">
<dt class="pcalibre1 calibre29 pcalibre">
<span class="pcalibre1 calibre8 pcalibre"><code class="pcalibre1 pcalibre literal">filename</code></span>
</dt>
<dd class="calibre30 pcalibre1 pcalibre">
<span class="pcalibre1 principal pcalibre">Write log messages to the given file, rather than stderr.</span>
</dd>
<dt class="pcalibre1 calibre29 pcalibre">
<span class="pcalibre1 calibre8 pcalibre"><code class="pcalibre1 pcalibre literal">filemode</code></span>
</dt>
<dd class="calibre30 pcalibre1 pcalibre">
<span class="pcalibre1 principal pcalibre">Set to "a" to append to the log file (the default), or "w" to
overwrite.</span>
</dd>
<dt class="pcalibre1 calibre29 pcalibre">
<span class="pcalibre1 calibre8 pcalibre"><code class="pcalibre1 pcalibre literal">format</code></span>
</dt>
<dd class="calibre30 pcalibre1 pcalibre">
<span class="pcalibre1 principal pcalibre">The format of log records.</span>
</dd>
<dt class="pcalibre1 calibre29 pcalibre">
<span class="pcalibre1 calibre8 pcalibre"><code class="pcalibre1 pcalibre literal">level</code></span>
</dt>
<dd class="calibre30 pcalibre1 pcalibre">
<span class="pcalibre1 principal pcalibre">The log level threshold, described above.</span>
</dd>
</dl>
</div>
<p class="pcalibre1 pcalibre calibre7">By default, log messages are written to standard error. You can also
write them to a file, one per line, to easily read later. Do this by
setting <code class="pcalibre1 pcalibre literal">filename</code> to the log file path. By default it appends log
messages, meaning that it will only add to the end of the file if it
isn’t empty. If you’d rather the file be emptied before the first
log message, set <code class="pcalibre1 pcalibre literal">filemode</code> to "w". Be careful about doing that, of course,
because you can easily lose old log messages if the application
restarts:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre13"># Wipes out previous log entries when program restarts</span>
logging.basicConfig(filename=<span class="pcalibre1 pcalibre calibre13">"log.txt"</span>, filemode=<span class="pcalibre1 pcalibre calibre13">"w"</span>)
logging.error(<span class="pcalibre1 pcalibre calibre13">"oops"</span>)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">The other valid value is "a", for append - that’s the default, and
probably will serve you better in production. "w" can be useful during
development, though.</p>
<p class="pcalibre1 pcalibre calibre7"><code class="pcalibre1 pcalibre literal">format</code> defines what chunks of information the final log record will
include, and how they are laid out. These chunks are called
"attributes" in the <code class="pcalibre1 pcalibre literal">logging</code> module docs. One of these attributes is
the actual log message - the string you pass when you call
<code class="pcalibre1 pcalibre literal">logging.warning()</code>, and so on. Often you will want to include other
attributes as well. Consider the kind of log record we saw above:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11">WARNING:root:Collision imminent</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">This record has three attributes, separated by colons. First is the
log level name; last is the actual string message you pass when you
call <code class="pcalibre1 pcalibre literal">logging.warning()</code>. (In the middle is the name of the underlying
logger object.  <code class="pcalibre1 pcalibre literal">basicConfig</code> uses a logger called "root"; we’ll learn
more about that later.)</p>
<p class="pcalibre1 pcalibre calibre7">You specify the layout you want by setting <code class="pcalibre1 pcalibre literal">format</code> to a string that
defines certain named fields, according to percent-style
formatting. Three of them are <code class="pcalibre1 pcalibre literal">levelname</code>, the log level; <code class="pcalibre1 pcalibre literal">message</code>,
the message string passed to the logging function; and <code class="pcalibre1 pcalibre literal">name</code>, the
name of the underlying logger. Here’s an example:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>logging.basicConfig(
    format=<span class="pcalibre1 pcalibre calibre13">"Log level: </span><span class="pcalibre1 pcalibre calibre20">%(levelname)s</span><span class="pcalibre1 pcalibre calibre13">, msg: </span><span class="pcalibre1 pcalibre calibre20">%(message)s</span><span class="pcalibre1 pcalibre calibre13">"</span>)
logging.warning(<span class="pcalibre1 pcalibre calibre13">"Collision imminent"</span>)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">If you run this as a program, you get the following output:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11">Log level: WARNING, msg: Collision imminent</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">It turns out the default formatting string is</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11">%(levelname)s:%(name)s:%(message)s</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">You indicate named fields in percent-formatting by <code class="pcalibre1 pcalibre literal">%(FIELDNAME)X</code>,
where "X" is a type code: <code class="pcalibre1 pcalibre literal">s</code> for string, <code class="pcalibre1 pcalibre literal">d</code> for integer (decimal),
and <code class="pcalibre1 pcalibre literal">f</code> for floating-point.</p>
<p class="pcalibre1 pcalibre calibre7">Many other attributes are provided, if you want to include
them. Here’s a select few from
the full list:<sup class="pcalibre1 pcalibre noteref">[<a href="#calibre_link-128" id="calibre_link-134" type="noteref" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">3</a>]</sup></p>
<div class="pcalibre1 pcalibre footnotes">
<div class="pcalibre1 pcalibre content">
<table class="pcalibre1 pcalibre table">
<colgroup class="pcalibre1 calibre22 pcalibre">
<col class="calibre23 pcalibre1 pcalibre"></col>
<col class="calibre23 pcalibre1 pcalibre"></col>
<col class="calibre23 pcalibre1 pcalibre"></col>
</colgroup>
<thead class="pcalibre1 calibre31 pcalibre">
<tr class="pcalibre1 pcalibre calibre25">
<th class="pcalibre1 calibre32 pcalibre">Attribute</th>
<th class="pcalibre1 calibre32 pcalibre">Format</th>
<th class="pcalibre1 calibre32 pcalibre">Description</th>
</tr>
</thead>
<tbody class="pcalibre1 pcalibre calibre24">
<tr class="pcalibre1 pcalibre calibre25">
<td class="pcalibre1 pcalibre calibre26"><p class="pcalibre1 pcalibre calibre27">asctime</p></td>
<td class="pcalibre1 pcalibre calibre26"><p class="pcalibre1 pcalibre calibre27"><code class="pcalibre1 pcalibre literal">%(asctime)s</code></p></td>
<td class="pcalibre1 pcalibre calibre26"><p class="pcalibre1 pcalibre calibre27">Human-readable date/time</p></td>
</tr>
<tr class="pcalibre1 pcalibre calibre25">
<td class="pcalibre1 pcalibre calibre26"><p class="pcalibre1 pcalibre calibre27">funcName</p></td>
<td class="pcalibre1 pcalibre calibre26"><p class="pcalibre1 pcalibre calibre27"><code class="pcalibre1 pcalibre literal">%(funcName)s</code></p></td>
<td class="pcalibre1 pcalibre calibre26"><p class="pcalibre1 pcalibre calibre27">Name of function containing the logging call</p></td>
</tr>
<tr class="pcalibre1 pcalibre calibre25">
<td class="pcalibre1 pcalibre calibre26"><p class="pcalibre1 pcalibre calibre27">lineno</p></td>
<td class="pcalibre1 pcalibre calibre26"><p class="pcalibre1 pcalibre calibre27"><code class="pcalibre1 pcalibre literal">%(lineno)d</code></p></td>
<td class="pcalibre1 pcalibre calibre26"><p class="pcalibre1 pcalibre calibre27">The line number of the logging call</p></td>
</tr>
<tr class="pcalibre1 pcalibre calibre25">
<td class="pcalibre1 pcalibre calibre26"><p class="pcalibre1 pcalibre calibre27">message</p></td>
<td class="pcalibre1 pcalibre calibre26"><p class="pcalibre1 pcalibre calibre27"><code class="pcalibre1 pcalibre literal">%(message)s</code></p></td>
<td class="pcalibre1 pcalibre calibre26"><p class="pcalibre1 pcalibre calibre27">The log message</p></td>
</tr>
<tr class="pcalibre1 pcalibre calibre25">
<td class="pcalibre1 pcalibre calibre26"><p class="pcalibre1 pcalibre calibre27">pathname</p></td>
<td class="pcalibre1 pcalibre calibre26"><p class="pcalibre1 pcalibre calibre27"><code class="pcalibre1 pcalibre literal">%(pathname)s</code></p></td>
<td class="pcalibre1 pcalibre calibre26"><p class="pcalibre1 pcalibre calibre27">Full pathname of the source file of the logging call</p></td>
</tr>
<tr class="pcalibre1 pcalibre calibre25">
<td class="pcalibre1 pcalibre calibre26"><p class="pcalibre1 pcalibre calibre27">levelname</p></td>
<td class="pcalibre1 pcalibre calibre26"><p class="pcalibre1 pcalibre calibre27"><code class="pcalibre1 pcalibre literal">%(levelname)s</code></p></td>
<td class="pcalibre1 pcalibre calibre26"><p class="pcalibre1 pcalibre calibre27">Text logging level for the message ('DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL')</p></td>
</tr>
<tr class="pcalibre1 pcalibre calibre25">
<td class="pcalibre1 pcalibre calibre26"><p class="pcalibre1 pcalibre calibre27">name</p></td>
<td class="pcalibre1 pcalibre calibre26"><p class="pcalibre1 pcalibre calibre27"><code class="pcalibre1 pcalibre literal">%(name)s</code></p></td>
<td class="pcalibre1 pcalibre calibre26"><p class="pcalibre1 pcalibre calibre27">The logger’s name</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<p class="pcalibre1 pcalibre calibre7">You might be wondering why log record format strings use Python 2’s
percent-formatting style, when everything else in Python 3 uses the
newer, brace-style string formatting. As it turns out, the conversion
was attempted, but backwards-compatibility reasons made
percent-formatting the only practical choice for the logging module,
even after the Python 3 reboot.</p>
<p class="pcalibre1 pcalibre calibre7">If you want to use the newer string formatting badly enough, there are
things you can do - there’s even a standard
recipe.<sup class="pcalibre1 pcalibre noteref">[<a href="#calibre_link-129" id="calibre_link-135" type="noteref" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">4</a>]</sup>
But doing so is complicated enough that it may not be worth the
effort, and it won’t help with legacy code. I recommend you simply
cooperate with the situation, and use percent formatting with your
Python logging.</p>
</section>
<section class="calibre2 pcalibre1 pcalibre" title="Passing Arguments">
<h2 id="calibre_link-119" class="pcalibre1 pcalibre calibre1">Passing Arguments</h2>
<p class="pcalibre1 pcalibre calibre7">
You often want to include some kind of runtime data in the logged
message. When you construct the message to log, specify the final log
message like this:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>num_fruits = 14
fruit_name = <span class="pcalibre1 pcalibre calibre13">"oranges"</span>
logging.info(
    <span class="pcalibre1 pcalibre calibre13">"We ate </span><span class="pcalibre1 pcalibre calibre20">%d</span><span class="pcalibre1 pcalibre calibre13"> of your </span><span class="pcalibre1 pcalibre calibre20">%s</span><span class="pcalibre1 pcalibre calibre13">. Thanks!"</span>,
    num_fruits, fruit_name)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">The output:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11">INFO:root:We ate 14 of your oranges. Thanks!</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">We call <code class="pcalibre1 pcalibre literal">info</code> with three parameters. First is the format
string; the second and third are arguments. The general form is</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11">logging.info(format, *args)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">You can pass zero or more arguments, so long as each has a field in
the format string:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11">logging.info("%s, %s, %s, %s, %s, %s and %s",
    "Doc", "Happy", "Sneezy", "Bashful",
    "Dopey", "Sleepy", "Grumpy")</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">You <em class="pcalibre1 calibre8 pcalibre">must</em> resist the obvious temptation to format the string fully,
and pass that to the logging function:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>num_fruits = 14
fruit_name = <span class="pcalibre1 pcalibre calibre13">"oranges"</span>
logging.warning(
    <span class="pcalibre1 pcalibre calibre13">"Don't do this: </span><span class="pcalibre1 pcalibre calibre20">%d</span><span class="pcalibre1 pcalibre calibre13"> </span><span class="pcalibre1 pcalibre calibre20">%s</span><span class="pcalibre1 pcalibre calibre13">"</span> % (num_fruits, fruit_name))
logging.warning(
    <span class="pcalibre1 pcalibre calibre13">"Or even this: {:d} {:s}"</span>.format(
    num_fruits, fruit_name))</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">This works, of course, in the sense that you will get correct log
messages. However, it’s wasteful, and surrenders important benefits
<code class="pcalibre1 pcalibre literal">logging</code> normally provides. Remember: when the line of code
with the log message is executed, it may not actually trigger a
log event. If the log level threshold is higher than the message
itself, the line does nothing. In that case, there is no
reason to format the string.</p>
<p class="pcalibre1 pcalibre calibre7">In the first form, the string is formatted if and only if a log event
actually happens, so that’s fine.  But if you format the string
yourself, it’s <em class="pcalibre1 calibre8 pcalibre">always</em> formatted. That takes up system memory and CPU
cycles even if no logging takes place. If the code path with the
logging call is only executed occasionally, that’s not a big deal. But
it impairs the program when a debug message is logged in the
middle of a tight loop. When you originally code the line, you
never really know where it might migrate in the future, or who will
call your function in ways you never imagined.</p>
<p class="pcalibre1 pcalibre calibre7">So just use the supported form, where the first argument is the format
string, and subsequent arguments are the parameters for it. You can
also use named fields, by passing a dictionary as the second argument:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>fruit_info = {<span class="pcalibre1 pcalibre calibre13">"count"</span>: 14, <span class="pcalibre1 pcalibre calibre13">"name"</span>: <span class="pcalibre1 pcalibre calibre13">"oranges"</span>}
logging.info(
    <span class="pcalibre1 pcalibre calibre13">"We ate </span><span class="pcalibre1 pcalibre calibre20">%(count)d</span><span class="pcalibre1 pcalibre calibre13"> of your </span><span class="pcalibre1 pcalibre calibre20">%(name)s</span><span class="pcalibre1 pcalibre calibre13">. Thanks!"</span>,
    fruit_info)</code></pre>
</figure>
</section>
<section class="calibre2 pcalibre1 pcalibre" title="Beyond Basic: Loggers">
<h2 id="calibre_link-120" class="pcalibre1 pcalibre calibre1">Beyond Basic: Loggers</h2>
<p class="pcalibre1 pcalibre calibre7">
The basic interface is simple and easy to set up. It works well in
single-file scripts. Larger Python applications tend to have different
logging needs, however. <code class="pcalibre1 pcalibre literal">logging</code> meets these needs through a richer
interface, called <em class="pcalibre1 calibre8 pcalibre">logger objects</em> - or simply, <em class="pcalibre1 calibre8 pcalibre">loggers</em>.</p>
<p class="pcalibre1 pcalibre calibre7">Actually, you have been using a logger object all along: when you call
<code class="pcalibre1 pcalibre literal">logging.warning()</code> (or the other log functions), they convey messages
through what is called the <em class="pcalibre1 calibre8 pcalibre">root logger</em> - the primary, default logger
object. This is why the word "root" shows in some example
output.</p>
<p class="pcalibre1 pcalibre calibre7"><code class="pcalibre1 pcalibre literal">logger.basicConfig</code> operates on this root logger. You can fetch the
actual root logger object by calling <code class="pcalibre1 pcalibre literal">logging.getLogger</code>:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11">&gt;&gt;&gt; logger = logging.getLogger()
&gt;&gt;&gt; logger.name
'root'</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">As you can see, it knows its name is "root". Logger objects have all
the same functions (methods, actually) the <code class="pcalibre1 pcalibre literal">logging</code> module itself
has:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">import</span> <span class="pcalibre1 pcalibre calibre18">logging</span>
logger = logging.getLogger()
logger.debug(<span class="pcalibre1 pcalibre calibre13">"Small detail. Useful for troubleshooting."</span>)
logger.info(<span class="pcalibre1 pcalibre calibre13">"This is informative."</span>)
logger.warning(<span class="pcalibre1 pcalibre calibre13">"This is a warning message."</span>)
logger.error(<span class="pcalibre1 pcalibre calibre13">"Uh oh. Something went wrong."</span>)
logger.critical(<span class="pcalibre1 pcalibre calibre13">"We have a big problem!"</span>)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Save this in a file and run it, and you’ll see the following output:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11">This is a warning message.
Uh oh. Something went wrong.
We have a big problem!</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">This is different from what we saw with <code class="pcalibre1 pcalibre literal">basicConfig</code>, which printed
out this instead:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11">WARNING:root:This is a warning message.
ERROR:root:Uh oh. Something went wrong.
CRITICAL:root:We have a big problem!</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">At this point, we’ve taken steps backward compared to
<code class="pcalibre1 pcalibre literal">basicConfig</code>. Not only is the log message unadorned by the log level,
or anything else useful. The log level threshold is hard-coded to
<code class="pcalibre1 pcalibre literal">logging.WARNING</code>, with no way to change it. The logging output will
be written to standard error, and no where else, regardless of where
you actually need it to go.</p>
<p class="pcalibre1 pcalibre calibre7">Let’s take inventory of what we want to control here. We want to
choose our log record format. And further, we want to be able to
control the log level threshold, and write messages to different
streams and destinations. You do this with a tool called <em class="pcalibre1 calibre8 pcalibre">handlers</em>.</p>
</section>
<section class="calibre2 pcalibre1 pcalibre" title="Log Destinations: Handlers and Streams">
<h2 id="calibre_link-121" class="pcalibre1 pcalibre calibre1">Log Destinations: Handlers and Streams</h2>
<p class="pcalibre1 pcalibre calibre7">



By default, loggers write to standard error. You can select a
different destination - or even <em class="pcalibre1 calibre8 pcalibre">several</em> destinations - for
each log record:</p>
<div class="pcalibre1 pcalibre itemized-list">
<ul class="pcalibre1 calibre14 pcalibre">
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">You can write log records to a file. Very common.</span>
</li>
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">You can, while writing records to that file, <em class="pcalibre1 calibre8 pcalibre">also</em> parrot it to stderr.</span>
</li>
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">Or to stdout. Or both.</span>
</li>
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">You can simultaneously log messages to two different files.</span>
</li>
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">In fact, you can log (say) <code class="pcalibre1 pcalibre literal">INFO</code> and higher messages to one file,
and <code class="pcalibre1 pcalibre literal">ERROR</code> and higher to another.</span>
</li>
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">You can write log records to a remote log server, accessed via a
REST HTTP API.</span>
</li>
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">Mix and match all the above, and more.</span>
</li>
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">And you can set a different, custom log format for each destination.</span>
</li>
</ul>
</div>
<p class="pcalibre1 pcalibre calibre7">This is all managed through what are called <em class="pcalibre1 calibre8 pcalibre">handlers</em>. In Python
logging, a handler’s job is to take a log record, and make sure it
gets recorded in the appropriate destination. That destination can be
a file; a stream like stderr or stdout; or something more abstract,
like inserting into a queue, or transmitting via an RPC or HTTP call.</p>
<p class="pcalibre1 pcalibre calibre7">By default, logger objects don’t have any handlers. You can verify this
using the <code class="pcalibre1 pcalibre literal">hasHandlers</code> method:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>&gt;&gt;&gt; logger = logging.getLogger()
&gt;&gt;&gt; logger.hasHandlers()
False</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">With no handler, a logger has the following behavior:</p>
<div class="pcalibre1 pcalibre itemized-list">
<ul class="pcalibre1 calibre14 pcalibre">
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">Messages are written to stderr.</span>
</li>
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">Only the message is written, nothing else. There’s no way to add
fields or otherwise modify it.</span>
</li>
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre">The log level threshold is <code class="pcalibre1 pcalibre literal">logging.WARNING</code>. There is no way to
change that.</span>
</li>
</ul>
</div>
<p class="pcalibre1 pcalibre calibre7">To change this, your first step is to create a handler. Nearly all
logger objects you ever use will have custom handlers. Let’s see how
to create a simple handler that writes messages to a file, called
"log.txt".</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">import</span> <span class="pcalibre1 pcalibre calibre18">logging</span>
logger = logging.getLogger()
log_file_handler = logging.FileHandler(<span class="pcalibre1 pcalibre calibre13">"log.txt"</span>)
logger.addHandler(log_file_handler)
logger.debug(<span class="pcalibre1 pcalibre calibre13">"A little detail"</span>)
logger.warning(<span class="pcalibre1 pcalibre calibre13">"Boo!"</span>)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">
The <code class="pcalibre1 pcalibre literal">logging</code> module provides a class called <code class="pcalibre1 pcalibre literal">FileHandler</code>. It takes a
file path argument, and will write log records into that file, one per
line. When you run this code, <code class="pcalibre1 pcalibre literal">log.txt</code> will be created (if it doesn’t
already exist), and will contain the string "Boo!" followed by a
newline. (If <code class="pcalibre1 pcalibre literal">log.txt</code> did exist already, the logged message would be
<em class="pcalibre1 calibre8 pcalibre">appended</em> to the end of the file.)</p>
<p class="pcalibre1 pcalibre calibre7">But "A little detail" is not written, because it’s below the default
logger threshold of <code class="pcalibre1 pcalibre literal">WARNING</code>. We change that by calling a method
named <code class="pcalibre1 pcalibre literal">setLevel</code> on the logger object:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">import</span> <span class="pcalibre1 pcalibre calibre18">logging</span>
logger = logging.getLogger()
logger.setLevel(logging.DEBUG)
log_file_handler = logging.FileHandler(<span class="pcalibre1 pcalibre calibre13">"log.txt"</span>)
logger.addHandler(log_file_handler)
logger.debug(<span class="pcalibre1 pcalibre calibre13">"A little detail"</span>)
logger.warning(<span class="pcalibre1 pcalibre calibre13">"Boo!"</span>)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">This writes the following in "log.txt":</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11">A little detail
Boo!</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Confusingly, you can call <code class="pcalibre1 pcalibre literal">setLevel</code> on a logger with no handlers,
<em class="pcalibre1 calibre8 pcalibre">but it has no effect</em>:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre13"># Doing it wrong:</span>
<span class="pcalibre1 pcalibre calibre18">import</span> <span class="pcalibre1 pcalibre calibre18">logging</span>
logger = logging.getLogger()
logger.setLevel(logging.DEBUG) <span class="pcalibre1 pcalibre calibre13"># No effect.</span>
logger.debug(<span class="pcalibre1 pcalibre calibre13">"This won't work :("</span>)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">To change the threshold from the default of <code class="pcalibre1 pcalibre literal">logging.WARNING</code>, you
must both add a handler, <em class="pcalibre1 calibre8 pcalibre">and</em> change the logger’s level.</p>
<p class="pcalibre1 pcalibre calibre7">
What if you want to log to stdout? Do that with a <code class="pcalibre1 pcalibre literal">StreamHandler</code>:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">import</span> <span class="pcalibre1 pcalibre calibre18">logging</span>
<span class="pcalibre1 pcalibre calibre18">import</span> <span class="pcalibre1 pcalibre calibre18">sys</span>
logger = logging.getLogger()
out_handler = logging.StreamHandler(sys.stdout)
logger.addHandler(out_handler)
logger.warning(<span class="pcalibre1 pcalibre calibre13">"Boo!"</span>)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">If you save this in a file and run it, you’ll get "Boo!" on standard
output. Notice that <code class="pcalibre1 pcalibre literal">logging.StreamHandler</code> takes <code class="pcalibre1 pcalibre literal">sys.stdout</code> as its
argument. You can create a <code class="pcalibre1 pcalibre literal">StreamHandler</code> without an argument too, in
which case it will write its records to standard error:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">import</span> <span class="pcalibre1 pcalibre calibre18">logging</span>
logger = logging.getLogger()
<span class="pcalibre1 pcalibre calibre13"># Same as StreamHandler(sys.stderr)</span>
stderr_handler = logging.StreamHandler()
logger.addHandler(stderr_handler)
logger.warning(<span class="pcalibre1 pcalibre calibre13">"This goes to standard error"</span>)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">In fact, you can pass any file-like object; The object just needs to
define compatible <code class="pcalibre1 pcalibre literal">write</code> and <code class="pcalibre1 pcalibre literal">flush</code> methods. Theoretically, you
could even log to a file by creating a handler like
<code class="pcalibre1 pcalibre literal">StreamHandler(open("log.txt", "a"))</code> - but in that case, it’s better
to use a <code class="pcalibre1 pcalibre literal">FileHandler</code>, so it can manage opening and closing the file.</p>
<p class="pcalibre1 pcalibre calibre7">


When creating a handler, your needs are nearly always met by either
<code class="pcalibre1 pcalibre literal">StreamHandler</code> or <code class="pcalibre1 pcalibre literal">FileHandler</code>. There are other predefined handlers,
too, useful when logging to certain specialized destinations:</p>
<div class="pcalibre1 pcalibre itemized-list">
<ul class="pcalibre1 calibre14 pcalibre">
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre"><code class="pcalibre1 pcalibre literal">WatchedFileHandler</code> and
<code class="pcalibre1 pcalibre literal">RotatingFileHandler</code>, for logging to
rotated log files</span>
</li>
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre"><code class="pcalibre1 pcalibre literal">SocketHandler</code> and
<code class="pcalibre1 pcalibre literal">DatagramHandler</code> for logging over
network sockets</span>
</li>
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre"><code class="pcalibre1 pcalibre literal">HTTPHandler</code> for logging over an HTTP REST
interface</span>
</li>
<li class="pcalibre calibre4 pcalibre6">
<span class="pcalibre1 principal pcalibre"><code class="pcalibre1 pcalibre literal">QueueHandler</code> and
<code class="pcalibre1 pcalibre literal">QueueListener</code> for queuing log records
across thread and process boundaries</span>
</li>
</ul>
</div>
<p class="pcalibre1 pcalibre calibre7">See the official
docs​<sup class="pcalibre1 pcalibre noteref">[<a href="#calibre_link-130" id="calibre_link-136" type="noteref" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">5</a>]</sup>
for more details.</p>
</section>
<section class="calibre2 pcalibre1 pcalibre" title="Logging to Multiple Destinations">
<h2 id="calibre_link-122" class="pcalibre1 pcalibre calibre1">Logging to Multiple Destinations</h2>
<p class="pcalibre1 pcalibre calibre7">
Suppose you want your long-running application to log all messages to
a file, including debug-level records. At the same time, you want
warnings, errors, and criticals logged to the console. How do you do
this?</p>
<p class="pcalibre1 pcalibre calibre7">We’ve given you part of the answer already. A single logger object can
have multiple handlers: all you have to do is call <code class="pcalibre1 pcalibre literal">addHandler</code>
multiple times, passing a different handler object for each. For
example, here is how you parrot all log messages to the console (via
standard error) and also to a file:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">import</span> <span class="pcalibre1 pcalibre calibre18">logging</span>
logger = logging.getLogger()
<span class="pcalibre1 pcalibre calibre13"># Remember, StreamHandler defaults to using sys.stderr</span>
console_handler = logging.StreamHandler()
logger.addHandler(console_handler)
<span class="pcalibre1 pcalibre calibre13"># Now the file handler:</span>
logfile_handler = logging.FileHandler(<span class="pcalibre1 pcalibre calibre13">"log.txt"</span>)
logger.addHandler(logfile_handler)
logger.warning(
    <span class="pcalibre1 pcalibre calibre13">"This goes to both the console, AND log.txt."</span>)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">This is combining what we learned above. We create two handlers - a
<code class="pcalibre1 pcalibre literal">StreamHandler</code> named <code class="pcalibre1 pcalibre literal">console_handler</code>, and a <code class="pcalibre1 pcalibre literal">FileHandler</code> named
<code class="pcalibre1 pcalibre literal">logfile_handler</code> - and add both to the same logger (via
<code class="pcalibre1 pcalibre literal">addHandler</code>). That’s all you need to log to multiple destinations in
parallel. Sure enough, if you save the above in a script and run it,
you’ll find the messages are both written into "log.txt", as well as
printed on the console (through standard error).</p>
<p class="pcalibre1 pcalibre calibre7">We aren’t done, though. How do we make it so every record is written
in the log file, but only those of <code class="pcalibre1 pcalibre literal">logging.WARNING</code> or higher get
sent to the console screen? Do this by setting log level thresholds
for both the logger object and the individual handlers. Both logger
objects and handlers have a method called <code class="pcalibre1 pcalibre literal">setLevel</code>, taking a log
level threshold as an argument:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>my_logger.setLevel(logging.DEBUG)
my_handler.setLevel(logging.INFO)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">If you set the level for a logger, but not its handlers, the handlers
inherit from the logger:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span>my_logger.setLevel(logging.ERROR)
my_logger.addHandler(my_handler)
my_logger.error(<span class="pcalibre1 pcalibre calibre13">"This message is emitted by my_handler."</span>)
my_logger.debug(<span class="pcalibre1 pcalibre calibre13">"But this message will not."</span>)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">And you can override that at the handler level. Here, I create two
handlers. One handler inherits its threshold from the logger, while
the other does its own thing:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">import</span> <span class="pcalibre1 pcalibre calibre18">logging</span>
logger = logging.getLogger()
logger.setLevel(logging.DEBUG)

verbose_handler = logging.FileHandler(<span class="pcalibre1 pcalibre calibre13">"verbose.txt"</span>)
logger.addHandler(verbose_handler)

terse_handler = logging.FileHandler(<span class="pcalibre1 pcalibre calibre13">"terse.txt"</span>)
terse_handler.setLevel(logging.WARNING)
logger.addHandler(terse_handler)

logger.debug(<span class="pcalibre1 pcalibre calibre13">"This message appears in verbose.txt ONLY."</span>)
logger.warning(<span class="pcalibre1 pcalibre calibre13">"And this message appears in both files."</span>)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">There’s a caveat, though: a handler can only make itself <em class="pcalibre1 calibre8 pcalibre">more</em>
selective than its logger, not less. If the logger chooses a threshold
of <code class="pcalibre1 pcalibre literal">logger.DEBUG</code>, its handler can choose a threshold of
<code class="pcalibre1 pcalibre literal">logger.INFO</code>, or <code class="pcalibre1 pcalibre literal">logger.ERROR</code>, and so on. But if the logger defines
a strict threshold - say, <code class="pcalibre1 pcalibre literal">logger.INFO</code> - an individual handler cannot
choose a lower one, like <code class="pcalibre1 pcalibre literal">logger.DEBUG</code>. So something like this won’t
work:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre13"># This doesn't quite work...</span>
<span class="pcalibre1 pcalibre calibre18">import</span> <span class="pcalibre1 pcalibre calibre18">logging</span>
my_logger = logging.getLogger()
my_logger.setLevel(logging.INFO)
my_handler = logging.StreamHandler()
my_handler.setLevel(logging.DEBUG) <span class="pcalibre1 pcalibre calibre13"># FAIL!</span>
my_logger.addHandler(my_handler)
my_logger.debug(<span class="pcalibre1 pcalibre calibre13">"No one will ever see this message :("</span>)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">There’s a subtle corollary of this. By default, a logger object’s
threshold is set to <code class="pcalibre1 pcalibre literal">logger.WARNING</code>. So if you don’t set the logger
object’s log level at all, it implicitly censors all handlers:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">import</span> <span class="pcalibre1 pcalibre calibre18">logging</span>
my_logger = logging.getLogger()
my_handler = logging.StreamHandler()
my_handler.setLevel(logging.DEBUG) <span class="pcalibre1 pcalibre calibre13"># FAIL!</span>
my_logger.addHandler(my_handler)
<span class="pcalibre1 pcalibre calibre13"># No one will see this message either.</span>
my_logger.debug(
    <span class="pcalibre1 pcalibre calibre13">"Because anything under WARNING gets filtered."</span>)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">The logger object’s default log level is not always permissive enough
for all handlers you might want to define. So you will generally want
to start by setting the logger object to the lowest threshold needed
by any log-record destination, and tighten that threshold for each
handler as needed.</p>
<p class="pcalibre1 pcalibre calibre7">Bringing this all together, we can now accomplish what we originally
wanted - to verbosely log everything into a log file, while duplicating
only the more interesting messages onto the console:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">import</span> <span class="pcalibre1 pcalibre calibre18">logging</span>
logger = logging.getLogger()
logger.setLevel(logging.DEBUG)
<span class="pcalibre1 pcalibre calibre13"># Warnings and higher only on the console.</span>
console_handler = logging.StreamHandler()
console_handler.setLevel(logging.WARNING)
logger.addHandler(console_handler)
<span class="pcalibre1 pcalibre calibre13"># But allow everything to into the log file.</span>
logfile_handler = logging.FileHandler(<span class="pcalibre1 pcalibre calibre13">"log.txt"</span>)
logger.addHandler(logfile_handler)

logger.warning(
    <span class="pcalibre1 pcalibre calibre13">"This goes to both the console, AND into log.txt."</span>)
logger.debug(<span class="pcalibre1 pcalibre calibre13">"While this only goes to the file."</span>)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Add as many handlers as you want. Each can have different log
levels. You can log to many different destinations, using the
different built-in handler types mentioned above. If those don’t do
what you need, implement your own subclass of <code class="pcalibre1 pcalibre literal">logging.Handler</code> and
use that.</p>
</section>
<section class="calibre2 pcalibre1 pcalibre" title="Record Layout with Formatters">
<h2 id="calibre_link-123" class="pcalibre1 pcalibre calibre1">Record Layout with Formatters</h2>
<p class="pcalibre1 pcalibre calibre7">We haven’t covered one important detail. So far, we’ve only shown you
how to create logger objects that will write just the log message and
nothing else. At the very least, you probably want to annotate that
with the log level. You may also want to insert the time, or some other
information. How do you do that?</p>
<p class="pcalibre1 pcalibre calibre7">The answer is to use a <em class="pcalibre1 calibre8 pcalibre">formatter</em>. A formatter converts a log record
into something that is recorded in the handler’s destination. That’s
an abstract way of saying it; more simply, a typical formatter just
converts the record into a usefully-formatted string. That string
contains the actual log message, as well as the other fields you care
about.</p>
<p class="pcalibre1 pcalibre calibre7">The procedure is to create a <code class="pcalibre1 pcalibre literal">Formatter</code> object, then associate with a
handler (using the latter’s <code class="pcalibre1 pcalibre literal">setHandler</code> method).  Creating a
formatter is easy - it normally takes just one argument, the format
string:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11"><span class="pcalibre1 pcalibre calibre12"></span><span class="pcalibre1 pcalibre calibre18">import</span> <span class="pcalibre1 pcalibre calibre18">logging</span>
my_handler = logging.StreamHandler()
fmt = logging.Formatter(<span class="pcalibre1 pcalibre calibre13">"My message is: </span><span class="pcalibre1 pcalibre calibre20">%(message)s</span><span class="pcalibre1 pcalibre calibre13">"</span>)
my_handler.setFormatter(fmt)
my_logger = logging.getLogger()
my_logger.addHandler(my_handler)
my_logger.warning(<span class="pcalibre1 pcalibre calibre13">"WAKE UP!!"</span>)</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">If you run this in a script, the output will be:</p>
<figure class="pcalibre1 pcalibre listing">
<pre class="pcalibre1 source pcalibre"><code class="pcalibre1 pcalibre calibre11">My message is this: WAKE UP!!</code></pre>
</figure>
<p class="pcalibre1 pcalibre calibre7">Notice the attribute for the message, <code class="pcalibre1 pcalibre literal">%(message)s</code>, included in the
string. This is just a normal formatting string, in the older,
percent-formatting style. It’s exactly equivalent to using the
<code class="pcalibre1 pcalibre literal">format</code> argument when you call <code class="pcalibre1 pcalibre literal">basicConfig</code>. For this reason, you
can use the same attributes, arranged however you like - here’s the
attribute table again, distilled from the
full official list:<sup class="pcalibre1 pcalibre noteref">[<a href="#calibre_link-131" id="calibre_link-137" type="noteref" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">6</a>]</sup></p>
<div class="pcalibre1 pcalibre footnotes">
<div class="pcalibre1 pcalibre content">
<table class="pcalibre1 pcalibre table">
<colgroup class="pcalibre1 calibre22 pcalibre">
<col class="calibre23 pcalibre1 pcalibre"></col>
<col class="calibre23 pcalibre1 pcalibre"></col>
<col class="calibre23 pcalibre1 pcalibre"></col>
</colgroup>
<thead class="pcalibre1 calibre31 pcalibre">
<tr class="pcalibre1 pcalibre calibre25">
<th class="pcalibre1 calibre32 pcalibre">Attribute</th>
<th class="pcalibre1 calibre32 pcalibre">Format</th>
<th class="pcalibre1 calibre32 pcalibre">Description</th>
</tr>
</thead>
<tbody class="pcalibre1 pcalibre calibre24">
<tr class="pcalibre1 pcalibre calibre25">
<td class="pcalibre1 pcalibre calibre26"><p class="pcalibre1 pcalibre calibre27">asctime</p></td>
<td class="pcalibre1 pcalibre calibre26"><p class="pcalibre1 pcalibre calibre27"><code class="pcalibre1 pcalibre literal">%(asctime)s</code></p></td>
<td class="pcalibre1 pcalibre calibre26"><p class="pcalibre1 pcalibre calibre27">Human-readable date/time</p></td>
</tr>
<tr class="pcalibre1 pcalibre calibre25">
<td class="pcalibre1 pcalibre calibre26"><p class="pcalibre1 pcalibre calibre27">funcName</p></td>
<td class="pcalibre1 pcalibre calibre26"><p class="pcalibre1 pcalibre calibre27"><code class="pcalibre1 pcalibre literal">%(funcName)s</code></p></td>
<td class="pcalibre1 pcalibre calibre26"><p class="pcalibre1 pcalibre calibre27">Name of function containing the logging call</p></td>
</tr>
<tr class="pcalibre1 pcalibre calibre25">
<td class="pcalibre1 pcalibre calibre26"><p class="pcalibre1 pcalibre calibre27">lineno</p></td>
<td class="pcalibre1 pcalibre calibre26"><p class="pcalibre1 pcalibre calibre27"><code class="pcalibre1 pcalibre literal">%(lineno)d</code></p></td>
<td class="pcalibre1 pcalibre calibre26"><p class="pcalibre1 pcalibre calibre27">The line number of the logging call</p></td>
</tr>
<tr class="pcalibre1 pcalibre calibre25">
<td class="pcalibre1 pcalibre calibre26"><p class="pcalibre1 pcalibre calibre27">message</p></td>
<td class="pcalibre1 pcalibre calibre26"><p class="pcalibre1 pcalibre calibre27"><code class="pcalibre1 pcalibre literal">%(message)s</code></p></td>
<td class="pcalibre1 pcalibre calibre26"><p class="pcalibre1 pcalibre calibre27">The log message</p></td>
</tr>
<tr class="pcalibre1 pcalibre calibre25">
<td class="pcalibre1 pcalibre calibre26"><p class="pcalibre1 pcalibre calibre27">pathname</p></td>
<td class="pcalibre1 pcalibre calibre26"><p class="pcalibre1 pcalibre calibre27"><code class="pcalibre1 pcalibre literal">%(pathname)s</code></p></td>
<td class="pcalibre1 pcalibre calibre26"><p class="pcalibre1 pcalibre calibre27">Full pathname of the source file of the logging call</p></td>
</tr>
<tr class="pcalibre1 pcalibre calibre25">
<td class="pcalibre1 pcalibre calibre26"><p class="pcalibre1 pcalibre calibre27">levelname</p></td>
<td class="pcalibre1 pcalibre calibre26"><p class="pcalibre1 pcalibre calibre27"><code class="pcalibre1 pcalibre literal">%(levelname)s</code></p></td>
<td class="pcalibre1 pcalibre calibre26"><p class="pcalibre1 pcalibre calibre27">Text logging level for the message ('DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL')</p></td>
</tr>
<tr class="pcalibre1 pcalibre calibre25">
<td class="pcalibre1 pcalibre calibre26"><p class="pcalibre1 pcalibre calibre27">name</p></td>
<td class="pcalibre1 pcalibre calibre26"><p class="pcalibre1 pcalibre calibre27"><code class="pcalibre1 pcalibre literal">%(name)s</code></p></td>
<td class="pcalibre1 pcalibre calibre26"><p class="pcalibre1 pcalibre calibre27">The logger’s name</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</section>
<footer class="pcalibre1 pcalibre calibre15">
<div class="calibre16 pcalibre1 pcalibre"></div><div class="pcalibre1 pcalibre chapter-footer">
<div class="pcalibre1 pcalibre footnotes">
<aside id="calibre_link-126" type="footnote" class="calibre2 pcalibre1 pcalibre">
<p class="pcalibre1 calibre17 pcalibre"><sup class="noteref1 pcalibre1 pcalibre"><a href="#calibre_link-132" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">1</a></sup> These beautifully crisp descriptions, which I cannot improve upon, are taken from <a class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4" href="https://docs.python.org/3/howto/logging.html">https://docs.python.org/3/howto/logging.html</a> .</p>
</aside>
<aside id="calibre_link-127" type="footnote" class="calibre2 pcalibre1 pcalibre">
<p class="pcalibre1 calibre17 pcalibre"><sup class="noteref1 pcalibre1 pcalibre"><a href="#calibre_link-133" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">2</a></sup> These restrictions aren’t in place for logger objects, described later.</p>
</aside>
<aside id="calibre_link-128" type="footnote" class="calibre2 pcalibre1 pcalibre">
<p class="pcalibre1 calibre17 pcalibre"><sup class="noteref1 pcalibre1 pcalibre"><a href="#calibre_link-134" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">3</a></sup> <a class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4" href="https://docs.python.org/3/library/logging.html#logrecord-attributes">https://docs.python.org/3/library/logging.html#logrecord-attributes</a></p>
</aside>
<aside id="calibre_link-129" type="footnote" class="calibre2 pcalibre1 pcalibre">
<p class="pcalibre1 calibre17 pcalibre"><sup class="noteref1 pcalibre1 pcalibre"><a href="#calibre_link-135" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">4</a></sup> <a class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4" href="https://docs.python.org/3/howto/logging-cookbook.html#use-of-alternative-formatting-styles">https://docs.python.org/3/howto/logging-cookbook.html#use-of-alternative-formatting-styles</a></p>
</aside>
<aside id="calibre_link-130" type="footnote" class="calibre2 pcalibre1 pcalibre">
<p class="pcalibre1 calibre17 pcalibre"><sup class="noteref1 pcalibre1 pcalibre"><a href="#calibre_link-136" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">5</a></sup> <a class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4" href="https://docs.python.org/3/library/logging.handlers.html">https://docs.python.org/3/library/logging.handlers.html</a></p>
</aside>
<aside id="calibre_link-131" type="footnote" class="calibre2 pcalibre1 pcalibre">
<p class="pcalibre1 calibre17 pcalibre"><sup class="noteref1 pcalibre1 pcalibre"><a href="#calibre_link-137" class="pcalibre pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4 calibre10">6</a></sup> <a class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4" href="https://docs.python.org/3/library/logging.html#logrecord-attributes">https://docs.python.org/3/library/logging.html#logrecord-attributes</a></p>
</aside>
</div>
</div>
</footer>
</section>
</div>


<div id="calibre_link-0" class="pcalibre1 pcalibre calibre">
<section class="calibre2 pcalibre1 pcalibre" id="calibre_link-124" title="What’s Next?" type="chapter">
<header class="calibre2 pcalibre1 pcalibre">
<div class="pcalibre1 pcalibre chapter-header">
<h1 class="pcalibre1 chapter-title pcalibre"> <small class="subtitle pcalibre1 pcalibre"><b class="pcalibre1 pcalibre calibre6">WHAT’S</b> <b class="pcalibre1 pcalibre calibre6">NEXT?</b></small></h1>
</div>
</header>
<p class="pcalibre1 pcalibre calibre7"><strong class="pcalibre1 pcalibre calibre9">How lucky we are.</strong> Our craft of software is profoundly rewarding -
personally, professionally, financially…​ and in terms of the
massive, positive impact we can have. It’s deeply fulfilling, in ways
those who don’t code may never know.</p>
<p class="pcalibre1 pcalibre calibre7">On top of that, we have a wonderful language like Python to code
in. When I first met   Guido van Rossum in person, I thanked him for creating
my favorite language. If you ever meet him, do the same!</p>
<p class="pcalibre1 pcalibre calibre7">This is not an end. It’s a starting point. And I mean that: I already
have a detailed outline of this book’s 3rd edition, and even some of
the <em class="pcalibre1 calibre8 pcalibre">fourth</em>. And at least <em class="pcalibre1 calibre8 pcalibre">two</em> other completely different
books mapped out, about Python or the broader craft of software
development. <em class="pcalibre1 calibre8 pcalibre">And</em> other media like videos, <em class="pcalibre1 calibre8 pcalibre">and</em> live, in-person
events. All I will say is: keep an eye on powerfulpython.com.</p>
<p class="pcalibre1 pcalibre calibre7">So…​ we’re not done. Maybe you found the hidden message earlier:
"This book is just the beginning. Far more to come." And while I can’t
yet reveal what that fully means, I hope you’re just as excited as I
for the future.</p>
<p class="pcalibre1 pcalibre calibre7">My email is <a class="pcalibre calibre5 pcalibre1 pcalibre3 pcalibre2 pcalibre5 pcalibre4" href="mailto:aaron@powerfulpython.com">aaron@powerfulpython.com</a>.  I know there are topics you
have always wanted to learn about, for Python or programming in
general. As you think of them, tell me; your requests deeply influence
what I create next. Even if I don’t reply (sometimes my inbox just
gets buried), I always carefully read and consider what you have to
say.</p>
<p class="pcalibre1 pcalibre calibre7">Thank you for reading; it is my honor writing for you. My prayer is
that you will find it valuable in your work, your career, even - dare
I hope? - your life. If we ever cross paths, please introduce yourself.
I’d love to meet you.</p>
<p class="pcalibre1 pcalibre calibre7"><strong class="pcalibre1 pcalibre calibre9">Happy coding!</strong></p>
<p class="pcalibre1 calibre7 pcalibre7">Aaron Maxwell</p>
</section>
</div>


</body></html>